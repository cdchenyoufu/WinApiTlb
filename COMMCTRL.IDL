// Common Control types, constants, and functions

// Enums

typedef enum EILC {
	[ helpstring("Use the default behavior if none of the other ILC_COLOR* flags is specified. Typically, the default is ILC_COLOR4; but for older display drivers, the default is ILC_COLORDDB.") ]
    ILC_COLOR            = 0x0000,
	[ helpstring("Uses a mask. The image list contains two bitmaps, one of which is a monochrome bitmap used as a mask. If this value is not included, the image list contains only one bitmap.") ]
    ILC_MASK             = 0x0001,
	[ helpstring("Use a device-dependent bitmap.") ]
    ILC_COLORDDB         = 0x00FE,
	[ helpstring("Use a 4-bit (16 color) device-independent bitmap (DIB) section as the bitmap for the image list.") ]
    ILC_COLOR4           = 0x0004,
	[ helpstring("Use an 8-bit DIB section. The colors used for the color table are the same colors as the halftone palette.") ]
    ILC_COLOR8           = 0x0008,
	[ helpstring("Use a 16-bit (32/64k color) DIB section.") ]
    ILC_COLOR16          = 0x0010,
	[ helpstring("Use a 24-bit DIB section.") ]
    ILC_COLOR24          = 0x0018,
	[ helpstring("Use a 32-bit DIB section.") ]
    ILC_COLOR32          = 0x0020,
    // ILC_PALETTE          = 0x0800   // No longer supported
} EILC;

typedef enum EILD {
	[ helpstring("Draws the image using the background color for the image list. If the background color is the CLR_NONE value, the image is drawn transparently using the mask.") ]
    ILD_NORMAL           = 0x0000,
	[ helpstring("Draws the image transparently using the mask, regardless of the background color. This value has no effect if the image list does not contain a mask.") ]
    ILD_TRANSPARENT      = 0x0001,
	[ helpstring("Draws the mask.") ]
    ILD_MASK             = 0x0010,
    ILD_IMAGE            = 0x0020,
	[ helpstring("Draws the image, blending 25 percent with the system highlight color. This value has no effect if the image list does not contain a mask.") ]
    ILD_BLEND25          = 0x0002,
	[ helpstring("Draws the image, blending 50 percent with the system highlight color. This value has no effect if the image list does not contain a mask.") ]
    ILD_BLEND50          = 0x0004,
	[ helpstring("ImageList Draw Constant: Draw with overlay mask") ]
    ILD_OVERLAYMASK      = 0x0F00,

    // define INDEXTOOVERLAYMASK(i)    ((i) << 8)

	[ helpstring("Draws the image, blending 50 percent with the system highlight color. This value has no effect if the image list does not contain a mask.") ]
    ILD_SELECTED         = 0x0004,
	[ helpstring("Draws the image, blending 25 percent with the system highlight color. This value has no effect if the image list does not contain a mask.") ]
    ILD_FOCUS            = 0x0004,
    ILD_BLEND            = 0x0F00
} EILD;

// Toolbar styles
typedef enum ETBSTYLE {
	[ helpstring("Creates a standard push button.") ]
	TBSTYLE_BUTTON		= 0x0000,
	[ helpstring("Creates a separator, providing a small gap between button groups. A button that has this style does not receive user input.") ]
	TBSTYLE_SEP			= 0x0001,
	[ helpstring("Creates a button that toggles between the pressed and not pressed states each time the user clicks it. The button has a different background color when it is in the pressed state.") ]
	TBSTYLE_CHECK		= 0x0002,
	[ helpstring("Creates a button that stays pressed until another button in the group is pressed.") ]
	TBSTYLE_GROUP		= 0x0004,
	[ helpstring("Creates a check button that stays pressed until another button in the group is pressed.") ]
	TBSTYLE_CHECKGROUP  = (TBSTYLE_GROUP | TBSTYLE_CHECK),
	[ helpstring("Draws a combo box-like drop-down arrow next to the button and, when pressed, the parent window receives a WM_NOTIFY message with the code equal to TBN_DROPDOWN.") ]
	TBSTYLE_DROPDOWN	= 0x0008,
	[ helpstring("Creates a tooltip control that an application	can use to display descriptive text for the buttons in the toolbar.") ]
	TBSTYLE_TOOLTIPS	= 0x0100,
	[ helpstring("Creates a toolbar that can have multiple lines of buttons. Toolbar buttons can “wrap” to the next line when the toolbar becomes too narrow to include all buttons on the same line. Wrapping occurs on separation and non-group boundaries.") ]
	TBSTYLE_WRAPABLE	= 0x0200,
	[ helpstring("Allows the user to change the position of a toolbar button by dragging it while holding down the ALT key.  If this style is not specified, the user must hold down the SHIFT key while dragging a button. CS_ADJUSTABLE must be specified to enable dragging. ") ]
	TBSTYLE_ALTDRAG		= 0x0400,
	[ helpstring("Draws the toolbar without button outlines.  Also makes the ToolBar transparent, which causes the ToolBar buttons to be displayed on the client area of the window underneath the ToolBar. The ToolBar supports hot tracking by default.") ]
	TBSTYLE_FLAT		= 0x0800,
	[ helpstring("Draws the text for the buttons beside them, instead of below them") ]
	TBSTYLE_LIST		= 0x1000,
	TBSTYLE_CUSTOMERASE	= 0x2000,
	TBSTYLE_REGISTERDROP= 0x4000,
	TBSTYLE_TRANSPARENT = 0x8000,
	TBSTYLE_EX_DRAWDDARROWS = 0x0001,

} ETBSTYLE; 
	
// Toolbar states
typedef enum ETBSTATE {
	TBSTATE_CHECKED        = 0x01,
	TBSTATE_PRESSED        = 0x02,
	TBSTATE_ENABLED        = 0x04,
	TBSTATE_HIDDEN         = 0x08,
	TBSTATE_INDETERMINATE  = 0x10,
	TBSTATE_WRAP           = 0x20,
	TBSTATE_ELLIPSES       = 0x40
} ETBSTATE;

typedef enum EIDB {
    IDB_STD_SMALL_COLOR     = 0,
    IDB_STD_LARGE_COLOR     = 1,
    IDB_VIEW_SMALL_COLOR    = 4,
    IDB_VIEW_LARGE_COLOR    = 5,
    IDB_HIST_SMALL_COLOR    = 8,
    IDB_HIST_LARGE_COLOR    = 9
} EIDB;

typedef enum ESTDBMP {
    // icon indexes for standard bitmap
    STD_CUT                 =0,
    STD_COPY                =1,
    STD_PASTE               =2,
    STD_UNDO                =3,
    STD_REDOW               =4,
    STD_DELETE              =5,
    STD_FILENEW             =6,
    STD_FILEOPEN            =7,
    STD_FILESAVE            =8,
    STD_PRINTPRE            =9,
    STD_PROPERTIES          =10,
    STD_HELP                =11,
    STD_FIND                =12,
    STD_REPLACE             =13,
    STD_PRINT               =14,

    // icon indexes for standard view bitmap
    VIEW_LARGEICONS         =0,
    VIEW_SMALLICONS         =1,
    VIEW_LIST               =2,
    VIEW_DETAILS            =3,
    VIEW_SORTNAME           =4,
    VIEW_SORTSIZE           =5,
    VIEW_SORTDATE           =6,
    VIEW_SORTTYPE           =7,
    VIEW_PARENTFOLDER       =8,
    VIEW_NETCONNECT         =9,
    VIEW_NETDISCONNECT      =10,
    VIEW_NEWFOLDER          =11,
    HIST_BACK               =0,
    HIST_FORWARD            =1,
    HIST_FAVORITES          =2,
    HIST_ADDTOFAVORITES     =3,
    HIST_VIEWTREE           =4
} ESTDBMP;

// Types
typedef struct NMCUSTOMDRAW {
    NMHDR hdr;
    DWORD dwDrawStage;
    HDC hdc;
    RECT rc;
    DWORD dwItemSpec;  // this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set
    UINT  uItemState;
    LONG lItemlParam;  // LPARAM 
} NMCUSTOMDRAW, * LPNMCUSTOMDRAW;

typedef struct IMAGEINFO {
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int     Unused1;
    int     Unused2;
    RECT    rcImage;
} IMAGEINFO;

typedef struct IMAGELISTDRAWPARAMS {
    DWORD       cbSize;
    HIMAGELIST  himl;
    int         i;
    HDC         hdcDst;
    int         x;
    int         y;
    int         cx;
    int         cy;
    int         xBitmap;        // x offest from the upperleft of bitmap
    int         yBitmap;        // y offset from the upperleft of bitmap
    COLORREF    rgbBk;
    COLORREF    rgbFg;
    UINT        fStyle;
    DWORD       dwRop;
} IMAGELISTDRAWPARAMS,  * LPIMAGELISTDRAWPARAMS;

typedef struct TBBUTTON {
    int iBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    BYTE bReserved[2];
    DWORD dwData;
    int iString;
} TBBUTTON, * LPTBBUTTON;

typedef struct COLORMAP {
    COLORREF from;
    COLORREF to;
} COLORMAP, * LPCOLORMAP;

typedef struct TBADDBITMAP {
	HINSTANCE       hInst;
    UINT            nID;
} TBADDBITMAP, *LPTBADDBITMAP;

typedef struct TBSAVEPARAMS {
    HKEY hkr;
    PTR /* LPCTSTR */ pszSubKey;
    PTR /* LPCTSTR */ pszValueName;
} TBSAVEPARAMS, * LPTBSAVEPARAMS;

typedef struct TBREPLACEBITMAP {
	HINSTANCE       hInstOld;
	UINT            nIDOld;
    HINSTANCE       hInstNew;
    UINT            nIDNew;
    int             nButtons;
} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;

typedef struct NMTOOLBAR {
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    PTR /* LPTSTR */ pszText;
} NMTOOLBAR, * LPNMTOOLBAR;

typedef struct LVITEM {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	PTR /* LPTSTR */ pszText;
	int cchTextMax;
	int iImage;
	long lParam;	// LPARAM 
	int iIndent;
} LVITEM;																			 

typedef struct LVFINDINFO {
    UINT flags;
    PTR /* LPCTSTR */ psz;
    LONG	lParam; // LPARAM  
    POINTL pt;
    UINT vkDirection;
} LVFINDINFO, * LPFINDINFO;

typedef struct LVHITTESTINFO {
    POINTL pt;
    UINT flags;
    int iItem;

    int iSubItem;    // this is was NOT in win95.  valid only for LVM_SUBITEMHITTEST
} LVHITTESTINFO, * LPLVHITTESTINFO;

typedef struct LVCOLUMN {
    UINT mask;
    int fmt;
    int cx;
    PTR /* LPTSTR */ pszText;
    int cchTextMax;
    int iSubItem;
    int iImage;
    int iOrder;
} LVCOLUMN, * LPLVCOLUMN;

typedef LONG PFNLVCOMPARE;

typedef struct NMLISTVIEW {
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;
    UINT    uOldState;
    UINT    uChanged;
    POINTL  ptAction;
    LONG	lParam; // LPARAM  
} NMLISTVIEW, *LPNMLISTVIEW;

typedef struct NMLVCUSTOMDRAW {
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
    COLORREF clrTextBk;
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;

typedef struct NMLVCACHEHINT {
    NMHDR   hdr;
    int     iFrom;
    int     iTo;
} NMLVCACHEHINT, *LPNMLVCACHEHINT;

typedef struct NMLVFINDITEM {
    NMHDR   hdr;
    int     iStart;
    LVFINDINFO lvfi;
} NMLVFINDITEM, *LPNMLVFINDITEM;

typedef struct NMLVODSTATECHANGE {
    NMHDR hdr;
    int iFrom;
    int iTo;
    UINT uNewState;
    UINT uOldState;
} NMLVODSTATECHANGE, *LPNMLVODSTATECHANGE;

typedef struct LVDISPINFO {
    NMHDR hdr;
    LVITEM item;
} NMLVDISPINFO, *LPNMLVDISPINFO;

typedef struct LVKEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMLVKEYDOWN, *LPNMLVKEYDOWN;


[
#ifdef UNICODE
uuid(64675056-3A82-101B-8181-00AA003743D3),
#else
uuid(64674056-3A82-101B-8181-00AA003743D3),
#endif
helpstring("Common Controls"),
dllname("COMCTL32")
]
module CommonControl {

    //====== Ranges for control message IDs =========
	#define NM_FIRST                (0U-  0U)       // generic to all controls
	#define NM_LAST                 (0U- 99U)
    #define LVM_FIRST               0x1000      // ListView messages
	#define LVN_FIRST               (0U-100U)       // listview
	#define LVN_LAST                (0U-199U)
    #define TV_FIRST                0x1100      // TreeView messages
    #define HDM_FIRST               0x1200      // Header messages

	//====== Generic WM_NOTIFY notification codes =================================

	const DWORD NM_OUTOFMEMORY      = (NM_FIRST-1);
	const DWORD NM_CLICK            = (NM_FIRST-2);
	const DWORD NM_DBLCLK           = (NM_FIRST-3);
	const DWORD NM_RETURN           = (NM_FIRST-4);
	const DWORD NM_RCLICK           = (NM_FIRST-5);
	const DWORD NM_RDBLCLK          = (NM_FIRST-6);
	const DWORD NM_SETFOCUS         = (NM_FIRST-7);
	const DWORD NM_KILLFOCUS        = (NM_FIRST-8);
	const DWORD NM_CUSTOMDRAW       = (NM_FIRST-12);
	const DWORD NM_HOVER            = (NM_FIRST-13);

    #if 0


    //==================== CUSTOM DRAW ==========================================

    // custom draw return flags
    // values under 0x00010000 are reserved for global custom draw values.
    // above that are for specific controls
    #define CDRF_DODEFAULT          0x00000000
    #define CDRF_NEWFONT            0x00000002
    #define CDRF_SKIPDEFAULT        0x00000004


    #define CDRF_NOTIFYPOSTPAINT    0x00000010
    #define CDRF_NOTIFYITEMDRAW     0x00000020
    #define CDRF_NOTIFYPOSTERASE    0x00000040
    #define CDRF_NOTIFYITEMERASE    0x00000080



    // drawstage flags
    // values under 0x00010000 are reserved for global custom draw values.
    // above that are for specific controls
    #define CDDS_PREPAINT           0x00000001
    #define CDDS_POSTPAINT          0x00000002
    #define CDDS_PREERASE           0x00000003
    #define CDDS_POSTERASE          0x00000004
    // the 0x000010000 bit means it's individual item specific
    #define CDDS_ITEM               0x00010000
    #define CDDS_ITEMPREPAINT       (CDDS_ITEM | CDDS_PREPAINT)
    #define CDDS_ITEMPOSTPAINT      (CDDS_ITEM | CDDS_POSTPAINT)
    #define CDDS_ITEMPREERASE       (CDDS_ITEM | CDDS_PREERASE)
    #define CDDS_ITEMPOSTERASE      (CDDS_ITEM | CDDS_POSTERASE)



    // itemState flags
    #define CDIS_SELECTED    0x0001
    #define CDIS_GRAYED      0x0002
    #define CDIS_DISABLED    0x0004
    #define CDIS_CHECKED     0x0008
    #define CDIS_FOCUS       0x0010
    #define CDIS_DEFAULT     0x0020
    #define CDIS_HOT         0x0040



    // for tooltips

    typedef struct NMTTCUSTOMDRAW
    {
        NMCUSTOMDRAW nmcd;
        UINT uDrawFlags;
    } NMTTCUSTOMDRAW, * LPNMTTCUSTOMDRAW;

    #endif

    //====== IMAGE APIS ========

    const DWORD CLR_NONE            = 0xFFFFFFFF;
    const DWORD CLR_DEFAULT         = 0xFF000000;

    [
    usesgetlasterror,
    entry("ImageList_Create"),
    helpstring("Creates a new image list"),
    ]
    HIMAGELIST WINAPI ImageList_Create(int cx, int cy,
                                       UINT flags,
                                       int cInitial,
                                       int cGrow);

    [
    usesgetlasterror,
    entry("ImageList_Destroy"),
    helpstring("Destroys an image list"),
    ]
    BOOL WINAPI ImageList_Destroy(HIMAGELIST himl);

    [
    usesgetlasterror,
    entry("ImageList_GetImageCount"),
    helpstring("Gets the number of images in an image list"),
    ]
    int WINAPI ImageList_GetImageCount(HIMAGELIST himl);

    [
    usesgetlasterror,
    entry("ImageList_Add"),
    helpstring("Adds an image or images to an image list"),
    ]
    int WINAPI ImageList_Add(HIMAGELIST himl,
                             HBITMAP hbmImage,
                             HBITMAP hbmMask);

    [
    usesgetlasterror,
    entry("ImageList_ReplaceIcon"),
    helpstring("Replaces an image with an icon or cursor"),
    ]
    int WINAPI ImageList_ReplaceIcon(HIMAGELIST himl,
                                     int i,
                                     HICON hicon);

    [
    usesgetlasterror,
    entry("ImageList_SetBkColor"),
    helpstring("Sets the image list background color"),
    ]
    COLORREF WINAPI ImageList_SetBkColor(HIMAGELIST himl,
                                         COLORREF clrBk);

    [
    usesgetlasterror,
    entry("ImageList_GetBkColor"),
    helpstring("Gets the image list background color"),
    ]
    COLORREF WINAPI ImageList_GetBkColor(HIMAGELIST himl);

    [
    usesgetlasterror,
    entry("ImageList_SetOverlayImage"),
    helpstring("Adds the index of an image to the list of images to be used as overlay masks"),
    ]
    BOOL WINAPI ImageList_SetOverlayImage(HIMAGELIST himl,
                                          int iImage,
                                          int iOverlay);

    //define ImageList_AddIcon(himl, hicon) 
    //       ImageList_ReplaceIcon(himl, -1, hicon)

    const DWORD CLR_HILIGHT         = 0xFF000000; // -16777216;

    [
    usesgetlasterror,
    entry("ImageList_Draw"),
    helpstring("Draws an image list item in the specified device context"),
    ]
    BOOL WINAPI ImageList_Draw(HIMAGELIST himl,
                               int i, HDC hdcDst,
                               int x, int y,
                               UINT fStyle);

    [
    usesgetlasterror,
    entry("ImageList_Replace"),
    helpstring("Replaces an image in an image list with a new image"),
    ]
    BOOL WINAPI ImageList_Replace(HIMAGELIST himl,
                                  int i,
                                  HBITMAP hbmImage,
                                  HBITMAP hbmMask);

    [
    usesgetlasterror,
    entry("ImageList_AddMasked"),
    helpstring("Adds an image or images to an image list, generating a mask from the specified bitmap"),
    ]
    int WINAPI ImageList_AddMasked(HIMAGELIST himl,
                                   HBITMAP hbmImage,
                                   COLORREF crMask);

    [
    usesgetlasterror,
    entry("ImageList_DrawEx"),
    helpstring("Draws an image list item in the specified device context using the given drawing style and color"),
    ]
    BOOL WINAPI ImageList_DrawEx(HIMAGELIST himl,
                                 int i, HDC hdcDst,
                                 int x, int y,
                                 int dx, int dy,
                                 COLORREF rgbBk,
                                 COLORREF rgbFg,
                                 UINT fStyle);

    [
    usesgetlasterror,
    entry("ImageList_Remove"),
    helpstring("Removes an image from an image list"),
    ]
    BOOL WINAPI ImageList_Remove(HIMAGELIST himl, int i);

    [
    usesgetlasterror,
    entry("ImageList_GetIcon"),
    helpstring("Creates an icon or cursor based on an image and mask in an image list"),
    ]
    HICON WINAPI ImageList_GetIcon(HIMAGELIST himl,
                                   int i, UINT flags);

    [
    usesgetlasterror,
    #ifdef UNICODE
    entry("ImageList_LoadImageW"),
    #else
    entry("ImageList_LoadImageA"),
    #endif
    helpstring("Creates an image list from the specified bitmap, cursor, or icon resource"),
    ]
    HIMAGELIST WINAPI ImageList_LoadImage(HINSTANCE hi,
                                          LPCTSTR lpbmp,
                                          int cx, int cGrow,
                                          COLORREF crMask,
                                          UINT uType, UINT uFlags);

    [
    usesgetlasterror,
    entry("ImageList_BeginDrag"),
    helpstring("Begins dragging an image"),
    ]
    BOOL WINAPI ImageList_BeginDrag(HIMAGELIST himlTrack,
                                    int iTrack,
                                    int dxHotspot,
                                    int dyHotspot);

    [
    usesgetlasterror,
    entry("ImageList_EndDrag"),
    helpstring("Ends a drag operation"),
    ]
    void WINAPI ImageList_EndDrag();

    [
    usesgetlasterror,
    entry("ImageList_DragEnter"),
    helpstring("Updates the specified window during a drag operation and displays the drag image at the specified position"),
    ]
    BOOL WINAPI ImageList_DragEnter(HWND hwndLock,
                                    int x, int y);

    [
    usesgetlasterror,
    entry("ImageList_DragLeave"),
    helpstring("Unlocks the specified window and hides the drag image, allowing the window to be updated"),
    ]
    BOOL WINAPI ImageList_DragLeave(HWND hwndLock);

    [
    usesgetlasterror,
    entry("ImageList_DragMove"),
    helpstring("Moves the image that is being dragged during a drag-and-drop operation"),
    ]
    BOOL WINAPI ImageList_DragMove(int x, int y);

    [
    usesgetlasterror,
    entry("ImageList_SetDragCursorImage"),
    helpstring("Creates a new drag image by combining the specified image (typically a cursor) with the current drag image"),
    ]
    BOOL WINAPI ImageList_SetDragCursorImage(HIMAGELIST himlDrag,
                                             int iDrag,
                                             int dxHotspot,
                                             int dyHotspot);

    [
    usesgetlasterror,
    entry("ImageList_DragShowNolock"),
    helpstring("Shows or hides the image being dragged"),
    ]
    BOOL        WINAPI ImageList_DragShowNolock(BOOL fShow);

    [
    usesgetlasterror,
    entry("ImageList_GetDragImage"),
    helpstring("Retrieves temporary drag image list, position, and offset"),
    ]
    HIMAGELIST  WINAPI ImageList_GetDragImage(int * ppt,
                                              int * pptHotspot);

    // define  ImageList_RemoveAll(himl)
    //         ImageList_Remove(himl, -1)
    // define  ImageList_ExtractIcon(hi, himl, i)
    //         ImageList_GetIcon(himl, i, 0)
    // define  ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask)
    //         ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

    [
    usesgetlasterror,
    entry("ImageList_Read"),
    helpstring("Reads an image list from a stream"),
    ]
    HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm);

    [
    usesgetlasterror,
    entry("ImageList_Write"),
    helpstring("Writes an image list to a stream"),
    ]
    BOOL WINAPI ImageList_Write(HIMAGELIST himl,
                                LPSTREAM pstm);

    [
    usesgetlasterror,
    entry("ImageList_GetIconSize"),
    helpstring("Gets the dimensions of images in an image list"),
    ]
    BOOL WINAPI ImageList_GetIconSize(HIMAGELIST himl,
                                      int * cx,
                                      int *cy);

    [
    usesgetlasterror,
    entry("ImageList_SetIconSize"),
    helpstring("Sets the dimensions of images in an image list"),
    ]
    BOOL WINAPI ImageList_SetIconSize(HIMAGELIST himl,
                                      int cx, int cy);

    [
    usesgetlasterror,
    entry("ImageList_GetImageInfo"),
    helpstring("Gets information about an image"),
    ]
    BOOL WINAPI ImageList_GetImageInfo(HIMAGELIST himl,
                                       int i,
                                       IMAGEINFO * pImageInfo);

    [
    usesgetlasterror,
    entry("ImageList_Merge"),
    helpstring("Creates a new image by combining two existing images, and stores it in a new image list"),
    ]
    HIMAGELIST WINAPI ImageList_Merge(HIMAGELIST himl1, int i1,
                                      HIMAGELIST himl2, int i2,
                                      int dx, int dy);

    //====== HEADER CONTROL ========

    #define NOHEADER
    #ifndef NOHEADER

    #define HDS_HORZ                0x0000
    #define HDS_BUTTONS             0x0002
    #define HDS_HOTTRACK            0x0004
    #define HDS_HIDDEN              0x0008


    #define HDS_DRAGDROP            0x0040
    #define HDS_FULLDRAG            0x0080

    typedef struct HDITEM {
        UINT    mask;
        int     cxy;
        PTR /* LPTSTR */ pszText;
        HBITMAP hbm;
        int     cchTextMax;
        int     fmt;
        LONG	lParam; // LPARAM  
        int     iImage;        // index of bitmap in ImageList
        int     iOrder;        // where to draw this item
    } HDITEM, * LPHDITEM;

    #define HD_ITEM HDITEM


    #define HDI_WIDTH               0x0001
    #define HDI_HEIGHT              HDI_WIDTH
    #define HDI_TEXT                0x0002
    #define HDI_FORMAT              0x0004
    #define HDI_LPARAM              0x0008
    #define HDI_BITMAP              0x0010
    #define HDI_IMAGE               0x0020
    #define HDI_DI_SETITEM          0x0040
    #define HDI_ORDER               0x0080

    #define HDF_LEFT                0
    #define HDF_RIGHT               1
    #define HDF_CENTER              2
    #define HDF_JUSTIFYMASK         0x0003
    #define HDF_RTLREADING          4

    #define HDF_OWNERDRAW           0x8000
    #define HDF_STRING              0x4000
    #define HDF_BITMAP              0x2000
    #define HDF_BITMAP_ON_RIGHT 0x1000

    #define HDF_IMAGE               0x0800

    #define HDM_GETITEMCOUNT        (HDM_FIRST + 0)
    #define Header_GetItemCount(hwndHD) 
        (int)SNDMSG((hwndHD), HDM_GETITEMCOUNT, 0, 0L)


    #define HDM_INSERTITEMA         (HDM_FIRST + 1)
    #define HDM_INSERTITEMW         (HDM_FIRST + 10)

    #ifdef UNICODE
    #define HDM_INSERTITEM          HDM_INSERTITEMW
    #else
    #define HDM_INSERTITEM          HDM_INSERTITEMA
    #endif

    #define Header_InsertItem(hwndHD, i, phdi) 
        (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))


    #define HDM_DELETEITEM          (HDM_FIRST + 2)
    #define Header_DeleteItem(hwndHD, i) 
        (BOOL)SNDMSG((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)


    #define HDM_GETITEMA            (HDM_FIRST + 3)
    #define HDM_GETITEMW            (HDM_FIRST + 11)

    #ifdef UNICODE
    #define HDM_GETITEM             HDM_GETITEMW
    #else
    #define HDM_GETITEM             HDM_GETITEMA
    #endif

    #define Header_GetItem(hwndHD, i, phdi) 
        (BOOL)SNDMSG((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM *)(phdi))


    #define HDM_SETITEMA            (HDM_FIRST + 4)
    #define HDM_SETITEMW            (HDM_FIRST + 12)

    #ifdef UNICODE
    #define HDM_SETITEM             HDM_SETITEMW
    #else
    #define HDM_SETITEM             HDM_SETITEMA
    #endif

    #define Header_SetItem(hwndHD, i, phdi) 
        (BOOL)SNDMSG((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))


    typedef struct HDLAYOUT {
        RECT * prc;
        WINDOWPOS * pwpos;
    } HDLAYOUT, *LPHDLAYOUT;

    #define HD_LAYOUT               HDLAYOUT

    #define HDM_LAYOUT              (HDM_FIRST + 5)
    #define Header_Layout(hwndHD, playout) 
        (BOOL)SNDMSG((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT *)(playout))


    #define HHT_NOWHERE             0x0001
    #define HHT_ONHEADER            0x0002
    #define HHT_ONDIVIDER           0x0004
    #define HHT_ONDIVOPEN           0x0008
    #define HHT_ABOVE               0x0100
    #define HHT_BELOW               0x0200
    #define HHT_TORIGHT             0x0400
    #define HHT_TOLEFT              0x0800

    typedef struct HDHITTESTINFO {
        POINTL pt;
        UINT flags;
        int iItem;
    } HDHITTESTINFO, *LPHDHITTESTINFO;

    #define HD_HITTESTINFO HDHITTESTINFO


    #define HDM_HITTEST             (HDM_FIRST + 6)

    #define HDM_GETITEMRECT         (HDM_FIRST + 7)
    #define Header_GetItemRect(hwnd, iItem, lprc) 
            (BOOL)SNDMSG((hwnd), HDM_GETITEMRECT, (WPARAM)iItem, (LPARAM)lprc)

    #define HDM_SETIMAGELIST        (HDM_FIRST + 8)
    #define Header_SetImageList(hwnd, himl) 
            (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, 0, (LPARAM)himl)

    #define HDM_GETIMAGELIST        (HDM_FIRST + 9)
    #define Header_GetImageList(hwnd) 
            (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, 0, 0)


    #define HDM_ORDERTOINDEX        (HDM_FIRST + 15)
    #define Header_OrderToIndex(hwnd, i) 
            (int)SNDMSG((hwnd), HDM_ORDERTOINDEX, (WPARAM)i, 0)

    #define HDM_CREATEDRAGIMAGE     (HDM_FIRST + 16)  // wparam = which item (by index)
    #define Header_CreateDragImage(hwnd, i) 
            (HIMAGELIST)SNDMSG((hwnd), HDM_CREATEDRAGIMAGE, (WPARAM)i, 0)

    #define HDM_GETORDERARRAY       (HDM_FIRST + 17)
    #define Header_GetOrderArray(hwnd, iCount, lpi) 
            (BOOL)SNDMSG((hwnd), HDM_GETORDERARRAY, (WPARAM)iCount, (LPARAM)lpi)

    #define HDM_SETORDERARRAY       (HDM_FIRST + 18)
    #define Header_SetOrderArray(hwnd, iCount, lpi) 
            (BOOL)SNDMSG((hwnd), HDM_SETORDERARRAY, (WPARAM)iCount, (LPARAM)lpi)
    // lparam = int array of size HDM_GETITEMCOUNT
    // the array specifies the order that all items should be displayed.
    // e.g.  { 2, 0, 1}
    // says the index 2 item should be shown in the 0ths position
    //      index 0 should be shown in the 1st position
    //      index 1 should be shown in the 2nd position


    #define HDM_SETHOTDIVIDER          (HDM_FIRST + 19)
    #define Header_SetHotDivider(hwnd, fPos, dw) 
            (int)SNDMSG((hwnd), HDM_SETHOTDIVIDER, (WPARAM)fPos, (LPARAM)dw)
    // convenience message for external dragdrop
    // wParam = BOOL  specifying whether the lParam is a dwPos of the cursor
    //              position or the index of which divider to hotlight
    // lParam = depends on wParam  (-1 and wParm = FALSE turns off hotlight)

    #define HDN_ITEMCHANGINGA       (HDN_FIRST-0)
    #define HDN_ITEMCHANGINGW       (HDN_FIRST-20)
    #define HDN_ITEMCHANGEDA        (HDN_FIRST-1)
    #define HDN_ITEMCHANGEDW        (HDN_FIRST-21)
    #define HDN_ITEMCLICKA          (HDN_FIRST-2)
    #define HDN_ITEMCLICKW          (HDN_FIRST-22)
    #define HDN_ITEMDBLCLICKA       (HDN_FIRST-3)
    #define HDN_ITEMDBLCLICKW       (HDN_FIRST-23)
    #define HDN_DIVIDERDBLCLICKA    (HDN_FIRST-5)
    #define HDN_DIVIDERDBLCLICKW    (HDN_FIRST-25)
    #define HDN_BEGINTRACKA         (HDN_FIRST-6)
    #define HDN_BEGINTRACKW         (HDN_FIRST-26)
    #define HDN_ENDTRACKA           (HDN_FIRST-7)
    #define HDN_ENDTRACKW           (HDN_FIRST-27)
    #define HDN_TRACKA              (HDN_FIRST-8)
    #define HDN_TRACKW              (HDN_FIRST-28)
    #define HDN_GETDISPINFOA        (HDN_FIRST-9)
    #define HDN_GETDISPINFOW        (HDN_FIRST-29)
    #define HDN_BEGINDRAG           (HDN_FIRST-10)
    #define HDN_ENDDRAG             (HDN_FIRST-11)

    #ifdef UNICODE
    #define HDN_ITEMCHANGING         HDN_ITEMCHANGINGW
    #define HDN_ITEMCHANGED          HDN_ITEMCHANGEDW
    #define HDN_ITEMCLICK            HDN_ITEMCLICKW
    #define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKW
    #define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKW
    #define HDN_BEGINTRACK           HDN_BEGINTRACKW
    #define HDN_ENDTRACK             HDN_ENDTRACKW
    #define HDN_TRACK                HDN_TRACKW
    #define HDN_GETDISPINFO          HDN_GETDISPINFOW
    #else
    #define HDN_ITEMCHANGING         HDN_ITEMCHANGINGA
    #define HDN_ITEMCHANGED          HDN_ITEMCHANGEDA
    #define HDN_ITEMCLICK            HDN_ITEMCLICKA
    #define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKA
    #define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKA
    #define HDN_BEGINTRACK           HDN_BEGINTRACKA
    #define HDN_ENDTRACK             HDN_ENDTRACKA
    #define HDN_TRACK                HDN_TRACKA
    #define HDN_GETDISPINFO          HDN_GETDISPINFOA
    #endif


    typedef struct NMHEADER {
        NMHDR   hdr;
        int     iItem;
        int     iButton;
        HDITEM * pitem;
    }  NMHEADER, * LPNMHEADER;


    typedef struct NMHDDISPINFO {
        NMHDR   hdr;
        int     iItem;
        UINT    mask;
        PTR /* LPTSTR */ pszText;
        int     cchTextMax;
        int     iImage;
        LONG	lParam; // LPARAM  
    } NMHDDISPINFO, * LPNMHDDISPINFO;


    #endif

    //====== TOOLBAR CONTROL =======

    #define TOOLBAR
    #ifndef NOTOOLBAR

    [
    usesgetlasterror,
    entry("CreateToolbarEx"),
    helpstring("Creates a toolbar window and adds the specified buttons to the toolbar"),
    ]
    HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
								HINSTANCE hBMInst, UINT wBMID, LPTBBUTTON lpButtons,
								int iNumButtons, int dxButton, int dyButton,
								int dxBitmap, int dyBitmap, UINT uStructSize);

    [
    usesgetlasterror,
    entry("CreateMappedBitmap"),
    helpstring("Creates a bitmap for use in a toolbar"),
    ]
    HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
                                      UINT wFlags, LPCOLORMAP lpColorMap,
                                      int iNumMaps);

	const int CMB_MASKED              = 0x02;

	//Toolbar Messages
	const int TB_ENABLEBUTTON 			= (WM_USER + 1);
	const int TB_CHECKBUTTON			= (WM_USER + 2);
	const int TB_PRESSBUTTON 			= (WM_USER + 3);
	const int TB_HIDEBUTTON   			= (WM_USER + 4);
	const int TB_INDETERMINATE 			= (WM_USER + 5);
	const int TB_ISBUTTONENABLED		= (WM_USER + 9);
	const int TB_ISBUTTONCHECKED 		= (WM_USER + 10);
	const int TB_ISBUTTONPRESSED		= (WM_USER + 11);
	const int TB_ISBUTTONHIDDEN			= (WM_USER + 12);
	const int TB_ISBUTTONINDETERMINATE	= (WM_USER + 13);
	const int TB_SETSTATE   			= (WM_USER + 17);
	const int TB_GETSTATE    			= (WM_USER + 18);
	const int TB_ADDBITMAP    			= (WM_USER + 19);
	const int TB_ADDBUTTONS    			= (WM_USER + 20);
	const int TB_INSERTBUTTON   		= (WM_USER + 21);
	const int TB_DELETEBUTTON    		= (WM_USER + 22);
	const int TB_GETBUTTON        		= (WM_USER + 23);
	const int TB_BUTTONCOUNT       		= (WM_USER + 24);
	const int TB_COMMANDTOINDEX     	= (WM_USER + 25);
	const int TB_SAVERESTOREA        	= (WM_USER + 26);
	const int TB_CUSTOMIZE     			= (WM_USER + 27);
	const int TB_ADDSTRINGA     		= (WM_USER + 28);
	const int TB_GETITEMRECT      		= (WM_USER + 29);
	const int TB_BUTTONSTRUCTSIZE  		= (WM_USER + 30);
	const int TB_SETBUTTONSIZE      	= (WM_USER + 31);
	const int TB_SETBITMAPSIZE       	= (WM_USER + 32);
	const int TB_AUTOSIZE        		= (WM_USER + 33);
	const int TB_GETTOOLTIPS      		= (WM_USER + 35);
	const int TB_SETTOOLTIPS       		= (WM_USER + 36);
	const int TB_SETPARENT          	= (WM_USER + 37);
	const int TB_SETROWS 				= (WM_USER + 39);
	const int TB_GETROWS  				= (WM_USER + 40);
	const int TB_GETBITMAPFLAGS       	= (WM_USER + 41);
	const int TB_SETCMDID  				= (WM_USER + 42);
	const int TB_CHANGEBITMAP			= (WM_USER + 43);
	const int TB_GETBITMAP				= (WM_USER + 44);
	const int TB_GETBUTTONTEXTA			= (WM_USER + 45);
	const int TB_REPLACEBITMAP   		= (WM_USER + 46);
	const int TB_SETINDENT        		= (WM_USER + 47);
	const int TB_SETIMAGELIST      		= (WM_USER + 48);
	const int TB_GETIMAGELIST       	= (WM_USER + 49);
	const int TB_LOADIMAGES          	= (WM_USER + 50);
	const int TB_GETRECT         		= (WM_USER + 51); // wParam is the Cmd instead of index
	const int TB_SETHOTIMAGELIST  		= (WM_USER + 52);
	const int TB_GETHOTIMAGELIST   		= (WM_USER + 53);
	const int TB_SETDISABLEDIMAGELIST	= (WM_USER + 54);
	const int TB_GETDISABLEDIMAGELIST	= (WM_USER + 55);
	const int TB_SETSTYLE         		= (WM_USER + 56);
	const int TB_GETSTYLE          		= (WM_USER + 57);
	const int TB_GETBUTTONSIZE      	= (WM_USER + 58);
	const int TB_SETBUTTONWIDTH      	= (WM_USER + 59);
	const int TB_SETMAXTEXTROWS 		= (WM_USER + 60);
	const int TB_GETTEXTROWS     		= (WM_USER + 61);
	const int TB_GETBUTTONTEXTW 		= (WM_USER + 75);
	const int TB_SAVERESTOREW         	= (WM_USER + 76);
	const int TB_ADDSTRINGW      		= (WM_USER + 77);

#ifdef UNICODE
	const int TB_GETBUTTONTEXT 			= (WM_USER + 75);
	const int TB_SAVERESTORE        	= (WM_USER + 76);
	const int TB_ADDSTRING      		= (WM_USER + 77);
#else
	const int TB_GETBUTTONTEXT			= (WM_USER + 45);
	const int TB_SAVERESTORE        	= (WM_USER + 26);
	const int TB_ADDSTRING     			= (WM_USER + 28);
#endif

	const int HINST_COMMCTRL          = -1;

	/*
    #define TBBF_LARGE              0x0001

    #define TBN_GETBUTTONINFOA      (TBN_FIRST-0)
    #define TBN_GETBUTTONINFOW      (TBN_FIRST-20)
    #define TBN_BEGINDRAG           (TBN_FIRST-1)
    #define TBN_ENDDRAG             (TBN_FIRST-2)
    #define TBN_BEGINADJUST         (TBN_FIRST-3)
    #define TBN_ENDADJUST           (TBN_FIRST-4)
    #define TBN_RESET               (TBN_FIRST-5)
    #define TBN_QUERYINSERT         (TBN_FIRST-6)
    #define TBN_QUERYDELETE         (TBN_FIRST-7)
    #define TBN_TOOLBARCHANGE       (TBN_FIRST-8)
    #define TBN_CUSTHELP            (TBN_FIRST-9)
    #define TBN_DROPDOWN            (TBN_FIRST - 10)
    #define TBN_CLOSEUP             (TBN_FIRST - 11)

    #ifdef UNICODE
    #define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOW
    #else
    #define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOA
    #endif
	*/

    #endif


    //====== REBAR CONTROL =====

    #define NOREBAR
    #ifndef NOREBAR

    #define RBIM_IMAGELIST  0x00000001

    #define RBS_TOOLTIPS    0x00000100
    #define RBS_VARHEIGHT   0x00000200
    #define RBS_BANDBORDERS 0x00000400
    #define RBS_FIXEDORDER  0x00000800

    typedef struct REBARINFO
    {
        UINT        cbSize;
        UINT        fMask;
        HIMAGELIST  himl;
    }   REBARINFO, *LPREBARINFO;

    #define RBBS_BREAK      0x00000001  // break to new line
    #define RBBS_FIXEDSIZE  0x00000002  // band can't be sized
    #define RBBS_CHILDEDGE  0x00000004  // edge around top & bottom of child window
    #define RBBS_HIDDEN     0x00000008  // don't show
    #define RBBS_NOVERT     0x00000010  // don't show when vertical
    #define RBBS_FIXEDBMP   0x00000020  // bitmap doesn't move during band resize

    #define RBBIM_STYLE     0x00000001
    #define RBBIM_COLORS    0x00000002
    #define RBBIM_TEXT      0x00000004
    #define RBBIM_IMAGE     0x00000008
    #define RBBIM_CHILD     0x00000010
    #define RBBIM_CHILDSIZE 0x00000020
    #define RBBIM_SIZE      0x00000040
    #define RBBIM_BACKGROUND 0x00000080
    #define RBBIM_ID        0x00000100

    typedef struct REBARBANDINFO
    {
        UINT        cbSize;
        UINT        fMask;
        UINT        fStyle;
        COLORREF    clrFore;
        COLORREF    clrBack;
        PTR /* LPTSTR */ lpText;
        UINT        cch;
        int         iImage;
        HWND        hwndChild;
        UINT        cxMinChild;
        UINT        cyMinChild;
        UINT        cx;
        HBITMAP     hbmBack;
        UINT        wID;
    }   REBARBANDINFO, *LPREBARBANDINFO;
    typedef REBARBANDINFO CONST *LPCREBARBANDINFO;

    #define RB_INSERTBANDA  (WM_USER +  1)
    #define RB_DELETEBAND   (WM_USER +  2)
    #define RB_GETBARINFO   (WM_USER +  3)
    #define RB_SETBARINFO   (WM_USER +  4)
    #define RB_GETBANDINFO  (WM_USER +  5)
    #define RB_SETBANDINFOA (WM_USER +  6)
    #define RB_SETPARENT    (WM_USER +  7)
    #define RB_INSERTBANDW  (WM_USER +  10)
    #define RB_SETBANDINFOW (WM_USER +  11)
    #define RB_GETBANDCOUNT (WM_USER +  12)
    #define RB_GETROWCOUNT  (WM_USER +  13)
    #define RB_GETROWHEIGHT (WM_USER +  14)

    #ifdef UNICODE
    #define RB_INSERTBAND   RB_INSERTBANDW
    #define RB_SETBANDINFO   RB_SETBANDINFOW
    #else
    #define RB_INSERTBAND   RB_INSERTBANDA
    #define RB_SETBANDINFO   RB_SETBANDINFOA
    #endif

    #define RBN_HEIGHTCHANGE    (RBN_FIRST - 0)

    #endif

    //====== TOOLTIPS CONTROL ==========

    #define NOTOOLTIPS
    #ifndef NOTOOLTIPS

    typedef struct TOOLINFO {
        UINT cbSize;
        UINT uFlags;
        HWND hwnd;
        UINT uId;
        RECT rect;
        HINSTANCE hinst;
        PTR /* LPTSTR */ lpszText;
        LONG	lParam; // LPARAM  
    } TTTOOLINFO, *LPTTTOOLINFO;


    #define LPTOOLINFO              LPTTTOOLINFO
    #define TOOLINFO                TTTOOLINFO


    #define TTS_ALWAYSTIP           0x01
    #define TTS_NOPREFIX            0x02

    #define TTF_IDISHWND            0x0001

    // Use this to center around trackpoint in trackmode
    // -OR- to center around tool in normal mode.
    // Use TTF_ABSOLUTE to place the tip exactly at the track coords when
    // in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP
    // to center the tip absolutely about the track point.

    #define TTF_CENTERTIP           0x0002
    #define TTF_RTLREADING          0x0004
    #define TTF_SUBCLASS            0x0010
    #define TTF_TRACK               0x0020
    #define TTF_ABSOLUTE            0x0080
    #define TTF_TRANSPARENT         0x0100
    #define TTF_DI_SETITEM          0x8000       // valid only on the TTN_NEEDTEXT callback

    #define TTDT_AUTOMATIC          0
    #define TTDT_RESHOW             1
    #define TTDT_AUTOPOP            2
    #define TTDT_INITIAL            3

    #define TTM_ACTIVATE            (WM_USER + 1)
    #define TTM_SETDELAYTIME        (WM_USER + 3)
    #define TTM_ADDTOOLA            (WM_USER + 4)
    #define TTM_ADDTOOLW            (WM_USER + 50)
    #define TTM_DELTOOLA            (WM_USER + 5)
    #define TTM_DELTOOLW            (WM_USER + 51)
    #define TTM_NEWTOOLRECTA        (WM_USER + 6)
    #define TTM_NEWTOOLRECTW        (WM_USER + 52)
    #define TTM_RELAYEVENT          (WM_USER + 7)

    #define TTM_GETTOOLINFOA        (WM_USER + 8)
    #define TTM_GETTOOLINFOW        (WM_USER + 53)

    #define TTM_SETTOOLINFOA        (WM_USER + 9)
    #define TTM_SETTOOLINFOW        (WM_USER + 54)

    #define TTM_HITTESTA            (WM_USER +10)
    #define TTM_HITTESTW            (WM_USER +55)
    #define TTM_GETTEXTA            (WM_USER +11)
    #define TTM_GETTEXTW            (WM_USER +56)
    #define TTM_UPDATETIPTEXTA      (WM_USER +12)
    #define TTM_UPDATETIPTEXTW      (WM_USER +57)
    #define TTM_GETTOOLCOUNT        (WM_USER +13)
    #define TTM_ENUMTOOLSA          (WM_USER +14)
    #define TTM_ENUMTOOLSW          (WM_USER +58)
    #define TTM_GETCURRENTTOOLA     (WM_USER + 15)
    #define TTM_GETCURRENTTOOLW     (WM_USER + 59)
    #define TTM_WINDOWFROMPOINT     (WM_USER + 16)
    #define TTM_TRACKACTIVATE       (WM_USER + 17)  // wParam = TRUE/FALSE start end  lparam = LPTOOLINFO
    #define TTM_TRACKPOSITION       (WM_USER + 18)  // lParam = dwPos
    #define TTM_SETTIPBKCOLOR       (WM_USER + 19)
    #define TTM_SETTIPTEXTCOLOR     (WM_USER + 20)
    #define TTM_GETDELAYTIME        (WM_USER + 21)
    #define TTM_GETTIPBKCOLOR       (WM_USER + 22)
    #define TTM_GETTIPTEXTCOLOR     (WM_USER + 23)
    #define TTM_SETMAXTIPWIDTH      (WM_USER + 24)
    #define TTM_GETMAXTIPWIDTH      (WM_USER + 25)
    #define TTM_SETMARGIN           (WM_USER + 26)  // lParam = lprc
    #define TTM_GETMARGIN           (WM_USER + 27)  // lParam = lprc
    #define TTM_POP                 (WM_USER + 28)


    #ifdef UNICODE
    #define TTM_ADDTOOL             TTM_ADDTOOLW
    #define TTM_DELTOOL             TTM_DELTOOLW
    #define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTW
    #define TTM_GETTOOLINFO         TTM_GETTOOLINFOW
    #define TTM_SETTOOLINFO         TTM_SETTOOLINFOW
    #define TTM_HITTEST             TTM_HITTESTW
    #define TTM_GETTEXT             TTM_GETTEXTW
    #define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTW
    #define TTM_ENUMTOOLS           TTM_ENUMTOOLSW
    #define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLW
    #else
    #define TTM_ADDTOOL             TTM_ADDTOOLA
    #define TTM_DELTOOL             TTM_DELTOOLA
    #define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTA
    #define TTM_GETTOOLINFO         TTM_GETTOOLINFOA
    #define TTM_SETTOOLINFO         TTM_SETTOOLINFOA
    #define TTM_HITTEST             TTM_HITTESTA
    #define TTM_GETTEXT             TTM_GETTEXTA
    #define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTA
    #define TTM_ENUMTOOLS           TTM_ENUMTOOLSA
    #define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLA
    #endif


    typedef struct TTHITTESTINFO {
        HWND hwnd;
        POINTL pt;
        TTTOOLINFO ti;
    } TTHITTESTINFO, * LPTTHITTESTINFO;

    #define TTN_GETDISPINFOA        (TTN_FIRST - 0)
    #define TTN_GETDISPINFOW        (TTN_FIRST - 10)
    #define TTN_SHOW                (TTN_FIRST - 1)
    #define TTN_POP                 (TTN_FIRST - 2)


    #ifdef UNICODE
    #define TTN_GETDISPINFO         TTN_GETDISPINFOW
    #else
    #define TTN_GETDISPINFO         TTN_GETDISPINFOA
    #endif

    #define TTN_NEEDTEXT            TTN_GETDISPINFO
    #define TTN_NEEDTEXTA           TTN_GETDISPINFOA
    #define TTN_NEEDTEXTW           TTN_GETDISPINFOW


    typedef struct NMTTDISPIFNO {
        NMHDR hdr;
        LPTSTR lpszText;
#ifdef UNICODE
        BYTE szText[80 * 2];
#else
        BYTE szText[80];
#endif
        HINSTANCE hinst;
        UINT uFlags;
        LONG	lParam; // LPARAM  
    } NMTTDISPINFO, *LPNMTTDISPINFO;


    #endif


    //====== STATUS BAR CONTROL ========

    #define NOSTATUSBAR
    #ifndef NOSTATUSBAR

    #define SBARS_SIZEGRIP          0x0100


    void WINAPI DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR pszText, UINT uFlags);
    void WINAPI DrawStatusTextW(HDC hDC, LPRECT lprc, LPCWSTR pszText, UINT uFlags);

    HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
    HWND WINAPI CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);

    #ifdef UNICODE
    #define CreateStatusWindow      CreateStatusWindowW
    #define DrawStatusText          DrawStatusTextW
    #else
    #define CreateStatusWindow      CreateStatusWindowA
    #define DrawStatusText          DrawStatusTextA
    #endif

    #define SB_SETTEXTA             (WM_USER+1)
    #define SB_SETTEXTW             (WM_USER+11)
    #define SB_GETTEXTA             (WM_USER+2)
    #define SB_GETTEXTW             (WM_USER+13)
    #define SB_GETTEXTLENGTHA       (WM_USER+3)
    #define SB_GETTEXTLENGTHW       (WM_USER+12)

    #ifdef UNICODE
    #define SB_GETTEXT              SB_GETTEXTW
    #define SB_SETTEXT              SB_SETTEXTW
    #define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHW
    #else
    #define SB_GETTEXT              SB_GETTEXTA
    #define SB_SETTEXT              SB_SETTEXTA
    #define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHA
    #endif


    #define SB_SETPARTS             (WM_USER+4)
    #define SB_GETPARTS             (WM_USER+6)
    #define SB_GETBORDERS           (WM_USER+7)
    #define SB_SETMINHEIGHT         (WM_USER+8)
    #define SB_SIMPLE               (WM_USER+9)
    #define SB_GETRECT              (WM_USER+10)
    #define SB_ISSIMPLE             (WM_USER+14)


    #define SBT_OWNERDRAW            0x1000
    #define SBT_NOBORDERS            0x0100
    #define SBT_POPOUT               0x0200
    #define SBT_RTLREADING           0x0400

    #endif

    //====== MENU HELP =========

    #define NOMENUHELP
    #ifndef NOMENUHELP

    void WINAPI MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT *lpwIDs);
    BOOL WINAPI ShowHideMenuCtl(HWND hWnd, UINT uFlags, LPINT lpInfo);
    void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo);

    #define MINSYSCOMMAND   SC_SIZE

    #endif


    //====== TRACKBAR CONTROL ==========

    #define NOTRACKBAR
    #ifndef NOTRACKBAR

    #define TBS_AUTOTICKS           0x0001
    #define TBS_VERT                0x0002
    #define TBS_HORZ                0x0000
    #define TBS_TOP                 0x0004
    #define TBS_BOTTOM              0x0000
    #define TBS_LEFT                0x0004
    #define TBS_RIGHT               0x0000
    #define TBS_BOTH                0x0008
    #define TBS_NOTICKS             0x0010
    #define TBS_ENABLESELRANGE      0x0020
    #define TBS_FIXEDLENGTH         0x0040
    #define TBS_NOTHUMB             0x0080
    #define TBS_TOOLTIPS            0x0100

    #define TBM_GETPOS              (WM_USER)
    #define TBM_GETRANGEMIN         (WM_USER+1)
    #define TBM_GETRANGEMAX         (WM_USER+2)
    #define TBM_GETTIC              (WM_USER+3)
    #define TBM_SETTIC              (WM_USER+4)
    #define TBM_SETPOS              (WM_USER+5)
    #define TBM_SETRANGE            (WM_USER+6)
    #define TBM_SETRANGEMIN         (WM_USER+7)
    #define TBM_SETRANGEMAX         (WM_USER+8)
    #define TBM_CLEARTICS           (WM_USER+9)
    #define TBM_SETSEL              (WM_USER+10)
    #define TBM_SETSELSTART         (WM_USER+11)
    #define TBM_SETSELEND           (WM_USER+12)
    #define TBM_GETPTICS            (WM_USER+14)
    #define TBM_GETTICPOS           (WM_USER+15)
    #define TBM_GETNUMTICS          (WM_USER+16)
    #define TBM_GETSELSTART         (WM_USER+17)
    #define TBM_GETSELEND           (WM_USER+18)
    #define TBM_CLEARSEL            (WM_USER+19)
    #define TBM_SETTICFREQ          (WM_USER+20)
    #define TBM_SETPAGESIZE         (WM_USER+21)
    #define TBM_GETPAGESIZE         (WM_USER+22)
    #define TBM_SETLINESIZE         (WM_USER+23)
    #define TBM_GETLINESIZE         (WM_USER+24)
    #define TBM_GETTHUMBRECT        (WM_USER+25)
    #define TBM_GETCHANNELRECT      (WM_USER+26)
    #define TBM_SETTHUMBLENGTH      (WM_USER+27)
    #define TBM_GETTHUMBLENGTH      (WM_USER+28)
    #define TBM_SETTOOLTIPS         (WM_USER+29)
    #define TBM_GETTOOLTIPS         (WM_USER+30)
    #define TBM_SETTIPSIDE          (WM_USER+31)
    // TrackBar Tip Side flags
    #define TBTS_TOP                0
    #define TBTS_LEFT               1
    #define TBTS_BOTTOM             2
    #define TBTS_RIGHT              3

    #define TBM_SETBUDDY            (WM_USER+32) // wparam = BOOL fLeft; (or right)
    #define TBM_GETBUDDY            (WM_USER+33) // wparam = BOOL fLeft; (or right)


    #define TB_LINEUP               0
    #define TB_LINEDOWN             1
    #define TB_PAGEUP               2
    #define TB_PAGEDOWN             3
    #define TB_THUMBPOSITION        4
    #define TB_THUMBTRACK           5
    #define TB_TOP                  6
    #define TB_BOTTOM               7
    #define TB_ENDTRACK             8


    // custom draw item specs
    #define TBCD_TICS    0x0001
    #define TBCD_THUMB   0x0002
    #define TBCD_CHANNEL 0x0003

    #endif // trackbar

    //====== DRAG LIST CONTROL =========

    #define NODRAGLIST
    #ifndef NODRAGLIST

    typedef struct DRAGLISTINFO {
        UINT uNotification;
        HWND hWnd;
        POINTL ptCursor;
    } DRAGLISTINFO, *LPDRAGLISTINFO;

    #define DL_BEGINDRAG            (WM_USER+133)
    #define DL_DRAGGING             (WM_USER+134)
    #define DL_DROPPED              (WM_USER+135)
    #define DL_CANCELDRAG           (WM_USER+136)

    #define DL_CURSORSET            0
    #define DL_STOPCURSOR           1
    #define DL_COPYCURSOR           2
    #define DL_MOVECURSOR           3

    #define DRAGLISTMSGSTRING       TEXT("commctrl_DragListMsg")

    BOOL WINAPI MakeDragList(HWND hLB);
    void WINAPI DrawInsert(HWND handParent, HWND hLB, int nItem);
    int WINAPI LBItemFromPt(HWND hLB, POINTL pt, BOOL bAutoScroll);

    #endif


    //====== UPDOWN CONTROL ============

    #define NOUPDOWN
    #ifndef NOUPDOWN

    typedef struct UDACCEL {
        UINT nSec;
        UINT nInc;
    } UDACCEL, *LPUDACCEL;

    #define UD_MAXVAL               0x7fff
    #define UD_MINVAL               (-UD_MAXVAL)


    #define UDS_WRAP                0x0001
    #define UDS_SETBUDDYINT         0x0002
    #define UDS_ALIGNRIGHT          0x0004
    #define UDS_ALIGNLEFT           0x0008
    #define UDS_AUTOBUDDY           0x0010
    #define UDS_ARROWKEYS           0x0020
    #define UDS_HORZ                0x0040
    #define UDS_NOTHOUSANDS         0x0080
    #define UDS_HOTTRACK            0x0100


    #define UDM_SETRANGE            (WM_USER+101)
    #define UDM_GETRANGE            (WM_USER+102)
    #define UDM_SETPOS              (WM_USER+103)
    #define UDM_GETPOS              (WM_USER+104)
    #define UDM_SETBUDDY            (WM_USER+105)
    #define UDM_GETBUDDY            (WM_USER+106)
    #define UDM_SETACCEL            (WM_USER+107)
    #define UDM_GETACCEL            (WM_USER+108)
    #define UDM_SETBASE             (WM_USER+109)
    #define UDM_GETBASE             (WM_USER+110)


    HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                    HWND hParent, int nID, HINSTANCE hInst,
                                    HWND hBuddy,
                                    int nUpper, int nLower, int nPos);

    typedef struct _NM_UPDOWN
    {
        NMHDR hdr;
        int iPos;
        int iDelta;
    } NMUPDOWN, *LPNMUPDOWN;

    #define NM_UPDOWN NMUPDOWN
    #define LPNM_UPDOWN LPNMUPDOWN

    #define UDN_DELTAPOS            (UDN_FIRST - 1)

    #endif


    //====== PROGRESS CONTROL ==========

    #define NOPROGRESS
    #ifndef NOPROGRESS

    #define PBS_SMOOTH              0x01
    #define PBS_VERTICAL            0x04

    #define PBM_SETRANGE            (WM_USER+1)
    #define PBM_SETPOS              (WM_USER+2)
    #define PBM_DELTAPOS            (WM_USER+3)
    #define PBM_SETSTEP             (WM_USER+4)
    #define PBM_STEPIT              (WM_USER+5)
    #define PBM_SETRANGE32          (WM_USER+6)  // lParam = high, wParam = low
    typedef struct
    {
       int iLow;
       int iHigh;
    } PBRANGE, *PPBRANGE;
    #define PBM_GETRANGE            (WM_USER+7)  // wParam = return (TRUE ? low : high). lParam = PPBRANGE or NULL
    #define PBM_GETPOS              (WM_USER+8)

    #endif


    //====== HOTKEY CONTROL ============

    #define NOHOTKEY
    #ifndef NOHOTKEY

    #define HOTKEYF_SHIFT           0x01
    #define HOTKEYF_CONTROL         0x02
    #define HOTKEYF_ALT             0x04
    #define HOTKEYF_EXT             0x08

    #define HKCOMB_NONE             0x0001
    #define HKCOMB_S                0x0002
    #define HKCOMB_C                0x0004
    #define HKCOMB_A                0x0008
    #define HKCOMB_SC               0x0010
    #define HKCOMB_SA               0x0020
    #define HKCOMB_CA               0x0040
    #define HKCOMB_SCA              0x0080


    #define HKM_SETHOTKEY           (WM_USER+1)
    #define HKM_GETHOTKEY           (WM_USER+2)
    #define HKM_SETRULES            (WM_USER+3)

    #endif


    //====== COMMON CONTROL STYLES =========

	/*
    #define CCS_TOP                 0x00000001L
    #define CCS_NOMOVEY             0x00000002L
    #define CCS_BOTTOM              0x00000003L
    #define CCS_NORESIZE            0x00000004L
    #define CCS_NOPARENTALIGN       0x00000008L
    #define CCS_ADJUSTABLE          0x00000020L
    #define CCS_NODIVIDER           0x00000040L
    #define CCS_VERT                0x00000080L
    #define CCS_LEFT                (CCS_VERT | CCS_TOP)
    #define CCS_RIGHT               (CCS_VERT | CCS_BOTTOM)
    #define CCS_NOMOVEX             (CCS_VERT | CCS_NOMOVEY)
	*/

    //====== LISTVIEW CONTROL ==========

    #define LISTVIEW
    #ifndef NOLISTVIEW


    const DWORD LVS_ICON                = 0x0000;
    const DWORD LVS_REPORT              = 0x0001;
    const DWORD LVS_SMALLICON           = 0x0002;
    const DWORD LVS_LIST                = 0x0003;
    const DWORD LVS_TYPEMASK            = 0x0003;
    const DWORD LVS_SINGLESEL           = 0x0004;
    const DWORD LVS_SHOWSELALWAYS       = 0x0008;
    const DWORD LVS_SORTASCENDING       = 0x0010;
    const DWORD LVS_SORTDESCENDING      = 0x0020;
    const DWORD LVS_SHAREIMAGELISTS     = 0x0040;
    const DWORD LVS_NOLABELWRAP         = 0x0080;
    const DWORD LVS_AUTOARRANGE         = 0x0100;
    const DWORD LVS_EDITLABELS          = 0x0200;
    const DWORD LVS_OWNERDATA           = 0x1000;
    const DWORD LVS_NOSCROLL            = 0x2000;

    const DWORD LVS_TYPESTYLEMASK       = 0xfc00;

    const DWORD LVS_ALIGNTOP            = 0x0000;
    const DWORD LVS_ALIGNLEFT           = 0x0800;
    const DWORD LVS_ALIGNMASK           = 0x0c00;

    const DWORD LVS_OWNERDRAWFIXED      = 0x0400;
    const DWORD LVS_NOCOLUMNHEADER      = 0x4000;
    const DWORD LVS_NOSORTHEADER        = 0x8000;

    const DWORD LVM_GETBKCOLOR          = (LVM_FIRST + 0);
    const DWORD LVM_SETBKCOLOR          = (LVM_FIRST + 1);
    const DWORD LVM_GETIMAGELIST        = (LVM_FIRST + 2);
    const DWORD LVM_SETIMAGELIST        = (LVM_FIRST + 3);
    const DWORD LVM_GETITEMCOUNT        = (LVM_FIRST + 4);
    const DWORD LVM_GETITEMA            = (LVM_FIRST + 5);
    const DWORD LVM_GETITEMW            = (LVM_FIRST + 75);
    const DWORD LVM_SETITEMA            = (LVM_FIRST + 6);
    const DWORD LVM_SETITEMW            = (LVM_FIRST + 76);
    const DWORD LVM_INSERTITEMA         = (LVM_FIRST + 7);
    const DWORD LVM_INSERTITEMW         = (LVM_FIRST + 77);
    const DWORD LVM_DELETEITEM          = (LVM_FIRST + 8);
    const DWORD LVM_DELETEALLITEMS      = (LVM_FIRST + 9);
    const DWORD LVM_GETCALLBACKMASK     = (LVM_FIRST + 10);
    const DWORD LVM_SETCALLBACKMASK     = (LVM_FIRST + 11);
    const DWORD LVM_GETNEXTITEM         = (LVM_FIRST + 12);
    const DWORD LVM_FINDITEMA           = (LVM_FIRST + 13);
    const DWORD LVM_FINDITEMW           = (LVM_FIRST + 83);
    const DWORD LVM_GETITEMRECT        	= (LVM_FIRST + 14);
    const DWORD LVM_SETITEMPOSITION     = (LVM_FIRST + 15);
    const DWORD LVM_GETITEMPOSITION     = (LVM_FIRST + 16);
    const DWORD LVM_GETSTRINGWIDTHA     = (LVM_FIRST + 17);
    const DWORD LVM_GETSTRINGWIDTHW     = (LVM_FIRST + 87);
    const DWORD LVM_HITTEST             = (LVM_FIRST + 18);
    const DWORD LVM_ENSUREVISIBLE       = (LVM_FIRST + 19);
    const DWORD LVM_SCROLL              = (LVM_FIRST + 20);
    const DWORD LVM_REDRAWITEMS         = (LVM_FIRST + 21);
    const DWORD LVM_ARRANGE             = (LVM_FIRST + 22);
    const DWORD LVM_EDITLABELA          = (LVM_FIRST + 23);
    const DWORD LVM_EDITLABELW          = (LVM_FIRST + 118);
    const DWORD LVM_GETEDITCONTROL      = (LVM_FIRST + 24);
    const DWORD LVM_GETCOLUMNA          = (LVM_FIRST + 25);
    const DWORD LVM_GETCOLUMNW          = (LVM_FIRST + 95);
    const DWORD LVM_SETCOLUMNA          = (LVM_FIRST + 26);
    const DWORD LVM_SETCOLUMNW          = (LVM_FIRST + 96);
    const DWORD LVM_INSERTCOLUMNA       = (LVM_FIRST + 27);
    const DWORD LVM_INSERTCOLUMNW       = (LVM_FIRST + 97);
    const DWORD LVM_DELETECOLUMN        = (LVM_FIRST + 28);
    const DWORD LVM_GETCOLUMNWIDTH      = (LVM_FIRST + 29);
    const DWORD LVM_SETCOLUMNWIDTH      = (LVM_FIRST + 30);
    const DWORD LVM_GETHEADER           = (LVM_FIRST + 31);
    const DWORD LVM_CREATEDRAGIMAGE     = (LVM_FIRST + 33);
    const DWORD LVM_GETVIEWRECT         = (LVM_FIRST + 34);
    const DWORD LVM_GETTEXTCOLOR        = (LVM_FIRST + 35);
    const DWORD LVM_SETTEXTCOLOR        = (LVM_FIRST + 36);
    const DWORD LVM_GETTEXTBKCOLOR      = (LVM_FIRST + 37);
    const DWORD LVM_SETTEXTBKCOLOR      = (LVM_FIRST + 38);
    const DWORD LVM_GETTOPINDEX         = (LVM_FIRST + 39);
    const DWORD LVM_GETCOUNTPERPAGE     = (LVM_FIRST + 40);
    const DWORD LVM_GETORIGIN           = (LVM_FIRST + 41);
    const DWORD LVM_UPDATE              = (LVM_FIRST + 42);
    const DWORD LVM_SETITEMSTATE        = (LVM_FIRST + 43);
    const DWORD LVM_GETITEMSTATE        = (LVM_FIRST + 44);
    const DWORD LVM_GETITEMTEXTA        = (LVM_FIRST + 45);
    const DWORD LVM_GETITEMTEXTW        = (LVM_FIRST + 115);
    const DWORD LVM_SETITEMTEXTA        = (LVM_FIRST + 46);
    const DWORD LVM_SETITEMTEXTW        = (LVM_FIRST + 116);
    const DWORD LVM_SETITEMCOUNT        = (LVM_FIRST + 47);
    const DWORD LVM_SORTITEMS           = (LVM_FIRST + 48);
    const DWORD LVM_SETITEMPOSITION32   = (LVM_FIRST + 49);
    const DWORD LVM_GETSELECTEDCOUNT    = (LVM_FIRST + 50);
    const DWORD LVM_GETITEMSPACING      = (LVM_FIRST + 51);
    const DWORD LVM_GETISEARCHSTRINGA   = (LVM_FIRST + 52);
    const DWORD LVM_GETISEARCHSTRINGW   = (LVM_FIRST + 117);
    const DWORD LVM_SETICONSPACING      = (LVM_FIRST + 53);
    const DWORD LVM_SETEXTENDEDLISTVIEWSTYLE = (LVM_FIRST + 54);
    const DWORD LVM_GETEXTENDEDLISTVIEWSTYLE =(LVM_FIRST + 55);
    const DWORD LVM_GETSUBITEMRECT      = (LVM_FIRST + 56);
    const DWORD LVM_SUBITEMHITTEST      = (LVM_FIRST + 57);
    const DWORD LVM_SETCOLUMNORDERARRAY = (LVM_FIRST + 58);
    const DWORD LVM_GETCOLUMNORDERARRAY = (LVM_FIRST + 59);
    const DWORD LVM_SETHOTITEM			= (LVM_FIRST + 60);
    const DWORD LVM_GETHOTITEM			= (LVM_FIRST + 61);
    const DWORD LVM_SETHOTCURSOR		= (LVM_FIRST + 62);
    const DWORD LVM_GETHOTCURSOR		= (LVM_FIRST + 63);
    const DWORD LVM_APPROXIMATEVIEWRECT = (LVM_FIRST + 64);
    const DWORD LVM_SETWORKAREA         = (LVM_FIRST + 65);

	#ifdef UNICODE
    const DWORD LVM_GETITEM             = (LVM_FIRST + 75);
    const DWORD LVM_SETITEM             = (LVM_FIRST + 76);
    const DWORD LVM_INSERTITEM          = (LVM_FIRST + 77);
    const DWORD LVM_FINDITEM            = (LVM_FIRST + 83);
    const DWORD LVM_GETSTRINGWIDTH      = (LVM_FIRST + 87);
    const DWORD LVM_EDITLABEL           = (LVM_FIRST + 118);
    const DWORD LVM_GETCOLUMN           = (LVM_FIRST + 95);
    const DWORD LVM_SETCOLUMN           = (LVM_FIRST + 96);
    const DWORD LVM_INSERTCOLUMN        = (LVM_FIRST + 97);
    const DWORD LVM_GETITEMTEXT         = (LVM_FIRST + 115);
    const DWORD LVM_SETITEMTEXT         = (LVM_FIRST + 116);
    const DWORD LVM_GETISEARCHSTRING    = (LVM_FIRST + 117);
	#else
    const DWORD LVM_GETITEM             = (LVM_FIRST + 5);
    const DWORD LVM_SETITEM             = (LVM_FIRST + 6);
    const DWORD LVM_INSERTITEM          = (LVM_FIRST + 7);
    const DWORD LVM_FINDITEM            = (LVM_FIRST + 13);
    const DWORD LVM_GETSTRINGWIDTH      = (LVM_FIRST + 17);
    const DWORD LVM_EDITLABEL           = (LVM_FIRST + 23);
    const DWORD LVM_GETCOLUMN           = (LVM_FIRST + 25);
    const DWORD LVM_SETCOLUMN           = (LVM_FIRST + 26);
    const DWORD LVM_INSERTCOLUMN        = (LVM_FIRST + 27);
    const DWORD LVM_GETITEMTEXT         = (LVM_FIRST + 45);
    const DWORD LVM_SETITEMTEXT         = (LVM_FIRST + 46);
    const DWORD LVM_GETISEARCHSTRING    = (LVM_FIRST + 52);
	#endif

    const DWORD LVSIL_NORMAL            = 0;
    const DWORD LVSIL_SMALL             = 1;
    const DWORD LVSIL_STATE             = 2;

    const DWORD LVIF_TEXT               = 0x0001;
    const DWORD LVIF_IMAGE              = 0x0002;
    const DWORD LVIF_PARAM              = 0x0004;
    const DWORD LVIF_STATE              = 0x0008;
    const DWORD LVIF_INDENT             = 0x0010;
    const DWORD LVIF_NORECOMPUTE        = 0x0800;

    const DWORD LVIS_FOCUSED            = 0x0001;
    const DWORD LVIS_SELECTED           = 0x0002;
    const DWORD LVIS_CUT                = 0x0004;
    const DWORD LVIS_DROPHILITED        = 0x0008;

    const DWORD LVIS_OVERLAYMASK        = 0x0F00;
    const DWORD LVIS_STATEIMAGEMASK     = 0xF000;

    const DWORD LVNI_ALL                = 0x0000;
    const DWORD LVNI_FOCUSED            = 0x0001;
    const DWORD LVNI_SELECTED           = 0x0002;
   	const DWORD LVNI_CUT                = 0x0004;
    const DWORD LVNI_DROPHILITED        = 0x0008;

    const DWORD LVNI_ABOVE              = 0x0100;
    const DWORD LVNI_BELOW              = 0x0200;
    const DWORD LVNI_TOLEFT             = 0x0400;
    const DWORD LVNI_TORIGHT            = 0x0800;


    //define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)
    const DWORD I_INDENTCALLBACK        = -1;
    const DWORD I_IMAGECALLBACK         = -1;

	/*
    #define LPSTR_TEXTCALLBACKW     ((LPWSTR)-1L)
    #define LPSTR_TEXTCALLBACKA     ((LPSTR)-1L)
    #ifdef UNICODE
    #define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKW
    #else
    #define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKA
    #endif
	*/

    const DWORD LVFI_PARAM              = 0x0001;
    const DWORD LVFI_STRING             = 0x0002;
    const DWORD LVFI_PARTIAL            = 0x0008;
    const DWORD LVFI_WRAP               = 0x0020;
    const DWORD LVFI_NEARESTXY          = 0x0040;

    const LONG LVIR_BOUNDS             = 0;
    const LONG LVIR_ICON               = 1;
    const LONG LVIR_LABEL              = 2;
    const LONG LVIR_SELECTBOUNDS       = 3;

    const DWORD LVHT_NOWHERE            = 0x0001;
    const DWORD LVHT_ONITEMICON         = 0x0002;
    const DWORD LVHT_ONITEMLABEL        = 0x0004;
    const DWORD LVHT_ONITEMSTATEICON    = 0x0008;
    const DWORD LVHT_ONITEM             = 0x000E; // LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON

    const DWORD LVHT_ABOVE              = 0x0008;
    const DWORD LVHT_BELOW              = 0x0010;
    const DWORD LVHT_TORIGHT            = 0x0020;
    const DWORD LVHT_TOLEFT             = 0x0040;

    const DWORD LVA_DEFAULT             = 0x0000;
    const DWORD LVA_ALIGNLEFT           = 0x0001;
    const DWORD LVA_ALIGNTOP            = 0x0002;
    const DWORD LVA_SNAPTOGRID          = 0x0005;

    /*
    //define ListView_GetBkColor(hwnd)  
        (COLORREF)SNDMSG((hwnd), LVM_GETBKCOLOR, 0, 0L)

    //define ListView_SetBkColor(hwnd, clrBk) 
        (BOOL)SNDMSG((hwnd), LVM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))

    //define ListView_GetImageList(hwnd, iImageList) 
        (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)(INT)(iImageList), 0L)
    //define ListView_SetImageList(hwnd, himl, iImageList) 
        (HIMAGELIST)(UINT)SNDMSG((hwnd), LVM_SETIMAGELIST, (WPARAM)(iImageList), (LPARAM)(UINT)(HIMAGELIST)(himl))
    //define ListView_GetItemCount(hwnd) 
        (int)SNDMSG((hwnd), LVM_GETITEMCOUNT, 0, 0L)
    //define ListView_GetItem(hwnd, pitem) 
        (BOOL)SNDMSG((hwnd), LVM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pitem))
    //define ListView_SetItem(hwnd, pitem) 
        (BOOL)SNDMSG((hwnd), LVM_SETITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))
    //define ListView_InsertItem(hwnd, pitem)   
        (int)SNDMSG((hwnd), LVM_INSERTITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))
    //define ListView_DeleteItem(hwnd, i) 
        (BOOL)SNDMSG((hwnd), LVM_DELETEITEM, (WPARAM)(int)(i), 0L)
    //define ListView_DeleteAllItems(hwnd) 
        (BOOL)SNDMSG((hwnd), LVM_DELETEALLITEMS, 0, 0L)
    //define ListView_GetCallbackMask(hwnd) 
        (BOOL)SNDMSG((hwnd), LVM_GETCALLBACKMASK, 0, 0)
    //define ListView_SetCallbackMask(hwnd, mask) 
        (BOOL)SNDMSG((hwnd), LVM_SETCALLBACKMASK, (WPARAM)(UINT)(mask), 0)
    //define ListView_GetNextItem(hwnd, i, flags) 
        (int)SNDMSG((hwnd), LVM_GETNEXTITEM, (WPARAM)(int)(i), MAKELPARAM((flags), 0))
    //define ListView_FindItem(hwnd, iStart, plvfi) 
        (int)SNDMSG((hwnd), LVM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const LV_FINDINFO *)(plvfi))
    //define ListView_GetItemRect(hwnd, i, prc, code) 
         (BOOL)SNDMSG((hwnd), LVM_GETITEMRECT, (WPARAM)(int)(i), 
               ((prc) ? (((RECT *)(prc))->left = (code),(LPARAM)(RECT *)(prc)) : (LPARAM)(RECT *)NULL))
    //define ListView_SetItemPosition(hwndLV, i, x, y) 
        (BOOL)SNDMSG((hwndLV), LVM_SETITEMPOSITION, (WPARAM)(int)(i), MAKELPARAM((x), (y)))
    //define ListView_GetItemPosition(hwndLV, i, ppt) 
        (BOOL)SNDMSG((hwndLV), LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINTL *)(ppt))
    //define ListView_GetStringWidth(hwndLV, psz) 
        (int)SNDMSG((hwndLV), LVM_GETSTRINGWIDTH, 0, (LPARAM)(LPCTSTR)(psz))
    //define ListView_HitTest(hwndLV, pinfo) 
        (int)SNDMSG((hwndLV), LVM_HITTEST, 0, (LPARAM)(LV_HITTESTINFO *)(pinfo))
    //define ListView_EnsureVisible(hwndLV, i, fPartialOK) 
        (BOOL)SNDMSG((hwndLV), LVM_ENSUREVISIBLE, (WPARAM)(int)(i), MAKELPARAM((fPartialOK), 0))
    //define ListView_Scroll(hwndLV, dx, dy) 
        (BOOL)SNDMSG((hwndLV), LVM_SCROLL, (WPARAM)(int)dx, (LPARAM)(int)dy)
    //define ListView_RedrawItems(hwndLV, iFirst, iLast) 
        (BOOL)SNDMSG((hwndLV), LVM_REDRAWITEMS, (WPARAM)(int)iFirst, (LPARAM)(int)iLast)
    //define ListView_Arrange(hwndLV, code) 
        (BOOL)SNDMSG((hwndLV), LVM_ARRANGE, (WPARAM)(UINT)(code), 0L)
    //define ListView_EditLabel(hwndLV, i) 
        (HWND)SNDMSG((hwndLV), LVM_EDITLABEL, (WPARAM)(int)(i), 0L)
    //define ListView_GetEditControl(hwndLV) 
        (HWND)SNDMSG((hwndLV), LVM_GETEDITCONTROL, 0, 0L)
    */

    const long LVCF_FMT					= 0x0001;
    const long LVCF_WIDTH				= 0x0002;
    const long LVCF_TEXT				= 0x0004;
    const long LVCF_SUBITEM				= 0x0008;
    const long LVCF_IMAGE				= 0x0010;
    const long LVCF_ORDER				= 0x0020;

    const long LVCFMT_LEFT				= 0x0000;
    const long LVCFMT_RIGHT				= 0x0001;
    const long LVCFMT_CENTER			= 0x0002;
    const long LVCFMT_JUSTIFYMASK		= 0x0003;
    const long LVCFMT_IMAGE				= 0x0800;
    const long LVCFMT_BITMAP_ON_RIGHT	= 0x1000;
    const long LVCFMT_COL_HAS_IMAGES	= 0x8000;

    /*
    //define ListView_GetColumn(hwnd, iCol, pcol) 
        (BOOL)SNDMSG((hwnd), LVM_GETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(LV_COLUMN *)(pcol))
    //define ListView_SetColumn(hwnd, iCol, pcol) 
        (BOOL)SNDMSG((hwnd), LVM_SETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))
    //define ListView_InsertColumn(hwnd, iCol, pcol) 
        (int)SNDMSG((hwnd), LVM_INSERTCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))
    //define ListView_DeleteColumn(hwnd, iCol) 
        (BOOL)SNDMSG((hwnd), LVM_DELETECOLUMN, (WPARAM)(int)(iCol), 0)
    //define ListView_GetColumnWidth(hwnd, iCol) 
        (int)SNDMSG((hwnd), LVM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)
    */


    const long LVSCW_AUTOSIZE			= -1;
    const long LVSCW_AUTOSIZE_USEHEADER = -2;

    /*
    //define ListView_SetColumnWidth(hwnd, iCol, cx) 
        (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), MAKELPARAM((cx), 0))
    //define ListView_GetHeader(hwnd)
        (HWND)SNDMSG((hwnd), LVM_GETHEADER, 0, 0L)
    //define ListView_CreateDragImage(hwnd, i, lpptUpLeft) 
        (HIMAGELIST)SNDMSG((hwnd), LVM_CREATEDRAGIMAGE, (WPARAM)(int)(i), (LPARAM)(LPPOINT)(lpptUpLeft))
    //define ListView_GetViewRect(hwnd, prc) 
        (BOOL)SNDMSG((hwnd), LVM_GETVIEWRECT, 0, (LPARAM)(RECT *)(prc))
    //define ListView_GetTextColor(hwnd)  
        (COLORREF)SNDMSG((hwnd), LVM_GETTEXTCOLOR, 0, 0L)
    //define ListView_SetTextColor(hwnd, clrText) 
        (BOOL)SNDMSG((hwnd), LVM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))
    //define ListView_GetTextBkColor(hwnd)  
        (COLORREF)SNDMSG((hwnd), LVM_GETTEXTBKCOLOR, 0, 0L)
    //define ListView_SetTextBkColor(hwnd, clrTextBk) 
        (BOOL)SNDMSG((hwnd), LVM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))
    //define ListView_GetTopIndex(hwndLV) 
        (int)SNDMSG((hwndLV), LVM_GETTOPINDEX, 0, 0)
    //define ListView_GetCountPerPage(hwndLV) 
        (int)SNDMSG((hwndLV), LVM_GETCOUNTPERPAGE, 0, 0)
    //define ListView_GetOrigin(hwndLV, ppt) 
        (BOOL)SNDMSG((hwndLV), LVM_GETORIGIN, (WPARAM)0, (LPARAM)(POINTL *)(ppt))
    //define ListView_Update(hwndLV, i) 
        (BOOL)SNDMSG((hwndLV), LVM_UPDATE, (WPARAM)i, 0L)
    //define ListView_SetItemState(hwndLV, i, data, mask) 
    { LV_ITEM _ms_lvi;
      _ms_lvi.stateMask = mask;
      _ms_lvi.state = data;
      SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM *)&_ms_lvi);
    //define ListView_GetItemState(hwndLV, i, mask) 
       (UINT)SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, (LPARAM)mask)
    //define ListView_GetCheckState(hwndLV, i) 
       ((((UINT)(SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, LVIS_STATEIMAGEMASK))) >> 12) -1)
    //define ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) 
    { LV_ITEM _ms_lvi;
      _ms_lvi.iSubItem = iSubItem_;
      _ms_lvi.cchTextMax = cchTextMax_;
      _ms_lvi.pszText = pszText_;
      SNDMSG((hwndLV), LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM *)&_ms_lvi);
    }
    //define ListView_SetItemText(hwndLV, i, iSubItem_, pszText_) 
    { LV_ITEM _ms_lvi;
      _ms_lvi.iSubItem = iSubItem_;
      _ms_lvi.pszText = pszText_;
      SNDMSG((hwndLV), LVM_SETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM *)&_ms_lvi);
    }
    */

    // these flags only apply to LVS_OWNERDATA listviews in report or list mode
    const long LVSICF_NOINVALIDATEALL  = 0x00000001;
    const long LVSICF_NOSCROLL         = 0x00000002;

    /*
    //define ListView_SetItemCount(hwndLV, cItems) 
      SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, 0)
    //define ListView_SetItemCountEx(hwndLV, cItems, dwFlags) 
      SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, (LPARAM)dwFlags)
    // typedef int (CALLBACK *PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);
    //define ListView_SortItems(hwndLV, _pfnCompare, _lPrm) 
      (BOOL)SNDMSG((hwndLV), LVM_SORTITEMS, (WPARAM)(LPARAM)_lPrm, 
      (LPARAM)(PFNLVCOMPARE)_pfnCompare)
    //define ListView_SetItemPosition32(hwndLV, i, x, y) 
    { POINTL ptNewPos = {x,y}; 
        SNDMSG((hwndLV), LVM_SETITEMPOSITION32, (WPARAM)(int)(i), (LPARAM)&ptNewPos); 
    }
    //define ListView_GetSelectedCount(hwndLV) 
        (UINT)SNDMSG((hwndLV), LVM_GETSELECTEDCOUNT, 0, 0L)
    //define ListView_GetItemSpacing(hwndLV, fSmall) 
            (DWORD)SNDMSG((hwndLV), LVM_GETITEMSPACING, fSmall, 0L)
    //define ListView_GetISearchString(hwndLV, lpsz) 
            (BOOL)SNDMSG((hwndLV), LVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)
    // -1 for cx and cy means we'll use the default (system settings)
    // 0 for cx or cy means use the current setting (allows you to change just one param)
    //define ListView_SetIconSpacing(hwndLV, cx, cy) 
            (DWORD)SNDMSG((hwndLV), LVM_SETICONSPACING, 0, MAKELONG(cx,cy))
    //define ListView_SetExtendedListViewStyle(hwndLV, dw)
            (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dw)
    //define ListView_GetExtendedListViewStyle(hwndLV)
            (DWORD)SNDMSG((hwndLV), LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
    */

    const DWORD LVS_EX_GRIDLINES        = 0x00000001;
    const DWORD LVS_EX_SUBITEMIMAGES    = 0x00000002;
    const DWORD LVS_EX_CHECKBOXES       = 0x00000004;
    const DWORD LVS_EX_TRACKSELECT      = 0x00000008;
    const DWORD LVS_EX_HEADERDRAGDROP   = 0x00000010;
    const DWORD LVS_EX_FULLROWSELECT    = 0x00000020; // applies to report mode only
    const DWORD LVS_EX_ONECLICKACTIVATE = 0x00000040;
    const DWORD LVS_EX_TWOCLICKACTIVATE = 0x00000080;
	const DWORD LVS_EX_FLATSB           = 0x00000100; // cannot be cleared
	const DWORD LVS_EX_REGIONAL         = 0x00000200;
	const DWORD LVS_EX_INFOTIP          = 0x00000400; // listview does InfoTips for you

    /*
    //define ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc) 
            (BOOL)SNDMSG((hwnd), LVM_GETSUBITEMRECT, (WPARAM)(int)(iItem), 
                    ((prc) ? ((((LPRECT)(prc))->top = iSubItem), (((LPRECT)(prc))->left = code), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))
    //define ListView_SubItemHitTest(hwnd, plvhti) 
            (int)SNDMSG((hwnd), LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)(plvhti))
    //define ListView_SetColumnOrderArray(hwnd, iCount, pi) 
            (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)iCount, (LPARAM)(LPINT)pi)
    //define ListView_GetColumnOrderArray(hwnd, iCount, pi) 
            (BOOL)SNDMSG((hwnd), LVM_GETCOLUMNORDERARRAY, (WPARAM)iCount, (LPARAM)(LPINT)pi)
    //define ListView_SetHotItem(hwnd, i) 
            (int)SNDMSG((hwnd), LVM_SETHOTITEM, (WPARAM)i, 0)
    //define ListView_GetHotItem(hwnd) 
            (int)SNDMSG((hwnd), LVM_GETHOTITEM, 0, 0)
    //define ListView_SetHotCursor(hwnd, hcur) 
            (HCURSOR)SNDMSG((hwnd), LVM_SETHOTCURSOR, 0, (LPARAM)hcur)
    //define ListView_GetHotCursor(hwnd) 
            (HCURSOR)SNDMSG((hwnd), LVM_GETHOTCURSOR, 0, 0)
    //define ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount) 
            (DWORD)SNDMSG((hwnd), LVM_APPROXIMATEVIEWRECT, iCount, MAKELPARAM(iWidth, iHeight))
    //define ListView_SetWorkArea(hwnd, prc) 
        (BOOL)SNDMSG((hwnd), LVM_SETWORKAREA, 0, (LPARAM)(RECT *)(prc))
    */


    const DWORD LVN_ITEMCHANGING        = (LVN_FIRST-0);
    const DWORD LVN_ITEMCHANGED         = (LVN_FIRST-1);
    const DWORD LVN_INSERTITEM          = (LVN_FIRST-2);
    const DWORD LVN_DELETEITEM          = (LVN_FIRST-3);
    const DWORD LVN_DELETEALLITEMS      = (LVN_FIRST-4);
    const DWORD LVN_BEGINLABELEDITA     = (LVN_FIRST-5);
    const DWORD LVN_BEGINLABELEDITW     = (LVN_FIRST-75);
    const DWORD LVN_ENDLABELEDITA       = (LVN_FIRST-6);
    const DWORD LVN_ENDLABELEDITW       = (LVN_FIRST-76);
    const DWORD LVN_COLUMNCLICK         = (LVN_FIRST-8);
    const DWORD LVN_BEGINDRAG           = (LVN_FIRST-9);
    const DWORD LVN_BEGINRDRAG          = (LVN_FIRST-11);

    const DWORD LVN_ODCACHEHINT         = (LVN_FIRST-13);
    const DWORD LVN_ODFINDITEMA         = (LVN_FIRST-52);
    const DWORD LVN_ODFINDITEMW         = (LVN_FIRST-79);

    const DWORD LVN_ITEMACTIVATE        = (LVN_FIRST-14);
    const DWORD LVN_ODSTATECHANGED      = (LVN_FIRST-15);


    #ifdef UNICODE
    const DWORD LVN_ODFINDITEM         = (LVN_FIRST-52);
    const DWORD LVN_BEGINLABELEDIT     = (LVN_FIRST-75);
    const DWORD LVN_ENDLABELEDIT       = (LVN_FIRST-76);
    #else
    const DWORD LVN_ODFINDITEM         = (LVN_FIRST-79);
    const DWORD LVN_BEGINLABELEDIT     = (LVN_FIRST-5);
    const DWORD LVN_ENDLABELEDIT       = (LVN_FIRST-6);
    #endif

    const DWORD LVN_GETDISPINFOA        = (LVN_FIRST-50);
    const DWORD LVN_GETDISPINFOW        = (LVN_FIRST-77);
    const DWORD LVN_SETDISPINFOA        = (LVN_FIRST-51);
    const DWORD LVN_SETDISPINFOW        = (LVN_FIRST-78);

    #ifdef UNICODE
    const DWORD LVN_GETDISPINFO        = (LVN_FIRST-77);
    const DWORD LVN_SETDISPINFO        = (LVN_FIRST-78);
    #else
    const DWORD LVN_GETDISPINFO        = (LVN_FIRST-50);
    const DWORD LVN_SETDISPINFO        = (LVN_FIRST-51);
    #endif


    const DWORD LVN_KEYDOWN            = (LVN_FIRST-55);
    const DWORD LVN_MARQUEEBEGIN       = (LVN_FIRST-56);


    const DWORD LVIF_DI_SETITEM        = 0x1000;

    #endif

    //====== TREEVIEW CONTROL ==============

    #define NOTREEVIEW
    #ifndef NOTREEVIEW

    #define TVS_HASBUTTONS          0x0001
    #define TVS_HASLINES            0x0002
    #define TVS_LINESATROOT         0x0004
    #define TVS_EDITLABELS          0x0008
    #define TVS_DISABLEDRAGDROP     0x0010
    #define TVS_SHOWSELALWAYS       0x0020
    #define TVS_RTLREADING          0x0040

    #define TVS_NOTOOLTIPS          0x0080
    #define TVS_CHECKBOXES          0x0100
    #define TVS_TRACKSELECT         0x0200

    #define TVS_SHAREDIMAGELISTS    0x0000
    #define TVS_PRIVATEIMAGELISTS   0x0400

    typedef struct _TREEITEM * HTREEITEM;

    #define TVIF_TEXT               0x0001
    #define TVIF_IMAGE              0x0002
    #define TVIF_PARAM              0x0004
    #define TVIF_STATE              0x0008
    #define TVIF_HANDLE             0x0010
    #define TVIF_SELECTEDIMAGE      0x0020
    #define TVIF_CHILDREN           0x0040

    #define TVIS_SELECTED           0x0002
    #define TVIS_CUT                0x0004
    #define TVIS_DROPHILITED        0x0008
    #define TVIS_BOLD               0x0010
    #define TVIS_EXPANDED           0x0020
    #define TVIS_EXPANDEDONCE       0x0040
    #define TVIS_EXPANDPARTIAL      0x0080

    #define TVIS_OVERLAYMASK        0x0F00
    #define TVIS_STATEIMAGEMASK     0xF000
    #define TVIS_USERMASK           0xF000


    #define I_CHILDRENCALLBACK  (-1)

    typedef struct TVITEM {
        UINT      mask;
        HTREEITEM hItem;
        UINT      state;
        UINT      stateMask;
        PTR /* LPTSTR */ pszText;
        int       cchTextMax;
        int       iImage;
        int       iSelectedImage;
        int       cChildren;
        LONG	lParam; // LPARAM  
    } TVITEM, *LPTVITEM;

    #define LPTV_ITEM               LPTVITEM
    #define TV_ITEM                 TVITEM

    #define TVI_ROOT                ((HTREEITEM)0xFFFF0000)
    #define TVI_FIRST               ((HTREEITEM)0xFFFF0001)
    #define TVI_LAST                ((HTREEITEM)0xFFFF0002)
    #define TVI_SORT                ((HTREEITEM)0xFFFF0003)

    typedef struct tagTVINSERTSTRUCTA {
        HTREEITEM hParent;
        HTREEITEM hInsertAfter;
        TV_ITEMA item;
    } TVINSERTSTRUCTA, *LPTVINSERTSTRUCTA;

    typedef struct tagTVINSERTSTRUCTW {
        HTREEITEM hParent;
        HTREEITEM hInsertAfter;
        TV_ITEMW item;
    } TVINSERTSTRUCTW, *LPTVINSERTSTRUCTW;

    #define LPTV_INSERTSTRUCTA      LPTVINSERTSTRUCTA
    #define LPTV_INSERTSTRUCTW      LPTVINSERTSTRUCTW
    #define LPTV_INSERTSTRUCT       LPTVINSERTSTRUCT
    #define TV_INSERTSTRUCTA        TVINSERTSTRUCTA
    #define TV_INSERTSTRUCTW        TVINSERTSTRUCTW
    #define TV_INSERTSTRUCT         TVINSERTSTRUCT

    #ifdef UNICODE
    #define  TVINSERTSTRUCT         TVINSERTSTRUCTW
    #define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTW
    #else
    #define  TVINSERTSTRUCT         TVINSERTSTRUCTA
    #define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTA
    #endif

    #define TVM_INSERTITEMA         (TV_FIRST + 0)
    #define TVM_INSERTITEMW         (TV_FIRST + 50)
    #ifdef UNICODE
    #define  TVM_INSERTITEM         TVM_INSERTITEMW
    #else
    #define  TVM_INSERTITEM         TVM_INSERTITEMA
    #endif

    #define TreeView_InsertItem(hwnd, lpis) 
        (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(lpis))


    #define TVM_DELETEITEM          (TV_FIRST + 1)
    #define TreeView_DeleteItem(hwnd, hitem) 
        (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)(HTREEITEM)(hitem))


    #define TreeView_DeleteAllItems(hwnd) 
        (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)


    #define TVM_EXPAND              (TV_FIRST + 2)
    #define TreeView_Expand(hwnd, hitem, code) 
        (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


    #define TVE_COLLAPSE            0x0001
    #define TVE_EXPAND              0x0002
    #define TVE_TOGGLE              0x0003
    #define TVE_EXPANDPARTIAL       0x4000
    #define TVE_COLLAPSERESET       0x8000


    #define TVM_GETITEMRECT         (TV_FIRST + 4)
    #define TreeView_GetItemRect(hwnd, hitem, prc, code) 
        (*(HTREEITEM *)prc = (hitem), (BOOL)SNDMSG((hwnd), TVM_GETITEMRECT, (WPARAM)(code), (LPARAM)(RECT *)(prc)))


    #define TVM_GETCOUNT            (TV_FIRST + 5)
    #define TreeView_GetCount(hwnd) 
        (UINT)SNDMSG((hwnd), TVM_GETCOUNT, 0, 0)


    #define TVM_GETINDENT           (TV_FIRST + 6)
    #define TreeView_GetIndent(hwnd) 
        (UINT)SNDMSG((hwnd), TVM_GETINDENT, 0, 0)


    #define TVM_SETINDENT           (TV_FIRST + 7)
    #define TreeView_SetIndent(hwnd, indent) 
        (BOOL)SNDMSG((hwnd), TVM_SETINDENT, (WPARAM)indent, 0)


    #define TVM_GETIMAGELIST        (TV_FIRST + 8)
    #define TreeView_GetImageList(hwnd, iImage) 
        (HIMAGELIST)SNDMSG((hwnd), TVM_GETIMAGELIST, iImage, 0)


    #define TVSIL_NORMAL            0
    #define TVSIL_STATE             2


    #define TVM_SETIMAGELIST        (TV_FIRST + 9)
    #define TreeView_SetImageList(hwnd, himl, iImage) 
        (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(UINT)(HIMAGELIST)(himl))


    #define TVM_GETNEXTITEM         (TV_FIRST + 10)
    #define TreeView_GetNextItem(hwnd, hitem, code) 
        (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


    #define TVGN_ROOT               0x0000
    #define TVGN_NEXT               0x0001
    #define TVGN_PREVIOUS           0x0002
    #define TVGN_PARENT             0x0003
    #define TVGN_CHILD              0x0004
    #define TVGN_FIRSTVISIBLE       0x0005
    #define TVGN_NEXTVISIBLE        0x0006
    #define TVGN_PREVIOUSVISIBLE    0x0007
    #define TVGN_DROPHILITE         0x0008
    #define TVGN_CARET              0x0009

    #define TreeView_GetChild(hwnd, hitem)          TreeView_GetNextItem(hwnd, hitem, TVGN_CHILD)
    #define TreeView_GetNextSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXT)
    #define TreeView_GetPrevSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUS)
    #define TreeView_GetParent(hwnd, hitem)         TreeView_GetNextItem(hwnd, hitem, TVGN_PARENT)
    #define TreeView_GetFirstVisible(hwnd)          TreeView_GetNextItem(hwnd, NULL,  TVGN_FIRSTVISIBLE)
    #define TreeView_GetNextVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXTVISIBLE)
    #define TreeView_GetPrevVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUSVISIBLE)
    #define TreeView_GetSelection(hwnd)             TreeView_GetNextItem(hwnd, NULL,  TVGN_CARET)
    #define TreeView_GetDropHilight(hwnd)           TreeView_GetNextItem(hwnd, NULL,  TVGN_DROPHILITE)
    #define TreeView_GetRoot(hwnd)                  TreeView_GetNextItem(hwnd, NULL,  TVGN_ROOT)


    #define TVM_SELECTITEM          (TV_FIRST + 11)
    #define TreeView_Select(hwnd, hitem, code) 
        (HTREEITEM)SNDMSG((hwnd), TVM_SELECTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))


    #define TreeView_SelectItem(hwnd, hitem)            TreeView_Select(hwnd, hitem, TVGN_CARET)
    #define TreeView_SelectDropTarget(hwnd, hitem)      TreeView_Select(hwnd, hitem, TVGN_DROPHILITE)
    #define TreeView_SelectSetFirstVisible(hwnd, hitem) TreeView_Select(hwnd, hitem, TVGN_FIRSTVISIBLE)


    #define TVM_GETITEMA            (TV_FIRST + 12)
    #define TVM_GETITEMW            (TV_FIRST + 62)

    #ifdef UNICODE
    #define  TVM_GETITEM            TVM_GETITEMW
    #else
    #define  TVM_GETITEM            TVM_GETITEMA
    #endif

    #define TreeView_GetItem(hwnd, pitem) 
        (BOOL)SNDMSG((hwnd), TVM_GETITEM, 0, (LPARAM)(TV_ITEM *)(pitem))


    #define TVM_SETITEMA            (TV_FIRST + 13)
    #define TVM_SETITEMW            (TV_FIRST + 63)

    #ifdef UNICODE
    #define  TVM_SETITEM            TVM_SETITEMW
    #else
    #define  TVM_SETITEM            TVM_SETITEMA
    #endif

    #define TreeView_SetItem(hwnd, pitem) 
        (BOOL)SNDMSG((hwnd), TVM_SETITEM, 0, (LPARAM)(const TV_ITEM *)(pitem))


    #define TVM_EDITLABELA          (TV_FIRST + 14)
    #define TVM_EDITLABELW          (TV_FIRST + 65)
    #ifdef UNICODE
    #define TVM_EDITLABEL           TVM_EDITLABELW
    #else
    #define TVM_EDITLABEL           TVM_EDITLABELA
    #endif

    #define TreeView_EditLabel(hwnd, hitem) 
        (HWND)SNDMSG((hwnd), TVM_EDITLABEL, 0, (LPARAM)(HTREEITEM)(hitem))


    #define TVM_GETEDITCONTROL      (TV_FIRST + 15)
    #define TreeView_GetEditControl(hwnd) 
        (HWND)SNDMSG((hwnd), TVM_GETEDITCONTROL, 0, 0)


    #define TVM_GETVISIBLECOUNT     (TV_FIRST + 16)
    #define TreeView_GetVisibleCount(hwnd) 
        (UINT)SNDMSG((hwnd), TVM_GETVISIBLECOUNT, 0, 0)


    #define TVM_HITTEST             (TV_FIRST + 17)
    #define TreeView_HitTest(hwnd, lpht) 
        (HTREEITEM)SNDMSG((hwnd), TVM_HITTEST, 0, (LPARAM)(LPTV_HITTESTINFO)(lpht))


    typedef struct TVHITTESTINFO {
        POINTL      pt;
        UINT        flags;
        HTREEITEM   hItem;
    } TVHITTESTINFO, *LPTVHITTESTINFO;
    #define LPTV_HITTESTINFO        LPTVHITTESTINFO
    #define TV_HITTESTINFO  TVHITTESTINFO

    #define TVHT_NOWHERE            0x0001
    #define TVHT_ONITEMICON         0x0002
    #define TVHT_ONITEMLABEL        0x0004
    #define TVHT_ONITEM             (TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON)
    #define TVHT_ONITEMINDENT       0x0008
    #define TVHT_ONITEMBUTTON       0x0010
    #define TVHT_ONITEMRIGHT        0x0020
    #define TVHT_ONITEMSTATEICON    0x0040

    #define TVHT_ABOVE              0x0100
    #define TVHT_BELOW              0x0200
    #define TVHT_TORIGHT            0x0400
    #define TVHT_TOLEFT             0x0800


    #define TVM_CREATEDRAGIMAGE     (TV_FIRST + 18)
    #define TreeView_CreateDragImage(hwnd, hitem) 
        (HIMAGELIST)SNDMSG((hwnd), TVM_CREATEDRAGIMAGE, 0, (LPARAM)(HTREEITEM)(hitem))


    #define TVM_SORTCHILDREN        (TV_FIRST + 19)
    #define TreeView_SortChildren(hwnd, hitem, recurse) 
        (BOOL)SNDMSG((hwnd), TVM_SORTCHILDREN, (WPARAM)recurse, (LPARAM)(HTREEITEM)(hitem))


    #define TVM_ENSUREVISIBLE       (TV_FIRST + 20)
    #define TreeView_EnsureVisible(hwnd, hitem) 
        (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))


    #define TVM_SORTCHILDRENCB      (TV_FIRST + 21)
    #define TreeView_SortChildrenCB(hwnd, psort, recurse) 
        (BOOL)SNDMSG((hwnd), TVM_SORTCHILDRENCB, (WPARAM)recurse, 
        (LPARAM)(LPTV_SORTCB)(psort))


    #define TVM_ENDEDITLABELNOW     (TV_FIRST + 22)
    #define TreeView_EndEditLabelNow(hwnd, fCancel) 
        (BOOL)SNDMSG((hwnd), TVM_ENDEDITLABELNOW, (WPARAM)fCancel, 0)


    #define TVM_GETISEARCHSTRINGA   (TV_FIRST + 23)
    #define TVM_GETISEARCHSTRINGW   (TV_FIRST + 64)

    #ifdef UNICODE
    #define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGW
    #else
    #define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGA
    #endif

    #define TVM_SETTOOLTIPS         (TV_FIRST + 24)
    #define TVM_GETTOOLTIPS         (TV_FIRST + 25)

    #define TreeView_GetISearchString(hwndTV, lpsz) 
            (BOOL)SNDMSG((hwndTV), TVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)


    typedef int (CALLBACK *PFNTVCOMPARE)(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    typedef struct TVSORTCB {
            HTREEITEM       hParent;
            PFNTVCOMPARE    lpfnCompare;
	        LONG			lParam; // LPARAM  
    } TVSORTCB, *LPTVSORTCB;
    #define LPTV_SORTCB             LPTVSORTCB
    #define TV_SORTCB               TVSORTCB


    typedef struct NMTREEVIEW {
        NMHDR       hdr;
        UINT        action;
        TVITEMA     itemOld;
        TVITEMA     itemNew;
        POINTL      ptDrag;
    } NMTREEVIEW, *LPNMTREEVIEW;


    #define LPNM_TREEVIEW           LPNMTREEVIEW
    #define NM_TREEVIEW             NMTREEVIEW

#ifdef UNICODE
    #define TVN_SELCHANGING        (TVN_FIRST-1)
    #define TVN_SELCHANGED         (TVN_FIRST-2)
#else
    #define TVN_SELCHANGING        (TVN_FIRST-50)
    #define TVN_SELCHANGED         (TVN_FIRST-51)
#endif

    #define TVC_UNKNOWN             0x0000
    #define TVC_BYMOUSE             0x0001
    #define TVC_BYKEYBOARD          0x0002

#ifdef UNICODE
    #define TVN_GETDISPINFO        (TVN_FIRST-3)
    #define TVN_SETDISPINFO        (TVN_FIRST-4)
#else
    #define TVN_GETDISPINFO        (TVN_FIRST-52)
    #define TVN_SETDISPINFO        (TVN_FIRST-53)
#endif

    #define TVIF_DI_SETITEM         0x1000

    typedef struct TVDISPINFOA {
        NMHDR hdr;
        TVITEMA item;
    } NMTVDISPINFOA, *LPNMTVDISPINFOA;

    typedef struct TVDISPINFOW {
        NMHDR hdr;
        TVITEMW item;
    } NMTVDISPINFOW, *LPNMTVDISPINFOW;

    #define TV_DISPINFOA            NMTVDISPINFOA
    #define TV_DISPINFOW            NMTVDISPINFOW
    #define TV_DISPINFO             NMTVDISPINFO

    #ifdef UNICODE
    #define NMTVDISPINFO            NMTVDISPINFOW
    #define LPNMTVDISPINFO          LPNMTVDISPINFOW
    #else
    #define NMTVDISPINFO            NMTVDISPINFOA
    #define LPNMTVDISPINFO          LPNMTVDISPINFOA
    #endif

    #define TVN_ITEMEXPANDINGA      (TVN_FIRST-5)
    #define TVN_ITEMEXPANDINGW      (TVN_FIRST-54)
    #define TVN_ITEMEXPANDEDA       (TVN_FIRST-6)
    #define TVN_ITEMEXPANDEDW       (TVN_FIRST-55)
    #define TVN_BEGINDRAGA          (TVN_FIRST-7)
    #define TVN_BEGINDRAGW          (TVN_FIRST-56)
    #define TVN_BEGINRDRAGA         (TVN_FIRST-8)
    #define TVN_BEGINRDRAGW         (TVN_FIRST-57)
    #define TVN_DELETEITEMA         (TVN_FIRST-9)
    #define TVN_DELETEITEMW         (TVN_FIRST-58)
    #define TVN_BEGINLABELEDITA     (TVN_FIRST-10)
    #define TVN_BEGINLABELEDITW     (TVN_FIRST-59)
    #define TVN_ENDLABELEDITA       (TVN_FIRST-11)
    #define TVN_ENDLABELEDITW       (TVN_FIRST-60)
    #define TVN_KEYDOWN             (TVN_FIRST-12)

    typedef struct TVKEYDOWN {
        NMHDR hdr;
        WORD wVKey;
        UINT flags;
    } NMTVKEYDOWN, *LPNMTVKEYDOWN;

    #define TV_KEYDOWN      NMTVKEYDOWN

    #ifdef UNICODE
    #define TVN_SELCHANGING         TVN_SELCHANGINGW
    #define TVN_SELCHANGED          TVN_SELCHANGEDW
    #define TVN_GETDISPINFO         TVN_GETDISPINFOW
    #define TVN_SETDISPINFO         TVN_SETDISPINFOW
    #define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGW
    #define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDW
    #define TVN_BEGINDRAG           TVN_BEGINDRAGW
    #define TVN_BEGINRDRAG          TVN_BEGINRDRAGW
    #define TVN_DELETEITEM          TVN_DELETEITEMW
    #define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITW
    #define TVN_ENDLABELEDIT        TVN_ENDLABELEDITW
    #else
    #define TVN_SELCHANGING         TVN_SELCHANGINGA
    #define TVN_SELCHANGED          TVN_SELCHANGEDA
    #define TVN_GETDISPINFO         TVN_GETDISPINFOA
    #define TVN_SETDISPINFO         TVN_SETDISPINFOA
    #define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGA
    #define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDA
    #define TVN_BEGINDRAG           TVN_BEGINDRAGA
    #define TVN_BEGINRDRAG          TVN_BEGINRDRAGA
    #define TVN_DELETEITEM          TVN_DELETEITEMA
    #define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITA
    #define TVN_ENDLABELEDIT        TVN_ENDLABELEDITA
    #endif

    typedef struct NMTVCUSTOMDRAW
    {
        NMCUSTOMDRAW nmcd;
        COLORREF     clrText;
        COLORREF     clrTextBk;
    } NMTVCUSTOMDRAW, *LPNMTVCUSTOMDRAW;

    #endif


    ////////////////////  ComboBoxEx ////////////////////////////////

    #if 0

    #define CBEIF_TEXT              0x00000001
    #define CBEIF_IMAGE             0x00000002
    #define CBEIF_SELECTEDIMAGE     0x00000004
    #define CBEIF_OVERLAY           0x00000008
    #define CBEIF_INDENT            0x00000010
    #define CBEIF_LPARAM            0x00000020

    #define CBEIF_DI_SETITEM        0x10000000

    typedef struct COMBOBOXEXITEMA
    {
        UINT mask;
        int iItem;
        LPSTR pszText;
        int cchTextMax;
        int iImage;
        int iSelectedImage;
        int iOverlay;
        int iIndent;
        LONG	lParam; // LPARAM  
    } COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
    typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;


    typedef struct COMBOBOXEXITEMW
    {
        UINT mask;
        int iItem;
        LPWSTR pszText;
        int cchTextMax;
        int iImage;
        int iSelectedImage;
        int iOverlay;
        int iIndent;
        LONG	lParam; // LPARAM  
    } COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
    typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;

    #ifdef UNICODE
    #define COMBOBOXEXITEM            COMBOBOXEXITEMW
    #define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMW
    #define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMW
    #else
    #define COMBOBOXEXITEM            COMBOBOXEXITEMA
    #define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMA
    #define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMA
    #endif

    #define CBEM_INSERTITEMA        (WM_USER + 1)
    #define CBEM_SETIMAGELIST       (WM_USER + 2)
    #define CBEM_GETIMAGELIST       (WM_USER + 3)
    #define CBEM_GETITEMA           (WM_USER + 4)
    #define CBEM_SETITEMA           (WM_USER + 5)
    #define CBEM_DELETEITEM         CB_DELETESTRING
    #define CBEM_GETCOMBOCONTROL    (WM_USER + 6)
    #define CBEM_GETEDITCONTROL     (WM_USER + 7)
    #define CBEM_SETEXSTYLE         (WM_USER + 8)
    #define CBEM_GETEXSTYLE         (WM_USER + 9)
    #define CBEM_HASEDITCHANGED     (WM_USER + 10)
    #define CBEM_INSERTITEMW        (WM_USER + 11)
    #define CBEM_SETITEMW           (WM_USER + 12)
    #define CBEM_GETITEMW           (WM_USER + 13)

    #ifdef UNICODE
    #define CBEM_INSERTITEM         CBEM_INSERTITEMW
    #define CBEM_SETITEM            CBEM_SETITEMW
    #define CBEM_GETITEM            CBEM_GETITEMW
    #else
    #define CBEM_INSERTITEM         CBEM_INSERTITEMA
    #define CBEM_SETITEM            CBEM_SETITEMA
    #define CBEM_GETITEM            CBEM_GETITEMA
    #endif

    #define CBES_EX_NOEDITIMAGE          0x00000001
    #define CBES_EX_NOEDITIMAGEINDENT    0x00000002
    #define CBES_EX_PATHWORDBREAKPROC    0x00000004


    typedef struct {
        NMHDR hdr;
        COMBOBOXEXITEM ceItem;
    } NMCOMBOBOXEX, *PNMCOMBOBOXEX;


    #define CBEN_GETDISPINFO        (CBEN_FIRST - 0)
    #define CBEN_INSERTITEM         (CBEN_FIRST - 1)
    #define CBEN_DELETEITEM         (CBEN_FIRST - 2)
    #define CBEN_BEGINEDIT          (CBEN_FIRST - 4)
    #define CBEN_ENDEDITA            (CBEN_FIRST - 5)
    #define CBEN_ENDEDITW            (CBEN_FIRST - 6)
            // lParam specifies why the endedit is happening
    #ifdef UNICODE
    #define CBEN_ENDEDIT CBEN_ENDEDITW
    #else
    #define CBEN_ENDEDIT CBEN_ENDEDITA
    #endif
    #define CBENF_KILLFOCUS         1
    #define CBENF_RETURN            2
    #define CBENF_ESCAPE            3
    #define CBENF_DROPDOWN          4

    #define CBEMAXSTRLEN 260

    // CBEN_ENDEDIT sends this information...
    // fChanged if the user actually did anything
    // iNewSelection gives what would be the new selection unless the notify is failed
    //                      iNewSelection may be CB_ERR if there's no match
    typedef struct {
            NMHDR hdr;
            BOOL fChanged;
            int iNewSelection;
            WCHAR szText[CBEMAXSTRLEN];
            int iWhy;
    } NMCBEENDEDITW, *PNMCBEENDEDITW;

    typedef struct {
            NMHDR hdr;
            BOOL fChanged;
            int iNewSelection;
            char szText[CBEMAXSTRLEN];
            int iWhy;
    } NMCBEENDEDITA, *PNMCBEENDEDITA;

    #ifdef UNICODE
    #define  NMCBEENDEDIT NMCBEENDEDITW
    #define  PNMCBEENDEDIT PNMCBEENDEDITW
    #else
    #define  NMCBEENDEDIT NMCBEENDEDITA
    #define  PNMCBEENDEDIT PNMCBEENDEDITA
    #endif

    #endif



    //====== TAB CONTROL ===========

    #define NOTABCONTROL
    #ifndef NOTABCONTROL

    #define TCS_SCROLLOPPOSITE      0x0001   // assumes multiline tab
    #define TCS_BOTTOM              0x0002
    #define TCS_RIGHT               0x0002
    #define TCS_MULTISELECT         0x0004  // allow multi-select in button mode
    #define TCS_FORCEICONLEFT       0x0010
    #define TCS_FORCELABELLEFT      0x0020
    #define TCS_HOTTRACK            0x0040
    #define TCS_VERTICAL            0x0080
    #define TCS_TABS                0x0000
    #define TCS_BUTTONS             0x0100
    #define TCS_SINGLELINE          0x0000
    #define TCS_MULTILINE           0x0200
    #define TCS_RIGHTJUSTIFY        0x0000
    #define TCS_FIXEDWIDTH          0x0400
    #define TCS_RAGGEDRIGHT         0x0800
    #define TCS_FOCUSONBUTTONDOWN   0x1000
    #define TCS_OWNERDRAWFIXED      0x2000
    #define TCS_TOOLTIPS            0x4000
    #define TCS_FOCUSNEVER          0x8000

    #define TCM_FIRST               0x1300





    #define TCM_GETIMAGELIST        (TCM_FIRST + 2)
    #define TabCtrl_GetImageList(hwnd) 
        (HIMAGELIST)SNDMSG((hwnd), TCM_GETIMAGELIST, 0, 0L)


    #define TCM_SETIMAGELIST        (TCM_FIRST + 3)
    #define TabCtrl_SetImageList(hwnd, himl) 
        (HIMAGELIST)SNDMSG((hwnd), TCM_SETIMAGELIST, 0, (LPARAM)(UINT)(HIMAGELIST)(himl))


    #define TCM_GETITEMCOUNT        (TCM_FIRST + 4)
    #define TabCtrl_GetItemCount(hwnd) 
        (int)SNDMSG((hwnd), TCM_GETITEMCOUNT, 0, 0L)



    #define TCIF_TEXT               0x0001
    #define TCIF_IMAGE              0x0002
    #define TCIF_RTLREADING         0x0004
    #define TCIF_PARAM              0x0008
    #define TCIF_STATE              0x0010


    #define TCIS_BUTTONPRESSED      0x0001

    typedef struct TCITEMHEADERA
    {
        UINT mask;
        UINT lpReserved1;
        UINT lpReserved2;
        PTR /* LPSTR */ pszText;
        int cchTextMax;
        int iImage;
    } TCITEMHEADERA, *LPTCITEMHEADERA;

    typedef struct TCITEMHEADERW
    {
        UINT mask;
        UINT lpReserved1;
        UINT lpReserved2;
        PTR /* LPWSTR */ pszText;
        int cchTextMax;
        int iImage;
    } TCITEMHEADERW, *LPTCITEMHEADERW;

    #define TC_ITEMHEADERA         TCITEMHEADERA
    #define TC_ITEMHEADERW         TCITEMHEADERW
    #define TC_ITEMHEADER          TCITEMHEADER

    #ifdef UNICODE
    #define  TCITEMHEADER          TCITEMHEADERW
    #define  LPTCITEMHEADER        LPTCITEMHEADERW
    #else
    #define  TCITEMHEADER          TCITEMHEADERA
    #define  LPTCITEMHEADER        LPTCITEMHEADERA
    #endif


    typedef struct tagTCITEMA
    {
        UINT mask;
        DWORD dwState;
        DWORD dwStateMask;
        PTR /* LPSTR */ pszText;
        int cchTextMax;
        int iImage;

        LONG	lParam; // LPARAM  
    } TCITEMA, *LPTCITEMA;

    typedef struct tagTCITEMW
    {
        UINT mask;
        DWORD dwState;
        DWORD dwStateMask;
        PTR /* LPWSTR */ pszText;
        int cchTextMax;
        int iImage;

        LONG	lParam; // LPARAM  
    } TCITEMW, *LPTCITEMW;

    #define TC_ITEMA                TCITEMA
    #define TC_ITEMW                TCITEMW
    #define TC_ITEM                 TCITEM

    #ifdef UNICODE
    #define  TCITEM                 TCITEMW
    #define  LPTCITEM               LPTCITEMW
    #else
    #define  TCITEM                 TCITEMA
    #define  LPTCITEM               LPTCITEMA
    #endif


    #define TCM_GETITEMA            (TCM_FIRST + 5)
    #define TCM_GETITEMW            (TCM_FIRST + 60)

    #ifdef UNICODE
    #define TCM_GETITEM             TCM_GETITEMW
    #else
    #define TCM_GETITEM             TCM_GETITEMA
    #endif

    #define TabCtrl_GetItem(hwnd, iItem, pitem) 
        (BOOL)SNDMSG((hwnd), TCM_GETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM *)(pitem))


    #define TCM_SETITEMA            (TCM_FIRST + 6)
    #define TCM_SETITEMW            (TCM_FIRST + 61)

    #ifdef UNICODE
    #define TCM_SETITEM             TCM_SETITEMW
    #else
    #define TCM_SETITEM             TCM_SETITEMA
    #endif

    #define TabCtrl_SetItem(hwnd, iItem, pitem) 
        (BOOL)SNDMSG((hwnd), TCM_SETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM *)(pitem))


    #define TCM_INSERTITEMA         (TCM_FIRST + 7)
    #define TCM_INSERTITEMW         (TCM_FIRST + 62)

    #ifdef UNICODE
    #define TCM_INSERTITEM          TCM_INSERTITEMW
    #else
    #define TCM_INSERTITEM          TCM_INSERTITEMA
    #endif

    #define TabCtrl_InsertItem(hwnd, iItem, pitem)   
        (int)SNDMSG((hwnd), TCM_INSERTITEM, (WPARAM)(int)iItem, (LPARAM)(const TC_ITEM *)(pitem))


    #define TCM_DELETEITEM          (TCM_FIRST + 8)
    #define TabCtrl_DeleteItem(hwnd, i) 
        (BOOL)SNDMSG((hwnd), TCM_DELETEITEM, (WPARAM)(int)(i), 0L)


    #define TCM_DELETEALLITEMS      (TCM_FIRST + 9)
    #define TabCtrl_DeleteAllItems(hwnd) 
        (BOOL)SNDMSG((hwnd), TCM_DELETEALLITEMS, 0, 0L)


    #define TCM_GETITEMRECT         (TCM_FIRST + 10)
    #define TabCtrl_GetItemRect(hwnd, i, prc) 
        (BOOL)SNDMSG((hwnd), TCM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT *)(prc))


    #define TCM_GETCURSEL           (TCM_FIRST + 11)
    #define TabCtrl_GetCurSel(hwnd) 
        (int)SNDMSG((hwnd), TCM_GETCURSEL, 0, 0)


    #define TCM_SETCURSEL           (TCM_FIRST + 12)
    #define TabCtrl_SetCurSel(hwnd, i) 
        (int)SNDMSG((hwnd), TCM_SETCURSEL, (WPARAM)i, 0)


    #define TCHT_NOWHERE            0x0001
    #define TCHT_ONITEMICON         0x0002
    #define TCHT_ONITEMLABEL        0x0004
    #define TCHT_ONITEM             (TCHT_ONITEMICON | TCHT_ONITEMLABEL)


    typedef struct tagTCHITTESTINFO
    {
        POINTL pt;
        UINT flags;
    } TCHITTESTINFO, * LPTCHITTESTINFO;
    #define LPTC_HITTESTINFO        LPTCHITTESTINFO
    #define TC_HITTESTINFO          TCHITTESTINFO


    #define TCM_HITTEST             (TCM_FIRST + 13)
    #define TabCtrl_HitTest(hwndTC, pinfo) 
        (int)SNDMSG((hwndTC), TCM_HITTEST, 0, (LPARAM)(TC_HITTESTINFO *)(pinfo))


    #define TCM_SETITEMEXTRA        (TCM_FIRST + 14)
    #define TabCtrl_SetItemExtra(hwndTC, cb) 
        (BOOL)SNDMSG((hwndTC), TCM_SETITEMEXTRA, (WPARAM)(cb), 0L)


    #define TCM_ADJUSTRECT          (TCM_FIRST + 40)
    #define TabCtrl_AdjustRect(hwnd, bLarger, prc) 
        (int)SNDMSG(hwnd, TCM_ADJUSTRECT, (WPARAM)(BOOL)bLarger, (LPARAM)(RECT *)prc)


    #define TCM_SETITEMSIZE         (TCM_FIRST + 41)
    #define TabCtrl_SetItemSize(hwnd, x, y) 
        (DWORD)SNDMSG((hwnd), TCM_SETITEMSIZE, 0, MAKELPARAM(x,y))


    #define TCM_REMOVEIMAGE         (TCM_FIRST + 42)
    #define TabCtrl_RemoveImage(hwnd, i) 
            (void)SNDMSG((hwnd), TCM_REMOVEIMAGE, i, 0L)


    #define TCM_SETPADDING          (TCM_FIRST + 43)
    #define TabCtrl_SetPadding(hwnd,  cx, cy) 
            (void)SNDMSG((hwnd), TCM_SETPADDING, 0, MAKELPARAM(cx, cy))


    #define TCM_GETROWCOUNT         (TCM_FIRST + 44)
    #define TabCtrl_GetRowCount(hwnd) 
            (int)SNDMSG((hwnd), TCM_GETROWCOUNT, 0, 0L)


    #define TCM_GETTOOLTIPS         (TCM_FIRST + 45)
    #define TabCtrl_GetToolTips(hwnd) 
            (HWND)SNDMSG((hwnd), TCM_GETTOOLTIPS, 0, 0L)


    #define TCM_SETTOOLTIPS         (TCM_FIRST + 46)
    #define TabCtrl_SetToolTips(hwnd, hwndTT) 
            (void)SNDMSG((hwnd), TCM_SETTOOLTIPS, (WPARAM)hwndTT, 0L)


    #define TCM_GETCURFOCUS         (TCM_FIRST + 47)
    #define TabCtrl_GetCurFocus(hwnd) 
        (int)SNDMSG((hwnd), TCM_GETCURFOCUS, 0, 0)

    #define TCM_SETCURFOCUS         (TCM_FIRST + 48)
    #define TabCtrl_SetCurFocus(hwnd, i) 
        SNDMSG((hwnd),TCM_SETCURFOCUS, i, 0)

    #define TCM_SETMINTABWIDTH      (TCM_FIRST + 49)
    #define TabCtrl_SetMinTabWidth(hwnd, x) 
            (int)SNDMSG((hwnd), TCM_SETMINTABWIDTH, 0, x)


    #define TCM_DESELECTALL         (TCM_FIRST + 50)
    #define TabCtrl_DeselectAll(hwnd, fExcludeFocus)
            (void)SNDMSG((hwnd), TCM_DESELECTALL, fExcludeFocus, 0)

    #define TCN_KEYDOWN             (TCN_FIRST - 0)
    typedef struct tagTCKEYDOWN
    {
        NMHDR hdr;
        WORD wVKey;
        UINT flags;
    } NMTCKEYDOWN;
    #define TC_KEYDOWN              NMTCKEYDOWN

    #define TCN_SELCHANGE           (TCN_FIRST - 1)
    #define TCN_SELCHANGING         (TCN_FIRST - 2)

    #endif


    //====== ANIMATE CONTROL =======

    const LPSTR ANIMATE_CLASS       = "SysAnimate32";

    const UINT ACS_CENTER           = 0x0001;
    const UINT ACS_TRANSPARENT      = 0x0002;
    const UINT ACS_AUTOPLAY         = 0x0004;


    const UINT ACM_OPENA            = WM_USER + 100;
    const UINT ACM_OPEN             = WM_USER + 100;

    const UINT ACM_PLAY             = WM_USER + 101;
    const UINT ACM_STOP             = WM_USER + 102;


    const UINT ACN_START            = 1;
    const UINT ACN_STOP             = 2;


    /*
    #define Animate_Create(hwndP, id, dwStyle, hInstance)  
             CreateWindow(ANIMATE_CLASS, NULL,          
                          dwStyle, 0, 0, 0, 0, hwndP, (HMENU)(id), 
                          hInstance, NULL)

    #define Animate_Open(hwnd, szName)
             (BOOL)SendMessage(hwnd, ACM_OPEN, 0, 
             (LPARAM)(LPTSTR)(szName))

    #define Animate_Play(hwnd, from, to, rep) 
             (BOOL)SendMessage(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), 
             (LPARAM)MAKELONG(from, to))

    #define Animate_Stop(hwnd) 
             (BOOL)SendMessage(hwnd, ACM_STOP, 0, 0)

    #define Animate_Close(hwnd) 
             Animate_Open(hwnd, NULL)

    #define Animate_Seek(hwnd, frame) 
             Animate_Play(hwnd, frame, frame, 1)

    */

    //====== MONTHCAL CONTROL ==========

    #define NOMONTHCAL
    #ifndef NOMONTHCAL

    // bit-packed array of "bold" info for a month
    // if a bit is on, that day is drawn bold
    typedef DWORD MONTHDAYSTATE, * LPMONTHDAYSTATE;


    #define MCM_FIRST           0x1000

    // BOOL MonthCal_GetCurSel(HWND hmc, LPSYSTEMTIME pst)
    //   returns FALSE if MCS_MULTISELECT
    //   returns TRUE and sets *pst to the currently selected date otherwise
    #define MCM_GETCURSEL       (MCM_FIRST + 1)
    #define MonthCal_GetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_GETCURSEL, 0, (LPARAM)(pst))

    // BOOL MonthCal_SetCurSel(HWND hmc, LPSYSTEMTIME pst)
    //   returns FALSE if MCS_MULTISELECT
    //   returns TURE and sets the currently selected date to *pst otherwise
    #define MCM_SETCURSEL       (MCM_FIRST + 2)
    #define MonthCal_SetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_SETCURSEL, 0, (LPARAM)(pst))

    // DWORD MonthCal_GetMaxSelCount(HWND hmc)
    //   returns the maximum number of selectable days allowed
    #define MCM_GETMAXSELCOUNT  (MCM_FIRST + 3)
    #define MonthCal_GetMaxSelCount(hmc)    (DWORD)SNDMSG(hmc, MCM_GETMAXSELCOUNT, 0, 0L)

    // BOOL MonthCal_SetMaxSelCount(HWND hmc, UINT n)
    //   sets the max number days that can be selected iff MCS_MULTISELECT
    #define MCM_SETMAXSELCOUNT  (MCM_FIRST + 4)
    #define MonthCal_SetMaxSelCount(hmc, n) (BOOL)SNDMSG(hmc, MCM_SETMAXSELCOUNT, (WPARAM)(n), 0L)

    // BOOL MonthCal_GetSelRange(HWND hmc, LPSYSTEMTIME rgst)
    //   sets rgst[0] to the first day of the selection range
    //   sets rgst[1] to the last day of the selection range
    #define MCM_GETSELRANGE     (MCM_FIRST + 5)
    #define MonthCal_GetSelRange(hmc, rgst) SNDMSG(hmc, MCM_GETSELRANGE, 0, (LPARAM)(rgst))

    // BOOL MonthCal_SetSelRange(HWND hmc, LPSYSTEMTIME rgst)
    //   selects the range of days from rgst[0] to rgst[1]
    #define MCM_SETSELRANGE     (MCM_FIRST + 6)
    #define MonthCal_SetSelRange(hmc, rgst) SNDMSG(hmc, MCM_SETSELRANGE, 0, (LPARAM)(rgst))

    // DWORD MonthCal_GetMonthRange(HWND hmc, DWORD gmr, LPSYSTEMTIME rgst)
    //   if rgst specified, sets rgst[0] to the starting date and
    //      and rgst[1] to the ending date of the the selectable (non-grayed)
    //      days if GMR_VISIBLE or all the displayed days (including grayed)
    //      if GMR_DAYSTATE.
    //   returns the number of months spanned by the above range.
    #define MCM_GETMONTHRANGE   (MCM_FIRST + 7)
    #define MonthCal_GetMonthRange(hmc, gmr, rgst)  (DWORD)SNDMSG(hmc, MCM_GETMONTHRANGE, (WPARAM)(gmr), (LPARAM)(rgst))

    // BOOL MonthCal_SetDayState(HWND hmc, int cbds, DAYSTATE *rgds)
    //   cbds is the count of DAYSTATE items in rgds and it must be equal
    //   to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL)
    //   This sets the DAYSTATE bits for each month (grayed and non-grayed
    //   days) displayed in the calendar. The first bit in a month's DAYSTATE
    //   corresponts to bolding day 1, the second bit affects day 2, etc.
    #define MCM_SETDAYSTATE     (MCM_FIRST + 8)
    #define MonthCal_SetDayState(hmc, cbds, rgds)   SNDMSG(hmc, MCM_SETDAYSTATE, (WPARAM)(cbds), (LPARAM)(rgds))

    // BOOL MonthCal_GetMinReqRect(HWND hmc, LPRECT prc)
    //   sets *prc the minimal size needed to display one month
    #define MCM_GETMINREQRECT   (MCM_FIRST + 9)
    #define MonthCal_GetMinReqRect(hmc, prc)        SNDMSG(hmc, MCM_GETMINREQRECT, 0, (LPARAM)(prc))

    // set what day is "today"   send NULL to revert back to real date
    #define MCM_SETTODAY    (MCM_FIRST + 12)
    #define MonthCal_SetToday(hmc, pst)             SNDMSG(hmc, MCM_SETTODAY, 0, (LPARAM)pst)

    // get what day is "today"
    // returns BOOL for success/failure
    #define MCM_GETTODAY    (MCM_FIRST + 13)
    #define MonthCal_GetToday(hmc, pst)             (BOOL)SNDMSG(hmc, MCM_GETTODAY, 0, (LPARAM)pst)

    // determine what pinfo->pt is over
    #define MCM_HITTEST          (MCM_FIRST + 14)
    #define MonthCal_HitTest(hmc, pinfo) 
            SNDMSG(hmc, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)pinfo)

    typedef struct {
            UINT cbSize;
            POINTL pt;

            UINT uHit;   // out param
            SYSTEMTIME st;
    } MCHITTESTINFO, *PMCHITTESTINFO;

    #define MCHT_TITLE                      0x00010000
    #define MCHT_CALENDAR                   0x00020000
    #define MCHT_TODAYLINK                  0x00030000

    #define MCHT_NEXT                       0x01000000   // these indicate that hitting
    #define MCHT_PREV                       0x02000000  // here will go to the next/prev month

    #define MCHT_NOWHERE                    0x00000000

    #define MCHT_TITLEBK                    (MCHT_TITLE)
    #define MCHT_TITLEMONTH                 (MCHT_TITLE | 0x0001)
    #define MCHT_TITLEYEAR                  (MCHT_TITLE | 0x0002)
    #define MCHT_TITLEBTNNEXT               (MCHT_TITLE | MCHT_NEXT | 0x0003)
    #define MCHT_TITLEBTNPREV               (MCHT_TITLE | MCHT_PREV | 0x0003)

    #define MCHT_CALENDARBK                 (MCHT_CALENDAR)
    #define MCHT_CALENDARDATE               (MCHT_CALENDAR | 0x0001)
    #define MCHT_CALENDARDATENEXT           (MCHT_CALENDARDATE | MCHT_NEXT)
    #define MCHT_CALENDARDATEPREV           (MCHT_CALENDARDATE | MCHT_PREV)
    #define MCHT_CALENDARDAY                (MCHT_CALENDAR | 0x0002)
    #define MCHT_CALENDARWEEKNUM            (MCHT_CALENDAR | 0x0003)

    // set colors to draw control with -- see MCSC_ bits below
    #define MCM_SETCOLOR            (MCM_FIRST + 10)
    #define MonthCal_SetColor(hmc, iColor, clr) SNDMSG(hmc, MCM_SETCOLOR, iColor, clr)

    #define MCM_GETCOLOR            (MCM_FIRST + 11)
    #define MonthCal_GetColor(hmc, iColor) SNDMSG(hmc, MCM_SETCOLOR, iColor, 0)

    #define MCSC_BACKGROUND   0   // the background color (between months)
    #define MCSC_TEXT         1   // the dates
    #define MCSC_TITLEBK      2   // background of the title
    #define MCSC_TITLETEXT    3
    #define MCSC_MONTHBK      4   // background within the month cal
    #define MCSC_TRAILINGTEXT 5   // the text color of header & trailing days

    // set first day of week to iDay:
    // 0 for Monday, 1 for Tuesday, ..., 6 for Sunday
    // -1 for means use locale info
    #define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST + 15)
    #define MonthCal_SetFirstDayOfWeek(hmc, iDay) 
            SNDMSG(hmc, MCM_SETFIRSTDAYOFWEEK, 0, iDay)

    // DWORD result...  low word has the day.  high word is bool if this is app set
    // or not (FALSE == using locale info)
    #define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST + 16)
    #define MonthCal_GetFirstDayOfWeek(hmc) 
            (DWORD)SNDMSG(hmc, MCM_GETFIRSTDAYOFWEEK, 0, 0)

    // DWORD MonthCal_GetRange(HWND hmc, LPSYSTEMTIME rgst)
    //   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
    //   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
    //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
    #define MCM_GETRANGE (MCM_FIRST + 17)
    #define MonthCal_GetRange(hmc, rgst) 
            (DWORD)SNDMSG(hmc, MCM_GETRANGE, 0, (LPARAM)(rgst))

    // BOOL MonthCal_SetRange(HWND hmc, DWORD gdtr, LPSYSTEMTIME rgst)
    //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
    //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
    //   returns TRUE on success, FALSE on error (such as invalid parameters)
    #define MCM_SETRANGE (MCM_FIRST + 18)
    #define MonthCal_SetRange(hmc, gd, rgst) 
            (BOOL)SNDMSG(hmc, MCM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

    // int MonthCal_GetMonthDelta(HWND hmc)
    //   returns the number of months one click on a next/prev button moves by
    #define MCM_GETMONTHDELTA (MCM_FIRST + 19)
    #define MonthCal_GetMonthDelta(hmc) 
            (int)SNDMSG(hmc, MCM_GETMONTHDELTA, 0, 0)

    // int MonthCal_SetMonthDelta(HWND hmc, int n)
    //   sets the month delta to n. n==0 reverts to moving by a page of months
    //   returns the previous value of n.
    #define MCM_SETMONTHDELTA (MCM_FIRST + 20)
    #define MonthCal_SetMonthDelta(hmc, n) 
            (int)SNDMSG(hmc, MCM_SETMONTHDELTA, n, 0)


    // MCN_SELCHANGE is sent whenever the currently displayed date changes
    // via month change, year change, keyboard navigation, prev/next button
    //
    typedef struct NMSELCHANGE
    {
        NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

        SYSTEMTIME      stSelStart;
        SYSTEMTIME      stSelEnd;
    } NMSELCHANGE, * LPNMSELCHANGE;

    #define MCN_SELCHANGE       (MCN_FIRST + 1)

    // MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate
    // information is needed (month or year scroll) to draw bolding information.
    // The app must fill in cDayState months worth of information starting from
    // stStart date. The app may fill in the array at prgDayState or change
    // prgDayState to point to a different array out of which the information
    // will be copied. (similar to tooltips)
    //
    typedef struct tagNMDAYSTATE
    {
        NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

        SYSTEMTIME      stStart;
        int             cDayState;

        LPMONTHDAYSTATE prgDayState; // points to cDayState MONTHDAYSTATEs
    } NMDAYSTATE, * LPNMDAYSTATE;

    #define MCN_GETDAYSTATE     (MCN_FIRST + 3)

    // MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard)
    //
    typedef NMSELCHANGE NMSELECT, * LPNMSELECT;


    #define MCN_SELECT          (MCN_FIRST + 4)


    #define MCS_DAYSTATE        0x0001
    #define MCS_MULTISELECT     0x0002
    #define MCS_WEEKNUMBERS     0x0004
    #define MCS_NOTODAY         0x0008


    #define GMR_VISIBLE     0       // visible portion of display
    #define GMR_DAYSTATE    1       // above plus the grayed out parts of
                                    // partially displayed months


    #endif // NOMONTHCAL


    //====== DATETIMEPICK CONTROL ==========

    #define NODATETIMEPICK
    #ifndef NODATETIMEPICK

    #define DTM_FIRST        0x1000

    // DWORD DateTimePick_GetSystemtime(HWND hdp, LPSYSTEMTIME pst)
    //   returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)
    //   returns GDT_VALID and modifies *pst to be the currently selected value
    #define DTM_GETSYSTEMTIME   (DTM_FIRST + 1)
    #define DateTime_GetSystemtime(hdp, pst)    (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))

    // BOOL DateTime_SetSystemtime(HWND hdp, DWORD gd, LPSYSTEMTIME pst)
    //   if gd==GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only)
    //   if gd==GDT_VALID, sets datetimepick to *pst
    //   returns TRUE on success, FALSE on error (such as bad params)
    #define DTM_SETSYSTEMTIME   (DTM_FIRST + 2)
    #define DateTime_SetSystemtime(hdp, gd, pst)    (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (LPARAM)(gd), (LPARAM)(pst))

    // DWORD DateTime_GetRange(HWND hdp, LPSYSTEMTIME rgst)
    //   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
    //   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
    //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
    #define DTM_GETRANGE (DTM_FIRST + 3)
    #define DateTime_GetRange(hdp, rgst)  (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))

    // BOOL DateTime_SetRange(HWND hdp, DWORD gdtr, LPSYSTEMTIME rgst)
    //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
    //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
    //   returns TRUE on success, FALSE on error (such as invalid parameters)
    #define DTM_SETRANGE (DTM_FIRST + 4)
    #define DateTime_SetRange(hdp, gd, rgst)  (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

    // BOOL DateTime_SetFormat(HWND hdp, LPCTSTR sz)
    //   sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars)
    //   NOTE: 'X' is a valid formatting character which indicates that the application
    //   will determine how to display information. Such apps must support DTN_WMKEYDOWN,
    //   DTN_FORMAT, and DTN_FORMATQUERY.
    #define DTM_SETFORMATA (DTM_FIRST + 5)
    #define DTM_SETFORMATW (DTM_FIRST + 50)

    #ifdef UNICODE
    #define DTM_SETFORMAT       DTM_SETFORMATW
    #else
    #define DTM_SETFORMAT       DTM_SETFORMATA
    #endif

    #define DateTime_SetFormat(hdp, sz)  (BOOL)SNDMSG(hdp, DTM_SETFORMAT, 0, (LPARAM)(sz))


    #define DTM_SETMCCOLOR    (DTM_FIRST + 6)
    #define DateTime_SetMonthCalColor(hdp, iColor, clr) SNDMSG(hdp, DTM_SETMCCOLOR, iColor, clr)

    #define DTM_GETMCCOLOR    (DTM_FIRST + 7)
    #define DateTime_GetMonthCalColor(hdp, iColor) SNDMSG(hdp, DTM_GETMCCOLOR, iColor, 0)

    // HWND DateTime_GetMonthCal(HWND hdp)
    //   returns the HWND of the MonthCal popup window. Only valid
    // between DTN_DROPDOWN and DTN_CLOSEUP notifications.
    #define DTM_GETMONTHCAL   (DTM_FIRST + 8)
    #define DateTime_GetMonthCal(hdp) (HWND)SNDMSG(hdp, DTM_GETMONTHCAL, 0, 0)

    #define DTM_SETMCFONT     (DTM_FIRST + 9)
    #define DateTime_SetMonthCalFont(hdp, hfont, fRedraw) SNDMSG(hdp, DTM_SETMCFONT, (WPARAM)hfont, (LPARAM)fRedraw)

    #define DTM_GETMCFONT     (DTM_FIRST + 10)
    #define DateTime_GetMonthCalFont(hdp) SNDMSG(hdp, DTM_GETMCFONT, 0, 0)

    #define DTS_UPDOWN          0x0001 // use UPDOWN instead of MONTHCAL
    #define DTS_SHOWNONE        0x0002 // allow a NONE selection
    #define DTS_SHORTDATEFORMAT 0x0000 // use the short date format (app must forward WM_WININICHANGE messages)
    #define DTS_LONGDATEFORMAT  0x0004 // use the long date format (app must forward WM_WININICHANGE messages)
    #define DTS_TIMEFORMAT      0x0009 // use the time format (app must forward WM_WININICHANGE messages)
    #define DTS_APPCANPARSE     0x0010 // allow user entered strings (app MUST respond to DTN_USERSTRING)
    #define DTS_RIGHTALIGN      0x0020 // right-align popup instead of left-align it

    #define DTN_DATETIMECHANGE  (DTN_FIRST + 1) // the systemtime has changed
    typedef struct NMDATETIMECHANGE
    {
        NMHDR       nmhdr;
        DWORD       dwFlags;    // GDT_VALID or GDT_NONE
        SYSTEMTIME  st;         // valid iff dwFlags==GDT_VALID
    } NMDATETIMECHANGE, * LPNMDATETIMECHANGE;

    #define DTN_USERSTRINGA  (DTN_FIRST + 2) // the user has entered a string
    #define DTN_USERSTRINGW  (DTN_FIRST + 15)
    typedef struct NMDATETIMESTRINGA
    {
        NMHDR      nmhdr;
        LPCSTR     pszUserString;  // string user entered
        SYSTEMTIME st;             // app fills this in
        DWORD      dwFlags;        // GDT_VALID or GDT_NONE
    } NMDATETIMESTRINGA, * LPNMDATETIMESTRINGA;

    typedef struct tagNMDATETIMESTRINGW
    {
        NMHDR      nmhdr;
        LPCWSTR    pszUserString;  // string user entered
        SYSTEMTIME st;             // app fills this in
        DWORD      dwFlags;        // GDT_VALID or GDT_NONE
    } NMDATETIMESTRINGW, * LPNMDATETIMESTRINGW;

    #ifdef UNICODE
    #define DTN_USERSTRING          DTN_USERSTRINGW
    #define NMDATETIMESTRING        NMDATETIMESTRINGW
    #define LPNMDATETIMESTRING      LPNMDATETIMESTRINGW
    #else
    #define DTN_USERSTRING          DTN_USERSTRINGA
    #define NMDATETIMESTRING        NMDATETIMESTRINGA
    #define LPNMDATETIMESTRING      LPNMDATETIMESTRINGA
    #endif


    #define DTN_WMKEYDOWNA  (DTN_FIRST + 3) // modify keydown on app format field (X)
    #define DTN_WMKEYDOWNW  (DTN_FIRST + 16)
    typedef struct tagNMDATETIMEWMKEYDOWNA
    {
        NMHDR      nmhdr;
        int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
        PTR /* LPCSTR */ pszFormat; // format substring
        SYSTEMTIME st;        // current systemtime, app should modify based on key
    } NMDATETIMEWMKEYDOWNA, * LPNMDATETIMEWMKEYDOWNA;

    typedef struct tagNMDATETIMEWMKEYDOWNW
    {
        NMHDR      nmhdr;
        int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
        PTR /* LPCWSTR */ pszFormat; // format substring
        SYSTEMTIME st;        // current systemtime, app should modify based on key
    } NMDATETIMEWMKEYDOWNW, * LPNMDATETIMEWMKEYDOWNW;

    #ifdef UNICODE
    #define DTN_WMKEYDOWN           DTN_WMKEYDOWNW
    #define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNW
    #define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNW
    #else
    #define DTN_WMKEYDOWN           DTN_WMKEYDOWNA
    #define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNA
    #define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNA
    #endif


    #define DTN_FORMATA  (DTN_FIRST + 4) // query display for app format field (X)
    #define DTN_FORMATW  (DTN_FIRST + 17)
    typedef struct tagNMDATETIMEFORMATA
    {
        NMHDR nmhdr;
        LPCSTR  pszFormat;   // format substring
        SYSTEMTIME st;       // current systemtime
        PTR /* LPCSTR */ pszDisplay;   // string to display
        CHAR szDisplay[64];  // buffer pszDisplay originally points at
    } NMDATETIMEFORMATA, * LPNMDATETIMEFORMATA;

    typedef struct tagNMDATETIMEFORMATW
    {
        NMHDR nmhdr;
        PTR /* LPCWSTR */ pszFormat;   // format substring
        SYSTEMTIME st;       // current systemtime
        LPCWSTR pszDisplay;  // string to display
        WCHAR szDisplay[64]; // buffer pszDisplay originally points at
    } NMDATETIMEFORMATW, * LPNMDATETIMEFORMATW;

    #ifdef UNICODE
    #define DTN_FORMAT             DTN_FORMATW
    #define NMDATETIMEFORMAT        NMDATETIMEFORMATW
    #define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATW
    #else
    #define DTN_FORMAT             DTN_FORMATA
    #define NMDATETIMEFORMAT        NMDATETIMEFORMATA
    #define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATA
    #endif


    #define DTN_FORMATQUERYA  (DTN_FIRST + 5) // query formatting info for app format field (X)
    #define DTN_FORMATQUERYW (DTN_FIRST + 18)
    typedef struct tagNMDATETIMEFORMATQUERYA
    {
        NMHDR nmhdr;
        PTR /* LPCSTR */ pszFormat;  // format substring
        SIZE szMax;        // max bounding rectangle app will use for this format string
    } NMDATETIMEFORMATQUERYA, * LPNMDATETIMEFORMATQUERYA;

    typedef struct tagNMDATETIMEFORMATQUERYW
    {
        NMHDR nmhdr;
        PTR /* LPCWSTR */ pszFormat; // format substring
        SIZE szMax;        // max bounding rectangle app will use for this format string
    } NMDATETIMEFORMATQUERYW, * LPNMDATETIMEFORMATQUERYW;

    #ifdef UNICODE
    #define DTN_FORMATQUERY         DTN_FORMATQUERYW
    #define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYW
    #define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYW
    #else
    #define DTN_FORMATQUERY         DTN_FORMATQUERYA
    #define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYA
    #define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYA
    #endif


    #define DTN_DROPDOWN    (DTN_FIRST + 6) // MonthCal has dropped down
    #define DTN_CLOSEUP     (DTN_FIRST + 7) // MonthCal is popping up


    #define GDTR_MIN     0x0001
    #define GDTR_MAX     0x0002

    #define GDT_ERROR    -1
    #define GDT_VALID    0
    #define GDT_NONE     1

    #endif // NODATETIMEPICK




    //====== TrackMouseEvent  ======

    #define NOTRACKMOUSEEVENT
    #ifndef NOTRACKMOUSEEVENT

    //
    // If the messages for TrackMouseEvent have not been defined then define them
    // now.
    //
    #ifndef WM_MOUSEHOVER
    #define WM_MOUSEHOVER                   0x02A1
    #define WM_MOUSELEAVE                   0x02A3
    #endif

    //
    // If the TRACKMOUSEEVENT structure and associated flags havent been declared
    // then declare them now.
    //
    #ifndef TME_HOVER

    #define TME_HOVER       0x00000001
    #define TME_LEAVE       0x00000002
    #define TME_QUERY       0x40000000
    #define TME_CANCEL      0x80000000


    #define HOVER_DEFAULT   0xFFFFFFFF

    typedef struct tagTRACKMOUSEEVENT {
        DWORD cbSize;
        DWORD dwFlags;
        HWND  hwndTrack;
        DWORD dwHoverTime;
    } TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

    #endif // !TME_HOVER

    //
    // Declare _TrackMouseEvent.  This API tries to use the window manager's
    // implementation of TrackMouseEvent if it is present, otherwise it emulates.
    //
    WINCOMMCTRLAPI
    BOOL
    WINAPI
    _TrackMouseEvent(
        LPTRACKMOUSEEVENT lpEventTrack);

    #endif // !NOTRACKMOUSEEVENT

}
