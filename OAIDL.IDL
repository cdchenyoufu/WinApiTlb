//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File: oaidl.idl
//
//----------------------------------------------------------------------------

#ifndef DO_NO_IMPORTS
import "objidl.idl";
#endif

interface IVBTypeInfo;
interface IVBTypeLib;
interface IVBErrorInfo;
interface IVBCreateErrorInfo;
interface IVBSupportErrorInfo;
interface IVBDispatch;
interface IVBStream;
interface IVBStorage;
interface IUnknown;

[
  version(0.1), odl,
  local  /* marshalling supplied by oleaut32.dll */
]
interface RemVariant
{

cpp_quote("//+-------------------------------------------------------------------------")
cpp_quote("//")
cpp_quote("//  Microsoft Windows")
cpp_quote("//  Copyright (C) Microsoft Corporation, 1992 - 1996.")
cpp_quote("//")
cpp_quote("//--------------------------------------------------------------------------")

#define FAR

// #########################################################################
//
//  SAFEARRAY
//
// #########################################################################

cpp_quote("#ifndef _tagSAFEARRAYBOUND_DEFINED")
cpp_quote("#define _tagSAFEARRAYBOUND_DEFINED")
cpp_quote("#define _SAFEARRAYBOUND_DEFINED")
cpp_quote("#define _LPSAFEARRAYBOUND_DEFINED")
typedef struct  SAFEARRAYBOUND {
    ULONG cElements;
    LONG lLbound;
} SAFEARRAYBOUND, * LPSAFEARRAYBOUND;
cpp_quote("#endif")


cpp_quote("#ifndef _tagSAFEARRAY_DEFINED")
cpp_quote("#define _tagSAFEARRAY_DEFINED")
cpp_quote("#define _SAFEARRAY_DEFINED")
cpp_quote("#define _LPSAFEARRAY_DEFINED")
cpp_quote("#if 0")
cpp_quote("/* the following is what RPC knows how to remote */")
typedef struct SAFEARRAY {
    USHORT cDims;
    USHORT fFeatures;
#if defined(_WIN32)
    ULONG cbElements;
    ULONG cLocks;
#else
    USHORT cbElements;
    USHORT cLocks;
#ifdef _MAC
    Handle handle;
#else
    ULONG handle;               // unused but kept for compatiblity
#endif
#endif
#ifdef LATER
    void HUGEP* pvData;
#else
    BYTE *pvData;
#endif
    /* [size_is(cDims)] */ SAFEARRAYBOUND rgsabound[];
} SAFEARRAY;
cpp_quote("#else /* 0 */")
cpp_quote("typedef struct SAFEARRAY {")
cpp_quote("    USHORT cDims;")
cpp_quote("    USHORT fFeatures;")
cpp_quote("#if defined(_WIN32)")
cpp_quote("    ULONG cbElements;")
cpp_quote("    ULONG cLocks;")
cpp_quote("#else")
cpp_quote("    USHORT cbElements;")
cpp_quote("    USHORT cLocks;")
cpp_quote("    ULONG handle;               // unused but kept for compatiblity")
cpp_quote("#endif")
cpp_quote("    void HUGEP* pvData;")
cpp_quote("    SAFEARRAYBOUND rgsabound[1];")
cpp_quote("} SAFEARRAY;")
cpp_quote("#endif /* 0 */")

cpp_quote("#endif /* _tagSAFEARRAY_DEFINED */")

const USHORT FADF_AUTO       = 0x0001;  /* the array is allocated on the stack */
const USHORT FADF_STATIC     = 0x0002;  /* the array is staticly allocated */
const USHORT FADF_EMBEDDED   = 0x0004;  /* array is embedded in a structure        */
const USHORT FADF_FIXEDSIZE  = 0x0010;  /* array may not be resized or reallocated */
const USHORT FADF_BSTR       = 0x0100;  /* an array of BSTRs */
const USHORT FADF_UNKNOWN    = 0x0200;  /* an array of IUnknown* */
const USHORT FADF_DISPATCH   = 0x0400;  /* and array of IVBDispatch* */
const USHORT FADF_VARIANT    = 0x0800;  /* an array of VARIANTs */
const USHORT FADF_RESERVED   = 0xF0E8;  /* reserved bits */

// Forward references.
typedef [unique] struct userVARIANT   * wireVARIANT;
typedef [wire_marshal( wireVARIANT )]  struct  VARIANT  VARIANT;


typedef struct SAFEARR_BSTR
{
                            ULONG   Size;
    [size_is(Size), ref]    wireBSTR *      aBstr;
} SAFEARR_BSTR;

typedef struct SAFEARR_UNKNOWN
{
                            ULONG   Size;
    [size_is(Size), ref]    IUnknown **      apUnknown;
} SAFEARR_UNKNOWN;

typedef struct SAFEARR_DISPATCH
{
                            ULONG   Size;
    [size_is(Size), ref]    IVBDispatch **     apDispatch;
} SAFEARR_DISPATCH;


typedef struct SAFEARR_VARIANT
{
                            ULONG   Size;
    [size_is(Size), ref]    wireVARIANT *   aVariant;  
} SAFEARR_VARIANT;

typedef [v1_enum] enum SF_TYPE {
    SF_ERROR    = VT_ERROR,
    SF_I1       = VT_I1,
    SF_I2       = VT_I2,
    SF_I4       = VT_I4,
    SF_I8       = VT_I8,
    SF_BSTR     = VT_BSTR,
    SF_UNKNOWN  = VT_UNKNOWN,
    SF_DISPATCH = VT_DISPATCH,
    SF_VARIANT  = VT_VARIANT
} SF_TYPE;

#if 0
typedef union SAFEARRAYUNION switch(ULONG vtDisc) u
{
    case SF_BSTR:      SAFEARR_BSTR     BstrStr;
    case SF_UNKNOWN:   SAFEARR_UNKNOWN  UnknownStr;
    case SF_DISPATCH:  SAFEARR_DISPATCH DispatchStr;
    case SF_VARIANT:   SAFEARR_VARIANT  VariantStr;
    case SF_I1:        BYTE_SIZEDARR    ByteStr;
    case SF_I2:        WORD_SIZEDARR    WordStr;
    case SF_I4:        DWORD_SIZEDARR   LongStr;
    case SF_I8:        HYPER_SIZEDARR   HyperStr;
    default:           ;                // error
} SAFEARRAYUNION;
#else
typedef struct /* union */ SAFEARRAYUNION // switch(ULONG vtDisc) u
{
    // case SF_BSTR:      SAFEARR_BSTR     BstrStr;
    // case SF_UNKNOWN:   SAFEARR_UNKNOWN  UnknownStr;
    // case SF_DISPATCH:  SAFEARR_DISPATCH DispatchStr;
    // case SF_VARIANT:   
	SAFEARR_VARIANT  VariantStr;
    // case SF_I1:        BYTE_SIZEDARR    ByteStr;
    // case SF_I2:        WORD_SIZEDARR    WordStr;
    // case SF_I4:        DWORD_SIZEDARR   LongStr;
    // case SF_I8:        HYPER_SIZEDARR   HyperStr;
    // default:           ;                // error
} SAFEARRAYUNION;
#endif

typedef struct userSAFEARRAY {
    short  cDims;		// unsigned
    short  fFeatures;	// unsigned
    long   cbElements;	// unsigned
    long   cLocks;		// unsigned
    SAFEARRAYUNION  uArrayStructs;
    [size_is(cDims)]                    SAFEARRAYBOUND rgsabound[];
} userSAFEARRAY;

typedef [unique]  userSAFEARRAY *  userPSAFEARRAY;
typedef [unique]  userPSAFEARRAY * wirePSAFEARRAY;

typedef [wire_marshal( wirePSAFEARRAY )] SAFEARRAY * LPSAFEARRAY;

// typedef CY CURRENCY;



// #########################################################################
// 		VARIANT
// #########################################################################

cpp_quote("/* VARIANT STRUCTURE")
cpp_quote(" *")
cpp_quote(" *  VARTYPE vt;")
cpp_quote(" *  USHORT wReserved1;")
cpp_quote(" *  USHORT wReserved2;")
cpp_quote(" *  USHORT wReserved3;")
#if 1	// VB compatible
cpp_quote(" *  ULONG dwReserved1;")
cpp_quote(" *  ULONG dwReserved2;")
#else
cpp_quote(" *  union {")
cpp_quote(" *    unsigned char        VT_UI1               ")
cpp_quote(" *    short                VT_I2                ")
cpp_quote(" *    long                 VT_I4                ")
cpp_quote(" *    float                VT_R4                ")
cpp_quote(" *    double               VT_R8                ")
cpp_quote(" *    VARIANT_BOOL         VT_BOOL              ")
cpp_quote(" *    SCODE                VT_ERROR             ")
cpp_quote(" *    CY                   VT_CY                ")
cpp_quote(" *    DATE                 VT_DATE              ")
cpp_quote(" *    BSTR                 VT_BSTR              ")
cpp_quote(" *    IUnknown *        VT_UNKNOWN           ")
cpp_quote(" *    IVBDispatch *       VT_DISPATCH          ")
cpp_quote(" *    SAFEARRAY *       VT_ARRAY|*           ")

cpp_quote(" *    short *           VT_BYREF|VT_I2       ")
cpp_quote(" *    long *            VT_BYREF|VT_I4       ")
cpp_quote(" *    float *           VT_BYREF|VT_R4       ")
cpp_quote(" *    double *          VT_BYREF|VT_R8       ")
cpp_quote(" *    VARIANT_BOOL *    VT_BYREF|VT_BOOL     ")
cpp_quote(" *    SCODE *           VT_BYREF|VT_ERROR    ")
cpp_quote(" *    CY *              VT_BYREF|VT_CY       ")
cpp_quote(" *    DATE *            VT_BYREF|VT_DATE     ")
cpp_quote(" *    BSTR *            VT_BYREF|VT_BSTR     ")
cpp_quote(" *    IUnknown * *   VT_BYREF|VT_UNKNOWN  ")
cpp_quote(" *    IVBDispatch * *  VT_BYREF|VT_DISPATCH ")
cpp_quote(" *    SAFEARRAY * *  VT_BYREF|VT_ARRAY|*  ")
cpp_quote(" *    VARIANT *         VT_BYREF|VT_VARIANT  ")

cpp_quote(" *    void *            Generic ByRef        ")
cpp_quote(" */")
#endif

cpp_quote("#ifndef _tagVARIANT_DEFINED")
cpp_quote("#define _tagVARIANT_DEFINED")
cpp_quote("#if 0")
cpp_quote("/* the following is what RPC knows how to remote */")

struct VARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
#if 1	// VB compatible
    DWORD dwReserved1;
    DWORD dwReserved2;
#else
    [switch_type(USHORT), switch_is((USHORT) (vt & 0x1fff))] union
    {
[case(VT_I4)]   // moved first so you can statically init most of the structure
      long          lVal;           /* VT_I4                */
[case(VT_UI1)]
      unsigned char bVal;           /* VT_UI1               */
[case(VT_I2)]
      short         iVal;           /* VT_I2                */
[case(VT_R4)]
      float         fltVal;         /* VT_R4                */
[case(VT_R8)]
      double        dblVal;         /* VT_R8                */
[case(VT_BOOL)]
      VARIANT_BOOL  bool;           /* VT_BOOL              */
[case(VT_ERROR)]
      SCODE         scode;          /* VT_ERROR             */
[case(VT_CY)]
      CY            cyVal;          /* VT_CY                */
[case(VT_DATE)]
      DATE          date;           /* VT_DATE              */
[case(VT_BSTR)]
      BSTR          bstrVal;        /* VT_BSTR              */

#if !defined(NO_MARSHAL_INTERFACE)
[case(VT_UNKNOWN)]
      IUnknown      *punkVal;       /* VT_UNKNOWN           */
#endif //!defined(NO_MARSHAL_INTERFACE)

#ifdef HPP
[case(VT_DISPATCH)]
      IVBDispatch     *pdispVal;      /* VT_DISPATCH          */
#endif

[case(VT_ARRAY)]
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */

[case(VT_UI1|VT_BYREF)]
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
[case(VT_I2|VT_BYREF)]
      short         *piVal;         /* VT_BYREF|VT_I2       */
[case(VT_I4|VT_BYREF)]
      long          *plVal;         /* VT_BYREF|VT_I4       */
[case(VT_R4|VT_BYREF)]
      float         *pfltVal;       /* VT_BYREF|VT_R4       */
[case(VT_R8|VT_BYREF)]
      double        *pdblVal;       /* VT_BYREF|VT_R8       */
[case(VT_BOOL|VT_BYREF)]
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
[case(VT_ERROR|VT_BYREF)]
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
[case(VT_CY|VT_BYREF)]
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */
[case(VT_DATE|VT_BYREF)]
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */
[case(VT_BSTR|VT_BYREF)]
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */

#if !defined(NO_MARSHAL_INTERFACE)
[case(VT_UNKNOWN|VT_BYREF)]
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
#endif //!defined(NO_MARSHAL_INTERFACE)

#ifdef HPP
[case(VT_DISPATCH|VT_BYREF)]
      IVBDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
#endif

[case(VT_ARRAY|VT_BYREF)]
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */
[case(VT_VARIANT, VT_VARIANT|VT_BYREF)]
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */
[case(VT_BYREF)]
#ifdef LATER
      void     * byref;             /* Generic ByRef        */
#else
      long     * byref;             /* form midl likes */
#endif
    }
#if(defined(NONAMELESSUNION))
    u
#endif
     ;
#endif
};

// End of variant definition

cpp_quote("#endif /* 0 */")

// #########################################################################
// 		wireVARIANT
// #########################################################################


typedef struct userVARIANT{
    VARTYPE     vt;
    WORD        wReserved1;
    WORD        wReserved2;
    WORD        wReserved3;
#if 1	// VB compatible
    DWORD dwReserved1;
    DWORD dwReserved2;
#else
    [switch_type(ULONG), switch_is((ULONG) (vt & 0x1fff))]
    union
    {
    [case(VT_I4)]   // moved first so you can statically init most of the structure
                        long          lVal;           /* VT_I4                */
    [case(VT_UI1)]      unsigned char bVal;           /* VT_UI1               */
    [case(VT_I2)]       short         iVal;           /* VT_I2                */
    [case(VT_R4)]       float         fltVal;         /* VT_R4                */
    [case(VT_R8)]       double        dblVal;         /* VT_R8                */
    [case(VT_BOOL)]     VARIANT_BOOL  bool;           /* VT_BOOL              */
    [case(VT_ERROR)]    SCODE         scode;          /* VT_ERROR             */
    [case(VT_CY)]       CY            cyVal;          /* VT_CY                */
    [case(VT_DATE)]     DATE          date;           /* VT_DATE              */
    [case(VT_BSTR)]     wireBSTR      bstrVal;        /* VT_BSTR              */
    [case(VT_UNKNOWN)]  IUnknown      *punkVal;       /* VT_UNKNOWN           */
    [case(VT_DISPATCH)] IVBDispatch     *pdispVal;      /* VT_DISPATCH          */
    [case(VT_ARRAY)]    wirePSAFEARRAY parray;        /* VT_ARRAY|*           */

    [case(VT_UI1|VT_BYREF)]
                        unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
    [case(VT_I2|VT_BYREF)]
                        short         *piVal;         /* VT_BYREF|VT_I2       */
    [case(VT_I4|VT_BYREF)]
                        long          *plVal;         /* VT_BYREF|VT_I4       */
    [case(VT_R4|VT_BYREF)]
                        float         *pfltVal;       /* VT_BYREF|VT_R4       */
    [case(VT_R8|VT_BYREF)]
                        double        *pdblVal;       /* VT_BYREF|VT_R8       */
    [case(VT_BOOL|VT_BYREF)]
                        VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
    [case(VT_ERROR|VT_BYREF)]
                        SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
    [case(VT_CY|VT_BYREF)]
                        CY            *pcyVal;        /* VT_BYREF|VT_CY       */
    [case(VT_DATE|VT_BYREF)]
                        DATE          *pdate;         /* VT_BYREF|VT_DATE     */
    [case(VT_BSTR|VT_BYREF)]
                        wireBSTR      *pbstrVal;      /* VT_BYREF|VT_BSTR     */
    [case(VT_UNKNOWN|VT_BYREF)]
                        IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
    [case(VT_DISPATCH|VT_BYREF)]
                        IVBDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
    [case(VT_ARRAY|VT_BYREF)]
                        wirePSAFEARRAY *pparray;      /* VT_BYREF|VT_ARRAY|*  */
    [case(VT_VARIANT|VT_BYREF)]
                        wireVARIANT   *pvarVal;       /* VT_BYREF|VT_VARIANT  */
    [case(VT_VARIANT)]
                        wireVARIANT   varVal;         /* this is illegal  */
    [case(VT_BYREF)]
                        long     * byref;             /* form midl likes */
    [case(VT_EMPTY)]    ;                             /* nothing         */       
    [case(VT_NULL)]     ;                             /* nothing         */       
    }
#if(defined(NONAMELESSUNION))
    u
#endif
     ;
#endif
} userVARIANT;

cpp_quote("struct VARIANT{")
cpp_quote("    VARTYPE vt;")
cpp_quote("    WORD wReserved1;")
cpp_quote("    WORD wReserved2;")
cpp_quote("    WORD wReserved3;")
#if 1	// VB compatible
cpp_quote("    ULONG dwReserved1;")
cpp_quote("    ULONG dwReserved2;")
#else
cpp_quote("    union")
cpp_quote("    {")
cpp_quote("      long          lVal;           /* VT_I4                */")
cpp_quote("      unsigned char bVal;           /* VT_UI1               */")
cpp_quote("      short         iVal;           /* VT_I2                */")
cpp_quote("      float         fltVal;         /* VT_R4                */")
cpp_quote("      double        dblVal;         /* VT_R8                */")
cpp_quote("      VARIANT_BOOL  bool;           /* VT_BOOL              */")
cpp_quote("      SCODE         scode;          /* VT_ERROR             */")
cpp_quote("      CY            cyVal;          /* VT_CY                */")
cpp_quote("      DATE          date;           /* VT_DATE              */")
cpp_quote("      BSTR          bstrVal;        /* VT_BSTR              */")
cpp_quote("      IUnknown      *punkVal;       /* VT_UNKNOWN           */")
cpp_quote("      IVBDispatch     *pdispVal;      /* VT_DISPATCH          */")
cpp_quote("      SAFEARRAY     *parray;        /* VT_ARRAY|*           */")
cpp_quote("      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */")
cpp_quote("      short         *piVal;         /* VT_BYREF|VT_I2       */")
cpp_quote("      long          *plVal;         /* VT_BYREF|VT_I4       */")
cpp_quote("      float         *pfltVal;       /* VT_BYREF|VT_R4       */")
cpp_quote("      double        *pdblVal;       /* VT_BYREF|VT_R8       */")
cpp_quote("      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */")
cpp_quote("      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */")
cpp_quote("      CY            *pcyVal;        /* VT_BYREF|VT_CY       */")
cpp_quote("      DATE          *pdate;         /* VT_BYREF|VT_DATE     */")
cpp_quote("      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */")
cpp_quote("      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */")
cpp_quote("      IVBDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */")
cpp_quote("      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */")
cpp_quote("      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */")
cpp_quote("      void     * byref;             /* Generic ByRef        */")
cpp_quote("    }")
cpp_quote("#if(defined(NONAMELESSUNION))")
cpp_quote("    u")
cpp_quote("#endif")
cpp_quote("     ;")
cpp_quote("};")
#endif
cpp_quote("#endif")



    cpp_quote("#ifndef _LPVARIANT_DEFINED")
    cpp_quote("#define _LPVARIANT_DEFINED")
    typedef struct VARIANT * LPVARIANT;
    cpp_quote("#endif")

    cpp_quote("#ifndef _VARIANTARG_DEFINED")
    cpp_quote("#define _VARIANTARG_DEFINED")
    typedef struct VARIANT VARIANTARG;
    cpp_quote("#endif")

    cpp_quote("#ifndef _LPVARIANTARG_DEFINED")
    cpp_quote("#define _LPVARIANTARG_DEFINED")
    typedef struct VARIANT * LPVARIANTARG;
    cpp_quote("#endif")



//########################################################################
//     End of VARIANT & SAFEARRAY
//########################################################################


//TypeInfo stuff.

    cpp_quote("#ifndef _DISPID_DEFINED")
    cpp_quote("#define _DISPID_DEFINED")
    typedef LONG DISPID;
    cpp_quote("#endif")


    cpp_quote("#ifndef _MEMBERID_DEFINED")
    cpp_quote("#define _MEMBERID_DEFINED")
    typedef DISPID MEMBERID;
    cpp_quote("#endif")

    cpp_quote("#ifndef _HREFTYPE_DEFINED")
    cpp_quote("#define _HREFTYPE_DEFINED")
    typedef DWORD HREFTYPE;
    cpp_quote("#endif")



typedef [v1_enum] enum  TYPEKIND
{
    TKIND_ENUM = 0,
    TKIND_RECORD,
    TKIND_MODULE,
    TKIND_INTERFACE,
    TKIND_DISPATCH,
    TKIND_COCLASS,
    TKIND_ALIAS,
    TKIND_UNION,
    TKIND_MAX                   /* end of enum marker */
} TYPEKIND;


cpp_quote("#ifndef _tagTYPEDESC_DEFINED")
cpp_quote("#define _tagTYPEDESC_DEFINED")
cpp_quote("#define _TYPEDESC_DEFINED")

cpp_quote("/* VT_PTR - lptdesc, the pointed at type */")
cpp_quote("/* VT_CARRAY - lpadesc */")
cpp_quote("/* VT_USERDEFINED - hreftype, used to get the UDT typeinfo */")

typedef struct  TYPEDESC {
#if 0 
    [switch_type(short), switch_is((short)vt)] union
    {
      [case(VT_PTR)] struct  TYPEDESC * lptdesc;
      [case(VT_CARRAY)] struct  ARRAYDESC * lpadesc;
      [case(VT_USERDEFINED)] HREFTYPE hreftype;
    }
#if(defined(NONAMELESSUNION))
    u
#endif
    ;
#else
	PTR /* HREFTYPE, TYPEDESC, or ARRAYDESC */ p;
#endif
    VARTYPE vt;
} TYPEDESC;
cpp_quote("#endif")


cpp_quote("#ifndef _tagARRAYDESC_DEFINED")
cpp_quote("#define _tagARRAYDESC_DEFINED")
cpp_quote("#define _ARRAYDESC_DEFINED")
cpp_quote("#if 0")
    typedef struct ARRAYDESC {
        TYPEDESC tdescElem;     /* element type */
        USHORT cDims;       /* dimension count */
        [size_is(cDims)] SAFEARRAYBOUND rgbounds[]; /* variable length array of bounds */
    } ARRAYDESC;
cpp_quote("#else")
cpp_quote("typedef struct  ARRAYDESC {")
cpp_quote("    TYPEDESC tdescElem;     /* element type */")
cpp_quote("    USHORT cDims;       /* dimension count */")
cpp_quote("    SAFEARRAYBOUND rgbounds[1]; /* variable length array of bounds */")
cpp_quote("} ARRAYDESC;")
cpp_quote("#endif")
cpp_quote("#endif")


cpp_quote("#ifndef _tagIDLDESC_DEFINED")
cpp_quote("#define _tagIDLDESC_DEFINED")
cpp_quote("#define _IDLDESC_DEFINED")
cpp_quote("#define _LPIDLDESC_DEFINED")
cpp_quote("#ifdef _WIN32")
typedef struct IDLDESC {
#if defined(_WIN32) || defined(_MAC)
    ULONG dwReserved;
#else
    PTR /* BSTR */ bstrIDLInfo; /* reserved, but original name retained for
                                   compatibilty */
#endif
    USHORT wIDLFlags;   /* IN, OUT, etc */
} IDLDESC, * LPIDLDESC;

cpp_quote("#else")
cpp_quote("typedef struct IDLDESC {")
cpp_quote("#if defined(_WIN32)")
cpp_quote("    ULONG dwReserved;")
cpp_quote("#else")
cpp_quote("    PTR /* BSTR */ bstrIDLInfo; /* reserved, but original name retained for")
cpp_quote("                                   compatibilty */")
cpp_quote("#endif")
cpp_quote("    USHORT wIDLFlags;   /* IN, OUT, etc */")
cpp_quote("} IDLDESC, * LPIDLDESC;")
cpp_quote("#endif")
cpp_quote("#endif")


cpp_quote("#ifndef _tagELEMDESC_DEFINED")
cpp_quote("#define _tagELEMDESC_DEFINED")
cpp_quote("#define _ELEMDESC_DEFINED")
cpp_quote("#define _LPELEMDESC_DEFINED")
typedef struct  ELEMDESC {
    TYPEDESC tdesc;     /* the type of the element */
    IDLDESC idldesc;        /* info for remoting the element */
} ELEMDESC, * LPELEMDESC;
cpp_quote("#endif")


cpp_quote("#ifndef _tagTYPEATTR_DEFINED")
cpp_quote("#define _tagTYPEATTR_DEFINED")
cpp_quote("#define _TYPEATTR_DEFINED")
cpp_quote("#define _LPTYPEATTR_DEFINED")
typedef struct  TYPEATTR {
    UUID typeguid;          /* the GUID of the TypeInfo */
    LCID typelcid;          /* locale of member names and doc strings */
    long  dwReserved;
    MEMBERID memidConstructor;  /* ID of constructor, MEMBERID_NIL if none */
    MEMBERID memidDestructor;   /* ID of destructor, MEMBERID_NIL if none */
    PTR /* LPOLESTR */ lpstrSchema;
    DWORD cbSizeInstance;    /* the size of an instance of this type */
    TYPEKIND typekind;      /* the kind of type this typeinfo describes */
    WORD cFuncs;        /* number of functions */
    WORD cVars;         /* number of variables / data members */
    WORD cImplTypes;        /* number of implemented interfaces */
    WORD cbSizeVft;     /* the size of this types virtual func table */
    WORD cbAlignment;       /* specifies the alignment requirements for
                   an instance of this type,
                     0 = align on 64k boundary
                     1 = byte align
                     2 = word align
                     4 = dword align... */
    WORD wTypeFlags;
    WORD wMajorVerNum;      /* major version number */
    WORD wMinorVerNum;      /* minor version number */
    TYPEDESC tdescAlias;    /* if typekind == TKIND_ALIAS this field
                   specifies the type for which this type
                   is an alias */
    IDLDESC idldescType;        /* IDL attributes of the described type */
} TYPEATTR, * LPTYPEATTR;
cpp_quote("#endif")


typedef struct _userDISPPARAMS{
    [size_is(cArgs)]      wireVARIANT * rgvarg;
    [size_is(cNamedArgs)] DISPID      * rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
} userDISPPARAMS;

typedef [unique]   userDISPPARAMS * wireDISPPARAMS;

typedef [wire_marshal( wireDISPPARAMS )] 
struct  DISPPARAMS{
    [size_is(cArgs)] VARIANTARG * rgvarg;
    [size_is(cNamedArgs)] DISPID * rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
} DISPPARAMS;


typedef struct  RemEXCEPINFO {
    WORD wCode;             /* An error code describing the error. */
    WORD wReserved;
    DWORD dwHelpContext;    /* help context of topic within the help file. */
    DWORD scode;
    DWORD cSource;
    DWORD cDescription;
    DWORD cHelpFile;
    [size_is(cSource + cDescription + cHelpFile)] OLECHAR strings[]; //Contains bstrSource, bstrDescription, bstrHelpFile.
}  RemEXCEPINFO;


typedef struct userEXCEPINFO {
    WORD wCode;             /* An error code describing the error. */
    WORD       wReserved;
    BSTR       bstrSource;        /* A source of the exception */
    BSTR       bstrDescription;   /* A description of the error */
    BSTR       bstrHelpFile;   /* Fully qualified drive, path, and file name */
    DWORD      dwHelpContext;  /* help context of topic within the help file */
    ULONG *  pvReserved;
    ULONG *  pfnDeferredFillIn;
    SCODE      scode;
}  userEXCEPINFO;

typedef [unique] userEXCEPINFO * wireEXCEPINFO;

typedef [wire_marshal( wireEXCEPINFO )]
struct  EXCEPINFO {
    short /* WORD */ wCode;
    short /* WORD */ wReserved;
    BSTR        bstrSource;
    BSTR        bstrDescription;
    BSTR        bstrHelpFile;
    long /* DWORD */ dwHelpContext;
    PTR /* void * */  pvReserved;
    /* HRESULT (__stdcall * pfnDeferredFillIn)(struct  EXCEPINFO *); */ 
    PTR pfnDeferredFillIn;
    SCODE       scode;
}  EXCEPINFO;
typedef EXCEPINFO * LPEXCEPINFO;


typedef [v1_enum] enum  CALLCONV {
      CC_CDECL = 1
    , CC_MSCPASCAL
    , CC_PASCAL = CC_MSCPASCAL
    , CC_MACPASCAL
    , CC_STDCALL
    , CC_RESERVED
    , CC_SYSCALL
    , CC_MPWCDECL
    , CC_MPWPASCAL
    , CC_MAX                    /* end of enum marker */
#ifdef _MAC
    , CC_FORCELONG = 2147483647
#endif
} CALLCONV;


typedef [v1_enum] enum  FUNCKIND {
    FUNC_VIRTUAL,
    FUNC_PUREVIRTUAL,
    FUNC_NONVIRTUAL,
    FUNC_STATIC,
    FUNC_DISPATCH
} FUNCKIND;


typedef [v1_enum] enum  INVOKEKIND {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8
} INVOKEKIND;

typedef struct  FUNCDESC {
    MEMBERID memid;
    [size_is(cScodes)] SCODE * lprgscode;
    [size_is(cParams)] ELEMDESC * lprgelemdescParam;  /* array of parameter types */
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
} FUNCDESC, * LPFUNCDESC;

typedef [v1_enum] enum  VARKIND {
    VAR_PERINSTANCE,
    VAR_STATIC,
    VAR_CONST,
    VAR_DISPATCH
} VARKIND;


/* IMPLTYPE Flags */
const USHORT IMPLTYPEFLAG_FDEFAULT = 0x1;
const USHORT IMPLTYPEFLAG_FSOURCE  = 0x2;
const USHORT IMPLTYPEFLAG_FRESTRICTED  = 0x4;






typedef struct  VARDESC {
    MEMBERID memid;
    PTR /* LPOLESTR */ lpstrSchema;
#if 0 
    [switch_type(USHORT), switch_is((USHORT)varkind)]
    union
    {
      [case(VAR_PERINSTANCE)] ULONG oInst;      /* VAR_PERINSTANCE - the offset of this
                   variable within the instance */
      [case(VAR_CONST)] VARIANT * lpvarValue;  /* VAR_CONST - the value of the constant */
    };
#else
	PTR p; // oInst of lpvarValue
#endif
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
} VARDESC, * LPVARDESC;


cpp_quote("#ifndef _tagTYPEFLAGS_DEFINED")
cpp_quote("#define _tagTYPEFLAGS_DEFINED")
cpp_quote("#define _TYPEFLAGS_DEFINED")
typedef enum  TYPEFLAGS {
      TYPEFLAG_FAPPOBJECT = 0x01
    , TYPEFLAG_FCANCREATE = 0x02
    , TYPEFLAG_FLICENSED = 0x04
    , TYPEFLAG_FPREDECLID = 0x08
    , TYPEFLAG_FHIDDEN = 0x10
    , TYPEFLAG_FCONTROL = 0x20
    , TYPEFLAG_FDUAL = 0x40
    , TYPEFLAG_FNONEXTENSIBLE = 0x80
    , TYPEFLAG_FOLEAUTOMATION = 0x100
    , TYPEFLAG_FRESTRICTED = 0x200
#ifdef _MAC
    , TYPEFLAG_FORCELONG  = 2147483647
#endif
} TYPEFLAGS;
cpp_quote("#endif")



cpp_quote("#ifndef _tagFUNCFLAGS_DEFINED")
cpp_quote("#define _tagFUNCFLAGS_DEFINED")
cpp_quote("#define _FUNCFLAGS_DEFINED")
typedef enum  FUNCFLAGS {
      FUNCFLAG_FRESTRICTED= 1
      , FUNCFLAG_FSOURCE= 0x2
      , FUNCFLAG_FBINDABLE= 0x4
      , FUNCFLAG_FREQUESTEDIT= 0x8
      , FUNCFLAG_FDISPLAYBIND= 0x10
      , FUNCFLAG_FDEFAULTBIND= 0x20
      , FUNCFLAG_FHIDDEN= 0x40
      , FUNCFLAG_FUSESGETLASTERROR= 0x80
#ifdef _MAC
    , FUNCFLAG_FORCELONG  = 2147483647
#endif
} FUNCFLAGS;
cpp_quote("#endif")


cpp_quote("#ifndef _tagVARFLAGS_DEFINED")
cpp_quote("#define _tagVARFLAGS_DEFINED")
cpp_quote("#define _VARFLAGS_DEFINED")
typedef enum  VARFLAGS {
      VARFLAG_FREADONLY = 1
      , VARFLAG_FSOURCE= 0x2
      , VARFLAG_FBINDABLE= 0x4
      , VARFLAG_FREQUESTEDIT= 0x8
      , VARFLAG_FDISPLAYBIND= 0x10
      , VARFLAG_FDEFAULTBIND= 0x20
      , VARFLAG_FHIDDEN = 0x40
#ifdef _MAC
    , VARFLAG_FORCELONG   = 2147483647
#endif
} VARFLAGS;
cpp_quote("#endif")
}

[
    uuid(00020405-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of ICreateTypeInfo interface")

]
interface IVBCreateTypeInfo: IUnknown
{

    typedef [unique] IVBCreateTypeInfo *LPCREATETYPEINFO;



    HRESULT SetGuid(
                     [in] REFGUID guid
                   );

    HRESULT SetTypeFlags(
                        [in]   UINT uTypeFlags
                        );

    HRESULT SetDocString(
                        [in] LPOLESTR lpstrDoc
                        );

    HRESULT SetHelpContext(
                        [in] DWORD dwHelpContext
                          );

    HRESULT SetVersion(
                        [in] WORD wMajorVerNum,
                        [in] WORD wMinorVerNum
                      );

    HRESULT AddRefTypeInfo(

                        [in] IVBTypeInfo * ptinfo,
                        [in] HREFTYPE * phreftype
                          );

    HRESULT AddFuncDesc(
                        [in] UINT index,
                        [in] FUNCDESC * pfuncdesc
                       );

    HRESULT AddImplType(
                        [in] UINT index,
                        [in] HREFTYPE hreftype
                       );

    HRESULT SetImplTypeFlags(
                        [in] UINT index,
                        [in] INT impltypeflags
                            );

    HRESULT SetAlignment(
                        [in] WORD cbAlignment
                        );

    HRESULT SetSchema(
                        [in] LPOLESTR lpstrSchema
                     );

    HRESULT AddVarDesc(
                        [in]  UINT index,
                        [in]  VARDESC * pvardesc
                      );

    HRESULT SetFuncAndParamNames(
                                 [in]  UINT index,
								 /* [in, size_is((long) cNames)] */
                                 [in]  PTR /* LPOLESTR * */ rgszNames,
                                 [in]  UINT cNames
                               );

    HRESULT SetVarName(
                        [in] UINT index,
                        [in] LPOLESTR szName
                      );

    HRESULT SetTypeDescAlias(
                              [in]  TYPEDESC * ptdescAlias
                            );

    HRESULT DefineFuncAsDllEntry(
                                 [in] UINT index,
                                 [in] LPOLESTR szDllName,
                                 [in] LPOLESTR szProcName
         );

    HRESULT SetFuncDocString(
                              [in] UINT index,
                              [in] LPOLESTR szDocString
         );

    HRESULT SetVarDocString(
                              [in] UINT index,
                              [in] LPOLESTR szDocString
                           );

    HRESULT SetFuncHelpContext(
                              [in] UINT index,
                              [in] DWORD dwHelpContext
         );

    HRESULT SetVarHelpContext(
                              [in] UINT index,
                              [in] DWORD dwHelpContext
         );

    HRESULT SetMops(
                              [in] UINT index,
                              [in] BSTR bstrMops
         );

    HRESULT SetTypeIdldesc(
                              [in] IDLDESC * pidldesc
         );

    HRESULT LayOut(
                     void
                  );

}




[
    uuid(00020406-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of ICreateTypeLib interface")
]

interface IVBCreateTypeLib : IUnknown
{

    typedef [unique] IVBCreateTypeLib *LPCREATETYPELIB;


    HRESULT CreateTypeInfo(
                            [in]  LPOLESTR szName,
                            [in]  TYPEKIND tkind,
                            [out, retval] IVBCreateTypeInfo **lplpictinfo
                           );

    HRESULT SetName( LPOLESTR szName);

    HRESULT SetVersion
    (
        [in] WORD wMajorVerNum,
        [in] WORD wMinorVerNum
    );




    HRESULT SetGuid
    (
        [in] REFGUID guid
    );

    HRESULT SetDocString
    (
        [in] LPOLESTR szDoc
    );


    HRESULT SetHelpFileName
    (
        [in] LPOLESTR szHelpFileName
    );

    HRESULT SetHelpContext
    (
        [in] DWORD dwHelpContext
    );

    HRESULT SetLcid
    (
        [in] LCID lcid
    );

    HRESULT SetLibFlags
    (
        [in] UINT uLibFlags
    );


    HRESULT SaveAllChanges
    (
        void
    );

}

[
    uuid(00020400-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of IDispatch interface")
]

interface IVBDispatch : IUnknown
{

    typedef [unique] IVBDispatch *LPDISPATCH;

    HRESULT GetTypeInfoCount
    (
        [out, retval] UINT * pctinfo
    );

    HRESULT GetTypeInfo
    (
        [in] UINT itinfo,
        [in] LCID lcid,
        [out, retval] IVBTypeInfo ** pptinfo
    );

    HRESULT GetIDsOfNames
    (
        [in] REFIID riid,
        [in /* ,size_is(cNames) */] PTR /* LPOLESTR * */ rgszNames,
        [in] UINT cNames,
        [in] LCID lcid,
        [in, out, size_is(cNames)] DISPID *rgdispid
    );

    HRESULT Invoke
    (
        [in] DISPID dispidMember,
        [in] REFIID riid,
        [in] LCID lcid,
        [in] WORD wFlags,
        [in, out] DISPPARAMS *pdispparams,
        [in, out, unique] VARIANT *pvarResult,
        [in, out] EXCEPINFO *pexcepinfo,
        [out, retval] UINT * puArgErr
    );

cpp_quote("/* DISPID reserved to indicate an \"unknown\" name */")
cpp_quote("/* only reserved for data members (properties); reused as a method dispid below */")
   const DISPID DISPID_UNKNOWN       = -1;

cpp_quote("/* DISPID reserved for the \"value\" property */")
   const DISPID DISPID_VALUE         = 0;

cpp_quote("/* The following DISPID is reserved to indicate the param")
cpp_quote(" * that is the right-hand-side (or \"put\" value) of a PropertyPut")
cpp_quote(" */")
const DISPID DISPID_PROPERTYPUT = -3;

cpp_quote("/* DISPID reserved for the standard \"NewEnum\" method */")
const DISPID DISPID_NEWENUM  = -4;

cpp_quote("/* DISPID reserved for the standard \"Evaluate\" method */")
const DISPID DISPID_EVALUATE = -5;

const DISPID DISPID_CONSTRUCTOR = -6;

const DISPID DISPID_DESTRUCTOR = -7;

const DISPID DISPID_COLLECT = -8;

cpp_quote("/* The range -500 through -999 is reserved for Controls */")
cpp_quote("/* The range 0x80010000 through 0x8001FFFF is reserved for Controls */")
cpp_quote("/* The remainder of the negative DISPIDs are reserved for future use */")

}

[	uuid(00020404-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of IEnumVARIANT interface")
]
interface IVBEnumVARIANT : IUnknown {

    HRESULT Next([in] ULONG celt,
				 [in, out] VARIANT *rgvar,
				 [in] PTR pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([in, out] IVBEnumVARIANT** ppenum);

}

[
    uuid(00020403-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of ITypeComp interface")
]

interface IVBTypeComp : IUnknown
{

    typedef [unique] IVBTypeComp *LPTYPECOMP;

    typedef [v1_enum] enum  DESCKIND
    {
        DESCKIND_NONE = 0,
        DESCKIND_FUNCDESC,
        DESCKIND_VARDESC,
        DESCKIND_TYPECOMP,
        DESCKIND_IMPLICITAPPOBJ,
        DESCKIND_MAX
    } DESCKIND;

    [switch_type(long)] union  BINDPTR
    {
    [case(DESCKIND_FUNCDESC)]
        FUNCDESC *lpfuncdesc;

    [case(DESCKIND_VARDESC)]
        VARDESC *lpvardesc;

    [case(DESCKIND_TYPECOMP)]
        [unique] IVBTypeComp *lptcomp;

    [default]
        ;
    };

    typedef union  BINDPTR BINDPTR;
    typedef BINDPTR *LPBINDPTR;

    HRESULT Bind
    (
        [in] LPOLESTR szName,
        [in] ULONG lHashVal,
        [in] WORD fFlags,
        [in, out] IVBTypeInfo **pptinfo,
        [in, out] DESCKIND *pdesckind,
        [in, out, switch_is((long) *pdesckind)] BINDPTR *pbindptr
    );

    HRESULT BindType
    (
        [in] LPOLESTR szName,
        [in] ULONG lHashVal,
        [in, out] IVBTypeInfo **pptinfo,
        [in, out] IVBTypeComp **pptcomp
    );
}

[
    uuid(00020401-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of ITypeInfo interface")
]

interface IVBTypeInfo : IUnknown
{

    typedef [unique] IVBTypeInfo *LPTYPEINFO;

/*---------------------------------------------------------------------*/
/*                            IVBTypeInfo                                */
/*---------------------------------------------------------------------*/

    HRESULT GetTypeAttr
    (
        [out, retval] TYPEATTR **pptypeattr
    );

    HRESULT GetTypeComp
    (
        [out, retval] IVBTypeComp **pptcomp
    );

    HRESULT GetFuncDesc
    (
        [in] UINT index,
        [out, retval] FUNCDESC **pppfuncdesc
    );

    HRESULT GetVarDesc
    (
        [in] UINT index,
        [out, retval] VARDESC **ppvardesc
    );

    HRESULT GetNames
    (
        [in] MEMBERID memid,
        // [in, out, size_is(cMaxNames), length_is(*pcNames)] BSTR *rgbstrNames,
        [in] PTR /* BSTR * */ rgbstrNames,
        [in] UINT cMaxNames,
        [out, retval] UINT * pcNames
    );


    HRESULT GetRefTypeOfImplType
    (
        [in] UINT index,
        [out, retval] HREFTYPE *hpreftype
    );


    HRESULT GetImplTypeFlags
    (
        [in] UINT index,
        [out, retval] UINT * pimpltypeflags
    );



    HRESULT GetIDsOfNames
    (
        [in /* , size_is(cNames) */] PTR /* OLECHAR ** */ rglpszNames,
        [in] UINT cNames,
        [in, out, size_is(cNames)] MEMBERID *rgmemid
    );

    HRESULT Invoke
    (
    [in, unique] void *pvInstance,
        [in] MEMBERID memid,
        [in] WORD wFlags,
        [in] DISPPARAMS *pdispparams,
        [in, out] VARIANT *pvarResult,
        [in, out] EXCEPINFO *pexcepinfo,
        [out, retval] UINT * puArgErr
    );

    HRESULT GetDocumentation
    (
        [in] MEMBERID memid,
		// Any of these can be NULL, so VB must handle indirectly through pointer
        [in] PTR pbstrName,
        [in] PTR pbstrDocString,
        [in] PTR pdwHelpContext,
        [in] PTR pbstrHelpFile
    );

    HRESULT GetDllEntry
    (
        [in] MEMBERID memid,
        [in] INVOKEKIND invkind,
		// Any of these can be NULL, so VB must handle indirectly through pointer
        [in] PTR pbstrDllName,
        [in] PTR pbstrName,
        [in] PTR pwOrdinal
    );

    HRESULT GetRefTypeInfo
    (
        [in] HREFTYPE hreftype,
        [out, retval] IVBTypeInfo ** pptinfo
    );

    HRESULT __stdcall AddressOfMember
    (
        [in] MEMBERID memid,
        [in] INVOKEKIND invkind,
        [in] PTR ppv
    );

    HRESULT CreateInstance
    (
        [in] IUnknown * puncOuter,
        [in] REFIID riid,
        [in, out] void * ppvObj
    );

    HRESULT GetMops
    (
        [in] MEMBERID memid,
		// Can be NULL, so VB must handle indirectly through pointer
        [in] PTR pbstrMops
    );

    HRESULT GetContainingTypeLib
    (
        [in, out] IVBTypeLib **pptlib,
        [in, out] UINT *pindex
    );

    void ReleaseTypeAttr
    (
        [in] TYPEATTR *ptypeattr
    );

    void ReleaseFuncDesc
    (
        [in] FUNCDESC *pfuncdesc
    );

    void ReleaseVarDesc
    (
        [in] VARDESC *pvardesc
    );
}

[
    uuid(00020402-0000-0000-C000-000000000046),
    odl,
	helpstring("Visual Basic version of ITypeLib interface")
]
interface IVBTypeLib : IUnknown
{

    typedef [v1_enum] enum  SYSKIND
    {
        SYS_WIN16 = 0,
        SYS_WIN32,
        SYS_MAC
    } SYSKIND;


    typedef [v1_enum] enum  LIBFLAGS
    {
      LIBFLAG_FRESTRICTED = 0x01
      , LIBFLAG_FCONTROL = 0x02
      , LIBFLAG_FHIDDEN = 0x04
    } LIBFLAGS;

    typedef [unique] IVBTypeLib *LPTYPELIB;

    typedef struct  TLIBATTR
    {
        UUID libguid;
        LCID liblcid;
        SYSKIND syskind;
        WORD wMajorVerNum;
        WORD wMinorVerNum;
        WORD wLibFlags;
    } TLIBATTR;

    typedef TLIBATTR *LPTLIBATTR;

    UINT GetTypeInfoCount
    (
        void
    );

    HRESULT GetTypeInfo
    (
        [in] UINT index,
        [out, retval] IVBTypeInfo **ppitinfo
    );

    HRESULT GetTypeInfoType
    (
        [in] UINT index,
        [out, retval] TYPEKIND * ptkind
    );

    HRESULT GetTypeInfoOfGuid
    (
        [in] REFGUID guid,
        [out, retval] IVBTypeInfo **pptinfo
    );

    HRESULT GetLibAttr
    (
        [out, retval] TLIBATTR **pptlibattr
    );

    HRESULT GetTypeComp
    (
        [out, retval] IVBTypeComp **pptcomp
    );

    HRESULT GetDocumentation
    (
        [in] INT index,
		// Any of these can be NULL, so VB must handle indirectly through pointer
        [in] PTR pbstrName,
        [in] PTR pbstrDocString,
        [in] PTR pdwHelpContext,
        [in] PTR pbstrHelpFile
    );

    HRESULT IsName
    (
        [in] LPOLESTR szNameBuf,
        [in] ULONG lHashVal,
        [out, retval] BOOL *pfName
    );

    HRESULT FindName
    (
        [in] LPOLESTR szNameBuf,
        [in] ULONG lHashVal,
        //[in, out, size_is(*pcFound), length_is(*pcFound)] IVBTypeInfo ** rgptinfo,
        [in, out] IVBTypeInfo ** rgptinfo,
        //[in, out, size_is(*pcFound), length_is(*pcFound)] MEMBERID * rgmemid,
        [in, out] MEMBERID * rgmemid,
        [in, out] USHORT *pcFound
    );

    void ReleaseTLibAttr
    (
        [in] TLIBATTR *ptlibattr
    );

}

[
    uuid(1CF2B120-547D-101B-8E65-08002B2BD119),
    odl,
	helpstring("Visual Basic version of IErrorInfo interface")
]

interface IVBErrorInfo: IUnknown
{

    typedef [unique] IVBErrorInfo *LPERRORINFO;

    HRESULT GetGUID(
                     [in, out] LPGUID pguid
                   );

    HRESULT GetSource(
                     [out, retval] BSTR * pbstrSource
                   );

    HRESULT GetDescription(
                     [out, retval] BSTR * pbstrDescription
                   );

    HRESULT GetHelpFile(
                     [out, retval] BSTR * pbstrHelpFile
                   );

    HRESULT GetHelpContext(
                     [out, retval] DWORD * pdwHelpContext
                   );

}

[
    uuid(22F03340-547D-101B-8E65-08002B2BD119),
    odl,
	helpstring("Visual Basic version of ICreateErrorInfo interface")
]
interface IVBCreateErrorInfo: IUnknown
{

    typedef [unique] IVBCreateErrorInfo *LPCREATEERRORINFO;

    HRESULT SetGUID(
                     [in] REFGUID rguid
                   );

    HRESULT SetSource(
                     [in] LPOLESTR szSource
                   );

    HRESULT SetDescription(
                     [in] LPOLESTR szDescription
                   );

    HRESULT SetHelpFile(
                     [in] LPOLESTR szHelpFile
                   );

    HRESULT SetHelpContext(
                     [in] DWORD dwHelpContext
                   );

}

[
    uuid(DF0B3D60-548F-101B-8E65-08002B2BD119),
    odl,
	helpstring("Visual Basic version of ISupportErrorInfo interface")
]
interface IVBSupportErrorInfo: IUnknown
{

    typedef [unique] IVBSupportErrorInfo *LPSUPPORTERRORINFO;

    HRESULT InterfaceSupportsErrorInfo(
                     [in] REFIID riid
                   );

}
