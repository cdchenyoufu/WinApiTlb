// Multimedia systems

typedef DWORD   MCIERROR;       // error return code, 0 means no error

typedef UINT    MCIDEVICEID;    // MCI device ID type

// typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);
typedef UINT YIELDPROC;

// parameter block for MCI_OPEN command message
typedef struct MCI_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCTSTR     lpstrDeviceType;
    LPCTSTR     lpstrElementName;
    LPCTSTR     lpstrAlias;
} MCI_OPEN_PARMS, *PMCI_OPEN_PARMS, *LPMCI_OPEN_PARMS;

// generic parameter block for MCI command messages with no special parameters
typedef struct MCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, *LPMCI_GENERIC_PARMS;


// parameter block for MCI_PLAY command message
typedef struct MCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, *LPMCI_PLAY_PARMS;

// parameter block for MCI_SEEK command message
typedef struct MCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, *LPMCI_SEEK_PARMS;

// parameter block for MCI_STATUS command message
typedef struct MCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, * LPMCI_STATUS_PARMS;

// parameter block for MCI_INFO command message
typedef struct MCI_INFO_PARMS {
    DWORD   dwCallback;
    LPTSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, * LPMCI_INFO_PARMS;

// parameter block for MCI_GETDEVCAPS command message
typedef struct MCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, * LPMCI_GETDEVCAPS_PARMS;

// parameter block for MCI_SYSINFO command message
typedef struct MCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPTSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMS, *PMCI_SYSINFO_PARMS, * LPMCI_SYSINFO_PARMS;

// parameter block for MCI_SET command message
typedef struct MCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS, *LPMCI_SET_PARMS;

// parameter block for MCI_BREAK command message
typedef struct MCI_BREAK_PARMS {
    DWORD   dwCallback;
    int     nVirtKey;
    HWND    hwndBreak;
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, * LPMCI_BREAK_PARMS;

// parameter block for MCI_SAVE command message
typedef struct MCI_SAVE_PARMS {
    DWORD    dwCallback;
    LPCTSTR   lpfilename;
} MCI_SAVE_PARMS, *PMCI_SAVE_PARMS, * LPMCI_SAVE_PARMS;

// parameter block for MCI_LOAD command message
typedef struct MCI_LOAD_PARMS {
    DWORD    dwCallback;
    LPCTSTR  lpfilename;
} MCI_LOAD_PARMS, *PMCI_LOAD_PARMS, * LPMCI_LOAD_PARMS;

// parameter block for MCI_RECORD command message
typedef struct MCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, *LPMCI_RECORD_PARMS;

// parameter block for MCI_PLAY command message
typedef struct MCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, *LPMCI_VD_PLAY_PARMS;

// parameter block for MCI_STEP command message
typedef struct MCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, *LPMCI_VD_STEP_PARMS;

// parameter block for MCI_ESCAPE command message
typedef struct MCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCTSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMS, *PMCI_VD_ESCAPE_PARMS, *LPMCI_VD_ESCAPE_PARMS;

// parameter block for MCI_OPEN command message
typedef struct MCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCTSTR      lpstrDeviceType;
    LPCTSTR      lpstrElementName;
    LPCTSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, *PMCI_WAVE_OPEN_PARMS, *LPMCI_WAVE_OPEN_PARMS;

// parameter block for MCI_DELETE command message
typedef struct MCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, *LPMCI_WAVE_DELETE_PARMS;

// parameter block for MCI_SET command message
typedef struct MCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    UINT    wInput;
    UINT    wOutput;
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, * LPMCI_WAVE_SET_PARMS;

// parameter block for MCI_SET command message
typedef struct MCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, * LPMCI_SEQ_SET_PARMS;

// parameter block for MCI_OPEN command message

typedef struct MCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCTSTR      lpstrDeviceType;
    LPCTSTR      lpstrElementName;
    LPCTSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMS, *PMCI_ANIM_OPEN_PARMS, *LPMCI_ANIM_OPEN_PARMS;

// parameter block for MCI_PLAY command message
typedef struct MCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, *LPMCI_ANIM_PLAY_PARMS;

// parameter block for MCI_STEP command message
typedef struct MCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, *LPMCI_ANIM_STEP_PARMS;

// parameter block for MCI_WINDOW command message
typedef struct MCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCTSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMS, *PMCI_ANIM_WINDOW_PARMS, * LPMCI_ANIM_WINDOW_PARMS;

// parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages
typedef struct MCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
    POINTL  ptOffset;
    POINTL  ptExtent;
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * LPMCI_ANIM_RECT_PARMS;

// parameter block for MCI_UPDATE PARMS
typedef struct MCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, * LPMCI_ANIM_UPDATE_PARMS;

// parameter block for MCI_OPEN command message
typedef struct MCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCTSTR      lpstrDeviceType;
    LPCTSTR      lpstrElementName;
    LPCTSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMS, *PMCI_OVLY_OPEN_PARMS, *LPMCI_OVLY_OPEN_PARMS;

// parameter block for MCI_WINDOW command message
typedef struct MCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCTSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMS, *PMCI_OVLY_WINDOW_PARMS, * LPMCI_OVLY_WINDOW_PARMS;

// parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages
typedef struct MCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
    POINTL  ptOffset;
    POINTL  ptExtent;
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, * LPMCI_OVLY_RECT_PARMS;

// parameter block for MCI_SAVE command message
typedef struct MCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCTSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, *PMCI_OVLY_SAVE_PARMS, * LPMCI_OVLY_SAVE_PARMS;

// parameter block for MCI_LOAD command message
typedef struct MCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCTSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, *PMCI_OVLY_LOAD_PARMS, * LPMCI_OVLY_LOAD_PARMS;

[
#ifdef UNICODE
uuid(6467504E-3A82-101B-8181-00AA003743D3),
#else
uuid(6467404E-3A82-101B-8181-00AA003743D3),
#endif
helpstring("Windows Multimedia Functions"),
dllname("WINMM.DLL")
]

module Multimedia {

    /*
    // ******* Multimedia messages *******
    const UINT MM_JOY1MOVE        = 0x3A0;           // joystick
    const UINT MM_JOY2MOVE        = 0x3A1;
    const UINT MM_JOY1ZMOVE       = 0x3A2;
    const UINT MM_JOY2ZMOVE       = 0x3A3;
    const UINT MM_JOY1BUTTONDOWN  = 0x3B5;
    const UINT MM_JOY2BUTTONDOWN  = 0x3B6;
    const UINT MM_JOY1BUTTONUP    = 0x3B7;
    const UINT MM_JOY2BUTTONUP    = 0x3B8;

    const UINT MM_MCINOTIFY       = 0x3B9;           // MCI

    const UINT MM_WOM_OPEN        = 0x3BB;           // waveform output
    const UINT MM_WOM_CLOSE       = 0x3BC;
    const UINT MM_WOM_DONE        = 0x3BD;

    const UINT MM_WIM_OPEN        = 0x3BE;           // waveform input
    const UINT MM_WIM_CLOSE       = 0x3BF;
    const UINT MM_WIM_DATA        = 0x3C0;

    const UINT MM_MIM_OPEN        = 0x3C1;           // MIDI input
    const UINT MM_MIM_CLOSE       = 0x3C2;
    const UINT MM_MIM_DATA        = 0x3C3;
    const UINT MM_MIM_LONGDATA    = 0x3C4;
    const UINT MM_MIM_ERROR       = 0x3C5;
    const UINT MM_MIM_LONGERROR   = 0x3C6;

    const UINT MM_MOM_OPEN        = 0x3C7;           // MIDI output
    const UINT MM_MOM_CLOSE       = 0x3C8;
    const UINT MM_MOM_DONE        = 0x3C9;


    // ****** String resource number bases (internal use) *****

    const int MMSYSERR_BASE         = 0;
    const int WAVERR_BASE           = 32;
    const int MIDIERR_BASE          = 64;
    const int TIMERR_BASE           = 96;
    const int JOYERR_BASE           = 160;
    const int MCIERR_BASE           = 256;

    const int MCI_STRING_OFFSET     = 512;
    const int MCI_VD_OFFSET         = 1024;
    const int MCI_CD_OFFSET         = 1088;
    const int MCI_WAVE_OFFSET       = 1152;
    const int MCI_SEQ_OFFSET        = 1216;

    // ******* General error return values ********

    // general error return values
    const int MMSYSERR_NOERROR      = 0;                    // no error
    //define MMSYSERR_ERROR       (MMSYSERR_BASE + 1)  // unspecified error
    //define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  // device ID out of range
    //define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  // driver failed enable
    //define MMSYSERR_ALLOCATED   (MMSYSERR_BASE + 4)  // device already allocated
    //define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  // device handle is invalid
    //define MMSYSERR_NODRIVER    (MMSYSERR_BASE + 6)  // no device driver present
    //define MMSYSERR_NOMEM       (MMSYSERR_BASE + 7)  // memory allocation error
    //define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  // function isn't supported
    //define MMSYSERR_BADERRNUM   (MMSYSERR_BASE + 9)  // error value out of range
    //define MMSYSERR_INVALFLAG   (MMSYSERR_BASE + 10) // invalid flag passed
    //define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) // invalid parameter passed
    //define MMSYSERR_LASTERROR   (MMSYSERR_BASE + 11) // last error in range
    */

    // ******** Omit Installable driver support *****

    // ******* Omit Driver callback support ******

    // ******* Manufacturer and product IDs *****

    /*
    // Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
    // MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

    // manufacturer IDs
    const int MM_MICROSOFT           = 1;       // Microsoft Corp.

    // product IDs
    const int MM_MIDI_MAPPER         = 1;       // MIDI Mapper
    const int MM_WAVE_MAPPER         = 2;       // Wave Mapper

    const int MM_SNDBLST_MIDIOUT     = 3;       // Sound Blaster MIDI output port
    const int MM_SNDBLST_MIDIIN      = 4;       // Sound Blaster MIDI input port
    const int MM_SNDBLST_SYNTH       = 5;       // Sound Blaster internal synthesizer
    const int MM_SNDBLST_WAVEOUT     = 6;       // Sound Blaster waveform output
    const int MM_SNDBLST_WAVEIN      = 7;       // Sound Blaster waveform input

    const int MM_ADLIB               = 9 ;      // Ad Lib-compatible synthesizer

    const int MM_MPU401_MIDIOUT      = 10;      // MPU401-compatible MIDI output port
    const int MM_MPU401_MIDIIN       = 11;      // MPU401-compatible MIDI input port

    //define MM_PC_JOYSTICK         12      // Joystick adapter
    */

    // ****** General MMSYSTEM support *******

    /*
    WORD WINAPI mmsystemGetVersion(void);
    */


    // ****** Sound support ******

    [
    usesgetlasterror,
	#ifdef UNICODE
    entry("sndPlaySoundW"),
	#else
    entry("sndPlaySoundA"),
	#endif
    helpstring("Plays a sound pointer according to flags"),
    ]
    BOOL WINAPI sndPlaySound(LPTSTR lpszSound, UINT uFlags);

    [
    usesgetlasterror,
	#ifdef UNICODE
    entry("sndPlaySoundW"),
	#else
    entry("sndPlaySoundA"),
	#endif
    helpstring("Plays a sound string according to flags"),
    ]
    BOOL WINAPI sndPlaySoundAsBytes(BYTE * lpbSoundName, UINT uFlags);

    [
    usesgetlasterror,
	#ifdef UNICODE
    entry("sndPlaySoundW"),
	#else
    entry("sndPlaySoundA"),
	#endif
    helpstring("Plays a sound pointer according to flags"),
    ]
    BOOL WINAPI sndPlaySoundAsLp(DWORD dwSound, UINT uFlags);

    // flag values for wFlags parameter
    [ helpstring("sndPlaySound: Play synchronously (default)") ]
    const UINT SND_SYNC          = 0x0000;
    [ helpstring("sndPlaySound: Play asynchronously") ]
    const UINT SND_ASYNC         = 0x0001;
    [ helpstring("sndPlaySound: Don't use default sound") ]
    const UINT SND_NODEFAULT     = 0x0002;
    [ helpstring("sndPlaySound: String parameter points to sound in memory") ]
    const UINT SND_MEMORY        = 0x0004;
    [ helpstring("sndPlaySound: Loop the sound until next sndPlaySound") ]
    const UINT SND_LOOP          = 0x0008;
    [ helpstring("sndPlaySound: Don't stop any currently playing sound") ]
    const UINT SND_NOSTOP        = 0x0010;

    // ****** Waveform audio support ******

    /*
    // waveform audio error return values
    //define WAVERR_BADFORMAT     (WAVERR_BASE + 0)    // unsupported wave format
    //define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    // still something playing
    //define WAVERR_UNPREPARED    (WAVERR_BASE + 2)    // header not prepared
    //define WAVERR_SYNC          (WAVERR_BASE + 3)    // device is synchronous
    //define WAVERR_LASTERROR     (WAVERR_BASE + 3)    // last error in range

    // waveform audio data types
    DECLARE_HANDLE(HWAVE);
    DECLARE_HANDLE(HWAVEIN);
    DECLARE_HANDLE(HWAVEOUT);
    typedef HWAVEIN *LPHWAVEIN;
    typedef HWAVEOUT *LPHWAVEOUT;
    typedef DRVCALLBACK WAVECALLBACK;
    typedef WAVECALLBACK *LPWAVECALLBACK;

    // Omit wave callback messages

    // device ID for wave device mapper
    //define WAVE_MAPPER    (-1)

    // flags for dwFlags parameter in waveOutOpen() and waveInOpen()
    //define  WAVE_FORMAT_QUERY    0x0001
    //define  WAVE_ALLOWSYNC       0x0002

    // wave data block header
    typedef struct wavehdr_tag {
        LPTSTR       lpData;                 // pointer to locked data buffer
        DWORD       dwBufferLength;         // length of data buffer
        DWORD       dwBytesRecorded;        // used for input only
        DWORD       dwUser;                 // for client's use
        DWORD       dwFlags;                // assorted flags (see defines)
        DWORD       dwLoops;                // loop control counter
        struct wavehdr_tag *lpNext;     // reserved for driver
        DWORD       reserved;               // reserved for driver
    } WAVEHDR;
    typedef WAVEHDR       *PWAVEHDR;
    typedef WAVEHDR *NPWAVEHDR;
    typedef WAVEHDR  *LPWAVEHDR;

    // flags for dwFlags field of WAVEHDR
    //define WHDR_DONE      0x00000001  // done bit
    //define WHDR_PREPARED  0x00000002  // set if this header has been prepared
    //define WHDR_BEGINLOOP 0x00000004  // loop start block
    //define WHDR_ENDLOOP   0x00000008  // loop end block
    //define WHDR_INQUEUE   0x00000010  // reserved for driver

    // waveform output device capabilities structure
    typedef struct waveoutcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        DWORD   dwFormats;             // formats supported
        UINT    wChannels;             // number of sources supported
        DWORD   dwSupport;             // functionality supported by driver
    } WAVEOUTCAPS;
    typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
    typedef WAVEOUTCAPS *NPWAVEOUTCAPS;
    typedef WAVEOUTCAPS  *LPWAVEOUTCAPS;

    // flags for dwSupport field of WAVEOUTCAPS
    //define WAVECAPS_PITCH         0x0001   // supports pitch control
    //define WAVECAPS_PLAYBACKRATE  0x0002   // supports playback rate control
    //define WAVECAPS_VOLUME        0x0004   // supports volume control
    //define WAVECAPS_LRVOLUME      0x0008   // separate left-right volume control
    //define WAVECAPS_SYNC          0x0010

    // waveform input device capabilities structure
    typedef struct waveincaps_tag {
        UINT    wMid;                    // manufacturer ID
        UINT    wPid;                    // product ID
        VERSION vDriverVersion;          // version of the driver
        char    szPname[MAXPNAMELEN];    // product name (NULL terminated string)
        DWORD   dwFormats;               // formats supported
        UINT    wChannels;               // number of channels supported
    } WAVEINCAPS;
    typedef WAVEINCAPS       *PWAVEINCAPS;
    typedef WAVEINCAPS *NPWAVEINCAPS;
    typedef WAVEINCAPS  *LPWAVEINCAPS;

    // defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
    //define WAVE_INVALIDFORMAT    0x00000000       // invalid format
    //define WAVE_FORMAT_1M08      0x00000001       // 11.025 kHz, Mono,   8-bit
    //define WAVE_FORMAT_1S08      0x00000002       // 11.025 kHz, Stereo, 8-bit
    //define WAVE_FORMAT_1M16      0x00000004       // 11.025 kHz, Mono,   16-bit
    //define WAVE_FORMAT_1S16      0x00000008       // 11.025 kHz, Stereo, 16-bit
    //define WAVE_FORMAT_2M08      0x00000010       // 22.05  kHz, Mono,   8-bit
    //define WAVE_FORMAT_2S08      0x00000020       // 22.05  kHz, Stereo, 8-bit
    //define WAVE_FORMAT_2M16      0x00000040       // 22.05  kHz, Mono,   16-bit
    //define WAVE_FORMAT_2S16      0x00000080       // 22.05  kHz, Stereo, 16-bit
    //define WAVE_FORMAT_4M08      0x00000100       // 44.1   kHz, Mono,   8-bit
    //define WAVE_FORMAT_4S08      0x00000200       // 44.1   kHz, Stereo, 8-bit
    //define WAVE_FORMAT_4M16      0x00000400       // 44.1   kHz, Mono,   16-bit
    //define WAVE_FORMAT_4S16      0x00000800       // 44.1   kHz, Stereo, 16-bit

    // general waveform format structure (information common to all formats)
    typedef struct waveformat_tag {
        WORD    wFormatTag;        // format type
        WORD    nChannels;         // number of channels (i.e. mono, stereo, etc.)
        DWORD   nSamplesPerSec;    // sample rate
        DWORD   nAvgBytesPerSec;   // for buffer estimation
        WORD    nBlockAlign;       // block size of data
    } WAVEFORMAT;
    typedef WAVEFORMAT       *PWAVEFORMAT;
    typedef WAVEFORMAT *NPWAVEFORMAT;
    typedef WAVEFORMAT  *LPWAVEFORMAT;

    // flags for wFormatTag field of WAVEFORMAT
    //define WAVE_FORMAT_PCM    1

    // specific waveform format structure for PCM data
    typedef struct pcmwaveformat_tag {
        WAVEFORMAT  wf;
        WORD        wBitsPerSample;
    } PCMWAVEFORMAT;
    typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
    typedef PCMWAVEFORMAT *NPPCMWAVEFORMAT;
    typedef PCMWAVEFORMAT  *LPPCMWAVEFORMAT;

    // waveform audio function prototypes
    UINT WINAPI waveOutGetNumDevs(void);
    UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
        UINT uSize);
    UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
    UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI waveOutGetErrorText(UINT uError, LPTSTR lpText, UINT uSize);
    UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
        const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
         WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
    UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
        WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
    UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
        UINT uSize);
    UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
    UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
        UINT uSize);
    UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
    UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
    UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
    UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
    UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

    DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);

    UINT WINAPI waveInGetNumDevs(void);
    UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
        UINT uSize);
    UINT WINAPI waveInGetErrorText(UINT uError, LPTSTR lpText, UINT uSize);
    UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
        const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI waveInClose(HWAVEIN hWaveIn);
    UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
        WAVEHDR FAR* lpWaveInHdr, UINT uSize);
    UINT WINAPI waveInStart(HWAVEIN hWaveIn);
    UINT WINAPI waveInStop(HWAVEIN hWaveIn);
    UINT WINAPI waveInReset(HWAVEIN hWaveIn);
    UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
        UINT uSize);
    UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

    DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
    */


    // ****** MIDI audio support *******

    /*
    // MIDI error return values
    //define MIDIERR_UNPREPARED   (MIDIERR_BASE + 0)   // header not prepared
    //define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   // still something playing
    //define MIDIERR_NOMAP        (MIDIERR_BASE + 2)   // no current map
    //define MIDIERR_NOTREADY     (MIDIERR_BASE + 3)   // hardware is still busy
    //define MIDIERR_NODEVICE     (MIDIERR_BASE + 4)   // port no longer connected
    //define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   // invalid setup
    //define MIDIERR_LASTERROR    (MIDIERR_BASE + 5)   // last error in range

    // MIDI audio data types
    DECLARE_HANDLE(HMIDI);
    DECLARE_HANDLE(HMIDIIN);
    DECLARE_HANDLE(HMIDIOUT);
    typedef HMIDIIN *LPHMIDIIN;
    typedef HMIDIOUT *LPHMIDIOUT;
    typedef DRVCALLBACK MIDICALLBACK;
    typedef MIDICALLBACK *LPMIDICALLBACK;
    //define MIDIPATCHSIZE  128
    typedef WORD PATCHARRAY[MIDIPATCHSIZE];
    typedef WORD *LPPATCHARRAY;
    typedef WORD KEYARRAY[MIDIPATCHSIZE];
    typedef WORD *LPKEYARRAY;

    // MIDI callback messages
    //define MIM_OPEN       MM_MIM_OPEN
    //define MIM_CLOSE      MM_MIM_CLOSE
    //define MIM_DATA       MM_MIM_DATA
    //define MIM_LONGDATA   MM_MIM_LONGDATA
    //define MIM_ERROR      MM_MIM_ERROR
    //define MIM_LONGERROR  MM_MIM_LONGERROR
    //define MOM_OPEN       MM_MOM_OPEN
    //define MOM_CLOSE      MM_MOM_CLOSE
    //define MOM_DONE       MM_MOM_DONE

    // device ID for MIDI mapper
    //define MIDIMAPPER    (-1)
    //define MIDI_MAPPER    (-1)

    // flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches()
    //define MIDI_CACHE_ALL     1
    //define MIDI_CACHE_BESTFIT 2
    //define MIDI_CACHE_QUERY   3
    //define MIDI_UNCACHE       4

    // MIDI output device capabilities structure
    typedef struct midioutcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT    wTechnology;           // type of device
        UINT    wVoices;               // # of voices (internal synth only)
        UINT    wNotes;                // max # of notes (internal synth only)
        UINT    wChannelMask;          // channels used (internal synth only)
        DWORD   dwSupport;             // functionality supported by driver
    } MIDIOUTCAPS;
    typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
    typedef MIDIOUTCAPS *NPMIDIOUTCAPS;
    typedef MIDIOUTCAPS  *LPMIDIOUTCAPS;

    // flags for wTechnology field of MIDIOUTCAPS structure
    //define MOD_MIDIPORT   1  // output port
    //define MOD_SYNTH      2  // generic internal synth
    //define MOD_SQSYNTH    3  // square wave internal synth
    //define MOD_FMSYNTH    4  // FM internal synth
    //define MOD_MAPPER     5  // MIDI mapper

    // flags for dwSupport field of MIDIOUTCAPS structure
    //define MIDICAPS_VOLUME         0x0001  // supports volume control
    //define MIDICAPS_LRVOLUME       0x0002  // separate left-right volume control
    //define MIDICAPS_CACHE          0x0004

    // MIDI output device capabilities structure
    typedef struct midiincaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
    } MIDIINCAPS;
    typedef MIDIINCAPS      *PMIDIINCAPS;
    typedef MIDIINCAPS *NPMIDIINCAPS;
    typedef MIDIINCAPS  *LPMIDIINCAPS;

    // MIDI data block header
    typedef struct midihdr_tag {
        LPTSTR       lpData;               // pointer to locked data block
        DWORD       dwBufferLength;       // length of data in data block
        DWORD       dwBytesRecorded;      // used for input only
        DWORD       dwUser;               // for client's use
        DWORD       dwFlags;              // assorted flags (see defines)
        struct midihdr_tag *lpNext;   // reserved for driver
        DWORD       reserved;             // reserved for driver
    } MIDIHDR;
    typedef MIDIHDR       *PMIDIHDR;
    typedef MIDIHDR *NPMIDIHDR;
    typedef MIDIHDR  *LPMIDIHDR;

    // flags for dwFlags field of MIDIHDR structure
    //define MHDR_DONE      0x00000001       // done bit
    //define MHDR_PREPARED  0x00000002       // set if header prepared
    //define MHDR_INQUEUE   0x00000004       // reserved for driver

    // MIDI function prototypes
    UINT WINAPI midiOutGetNumDevs(void);
    UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
        MIDIOUTCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
    UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI midiOutGetErrorText(UINT uError, LPTSTR lpText, UINT uSize);
    UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
        DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
    UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
    UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
        MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
    UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
    UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
        UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
    UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
        UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
    UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

    DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);

    UINT WINAPI midiInGetNumDevs(void);
    UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
        LPMIDIINCAPS lpCaps, UINT uSize);
    UINT WINAPI midiInGetErrorText(UINT uError, LPTSTR lpText, UINT uSize);
    UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
        DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
    UINT WINAPI midiInClose(HMIDIIN hMidiIn);
    UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
        MIDIHDR FAR* lpMidiInHdr, UINT uSize);
    UINT WINAPI midiInStart(HMIDIIN hMidiIn);
    UINT WINAPI midiInStop(HMIDIIN hMidiIn);
    UINT WINAPI midiInReset(HMIDIIN hMidiIn);
    UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

    DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
    */

    // ****** Auxiliary audio support ******

    /*
    // device ID for aux device mapper
    //define AUX_MAPPER    (-1)

    // Auxiliary audio device capabilities structure
    typedef struct auxcaps_tag {
        UINT    wMid;                  // manufacturer ID
        UINT    wPid;                  // product ID
        VERSION vDriverVersion;        // version of the driver
        char    szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT    wTechnology;           // type of device
        DWORD   dwSupport;             // functionality supported by driver
    } AUXCAPS;
    typedef AUXCAPS       *PAUXCAPS;
    typedef AUXCAPS *NPAUXCAPS;
    typedef AUXCAPS  *LPAUXCAPS;

    // flags for wTechnology field in AUXCAPS structure
    //define AUXCAPS_CDAUDIO    1      // audio from internal CD-ROM drive
    //define AUXCAPS_AUXIN     2       // audio from auxiliary input jacks

    // flags for dwSupport field in AUXCAPS structure
    //define AUXCAPS_VOLUME         0x0001  // supports volume control
    //define AUXCAPS_LRVOLUME       0x0002  // separate left-right volume control

    // auxiliary audio function prototypes
    UINT WINAPI auxGetNumDevs(void);
    UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
    UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

    DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
    */


    // ********** Timer support ********

    /* Omit all except timeGetTime
    */

    [
    usesgetlasterror,
    entry("timeGetTime"),
    helpstring("Gets the time in milliseconds"),
    ]
    DWORD WINAPI timeGetTime();

    // ****** Joystick support ******

    /*
    // joystick error return values
    //define JOYERR_NOERROR       (0)                  // no error
    //define JOYERR_PARMS         (JOYERR_BASE+5)      // bad parameters
    //define JOYERR_NOCANDO       (JOYERR_BASE+6)      // request not completed
    //define JOYERR_UNPLUGGED     (JOYERR_BASE+7)      // joystick is unplugged

    // constants used with JOYINFO structure and MM_JOY* messages
    //define JOY_BUTTON1        0x0001
    //define JOY_BUTTON2        0x0002
    //define JOY_BUTTON3        0x0004
    //define JOY_BUTTON4        0x0008
    //define JOY_BUTTON1CHG     0x0100
    //define JOY_BUTTON2CHG     0x0200
    //define JOY_BUTTON3CHG     0x0400
    //define JOY_BUTTON4CHG     0x0800

    // joystick ID constants
    //define JOYSTICKID1        0
    //define JOYSTICKID2        1

    // joystick device capabilities data structure
    typedef struct joycaps_tag {
        UINT wMid;                  // manufacturer ID
        UINT wPid;                  // product ID
        char szPname[MAXPNAMELEN];  // product name (NULL terminated string)
        UINT wXmin;                 // minimum x position value
        UINT wXmax;                 // maximum x position value
        UINT wYmin;                 // minimum y position value
        UINT wYmax;                 // maximum y position value
        UINT wZmin;                 // minimum z position value
        UINT wZmax;                 // maximum z position value
        UINT wNumButtons;           // number of buttons
        UINT wPeriodMin;            // minimum message period when captured
        UINT wPeriodMax;            // maximum message period when captured
        } JOYCAPS;
    typedef JOYCAPS       *PJOYCAPS;
    typedef JOYCAPS *NPJOYCAPS;
    typedef JOYCAPS  *LPJOYCAPS;

    // joystick information data structure
    typedef struct joyinfo_tag {
        UINT wXpos;                 // x position
        UINT wYpos;                 // y position
        UINT wZpos;                 // z position
        UINT wButtons;              // button states
        } JOYINFO;
    typedef JOYINFO       *PJOYINFO;
    typedef JOYINFO *NPJOYINFO;
    typedef JOYINFO  *LPJOYINFO;

    // joystick function prototypes
    UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
    UINT WINAPI joyGetNumDevs(void);
    UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
    UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
    UINT WINAPI joyReleaseCapture(UINT uJoyID);
    UINT WINAPI joySetCapture(HWND hwnd hwnd, UINT uJoyID, UINT uPeriod,
        BOOL bChanged);
    UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);
    */


    // ****** Multimedia File I/O support *******

    /*
    // MMIO error return values
    //define MMIOERR_BASE           256
    //define MMIOERR_FILENOTFOUND   (MMIOERR_BASE + 1)  // file not found
    //define MMIOERR_OUTOFMEMORY    (MMIOERR_BASE + 2)  // out of memory
    //define MMIOERR_CANNOTOPEN     (MMIOERR_BASE + 3)  // cannot open
    //define MMIOERR_CANNOTCLOSE    (MMIOERR_BASE + 4)  // cannot close
    //define MMIOERR_CANNOTREAD     (MMIOERR_BASE + 5)  // cannot read
    //define MMIOERR_CANNOTWRITE    (MMIOERR_BASE + 6)  // cannot write
    //define MMIOERR_CANNOTSEEK     (MMIOERR_BASE + 7)  // cannot seek
    //define MMIOERR_CANNOTEXPAND   (MMIOERR_BASE + 8)  // cannot expand file
    //define MMIOERR_CHUNKNOTFOUND  (MMIOERR_BASE + 9)  // chunk not found
    //define MMIOERR_UNBUFFERED     (MMIOERR_BASE + 10) // file is unbuffered

    // MMIO constants
    //define CFSEPCHAR      '+'             // compound file name separator char.

    // MMIO data types
    typedef DWORD           FOURCC;         // a four character code
    typedef char _huge *    HPSTR;          // a huge version of LPTSTR
    DECLARE_HANDLE(HMMIO);                  // a handle to an open file
    typedef LRESULT (CALLBACK MMIOPROC)(LPTSTR lpmmioinfo, UINT uMessage,
                LPARAM lParam1, LPARAM lParam2);
    typedef MMIOPROC *LPMMIOPROC;

    // general MMIO information data structure
    typedef struct _MMIOINFO
    {
            // general fields
            DWORD           dwFlags;        // general status flags
            FOURCC          fccIOProc;      // pointer to I/O procedure
            LPMMIOPROC      pIOProc;        // pointer to I/O procedure
            UINT            wErrorRet;      // place for error to be returned
            HTASK           htask;          // alternate local task

            // fields maintained by MMIO functions during buffered I/O
            LONG            cchBuffer;      // size of I/O buffer (or 0L)
            HPSTR           pchBuffer;      // start of I/O buffer (or NULL)
            HPSTR           pchNext;        // pointer to next byte to read/write
            HPSTR           pchEndRead;     // pointer to last valid byte to read
            HPSTR           pchEndWrite;    // pointer to last byte to write
            LONG            lBufOffset;     // disk offset of start of buffer

            // fields maintained by I/O procedure
            LONG            lDiskOffset;    // disk offset of next read or write
            DWORD           adwInfo[3];     // data specific to type of MMIOPROC

            // other fields maintained by MMIO
            DWORD           dwReserved1;    // reserved for MMIO use
            DWORD           dwReserved2;    // reserved for MMIO use
            HMMIO           hmmio;          // handle to open file
    } MMIOINFO;
    typedef MMIOINFO       *PMMIOINFO;
    typedef MMIOINFO *NPMMIOINFO;
    typedef MMIOINFO  *LPMMIOINFO;

    // RIFF chunk information data structure
    typedef struct _MMCKINFO
    {
            FOURCC          ckid;           // chunk ID
            DWORD           cksize;         // chunk size
            FOURCC          fccType;        // form type or list type
            DWORD           dwDataOffset;   // offset of data portion of chunk
            DWORD           dwFlags;        // flags used by MMIO functions
    } MMCKINFO;
    typedef MMCKINFO       *PMMCKINFO;
    typedef MMCKINFO *NPMMCKINFO;
    typedef MMCKINFO  *LPMMCKINFO;

    // bit field masks
    //define MMIO_RWMODE    0x00000003      // open file for reading/writing/both
    //define MMIO_SHAREMODE 0x00000070      // file sharing mode number

    // constants for dwFlags field of MMIOINFO
    //define MMIO_CREATE    0x00001000      // create new file (or truncate file)
    //define MMIO_PARSE     0x00000100      // parse new file returning path
    //define MMIO_DELETE    0x00000200      // create new file (or truncate file)
    //define MMIO_EXIST     0x00004000      // checks for existence of file
    //define MMIO_ALLOCBUF  0x00010000      // mmioOpen() should allocate a buffer
    //define MMIO_GETTEMP   0x00020000      // mmioOpen() should retrieve temp name

    //define MMIO_DIRTY     0x10000000      // I/O buffer is dirty


    // read/write mode numbers (bit field MMIO_RWMODE)
    //define MMIO_READ      0x00000000      // open file for reading only
    //define MMIO_WRITE     0x00000001      // open file for writing only
    //define MMIO_READWRITE 0x00000002      // open file for reading and writing

    // share mode numbers (bit field MMIO_SHAREMODE)
    //define MMIO_COMPAT    0x00000000      // compatibility mode
    //define MMIO_EXCLUSIVE 0x00000010      // exclusive-access mode
    //define MMIO_DENYWRITE 0x00000020      // deny writing to other processes
    //define MMIO_DENYREAD  0x00000030      // deny reading to other processes
    //define MMIO_DENYNONE  0x00000040      // deny nothing to other processes

    // various MMIO flags
    //define MMIO_FHOPEN            0x0010  // mmioClose: keep file handle open
    //define MMIO_EMPTYBUF          0x0010  // mmioFlush: empty the I/O buffer
    //define MMIO_TOUPPER           0x0010  // mmioStringToFOURCC: to u-case
    //define MMIO_INSTALLPROC   0x00010000  // mmioInstallIOProc: install MMIOProc
    //define MMIO_GLOBALPROC    0x10000000  // mmioInstallIOProc: install globally
    //define MMIO_REMOVEPROC    0x00020000  // mmioInstallIOProc: remove MMIOProc
    //define MMIO_FINDPROC      0x00040000  // mmioInstallIOProc: find an MMIOProc
    //define MMIO_FINDCHUNK         0x0010  // mmioDescend: find a chunk by ID
    //define MMIO_FINDRIFF          0x0020  // mmioDescend: find a LIST chunk
    //define MMIO_FINDLIST          0x0040  // mmioDescend: find a RIFF chunk
    //define MMIO_CREATERIFF        0x0020  // mmioCreateChunk: make a LIST chunk
    //define MMIO_CREATELIST        0x0040  // mmioCreateChunk: make a RIFF chunk


    // message numbers for MMIOPROC I/O procedure functions
    //define MMIOM_READ     MMIO_READ       // read
    //define MMIOM_WRITE    MMIO_WRITE      // write
    //define MMIOM_SEEK             2       // seek to a new position in file
    //define MMIOM_OPEN             3       // open file
    //define MMIOM_CLOSE            4       // close file
    //define MMIOM_WRITEFLUSH       5       // write and flush

    //define MMIOM_RENAME           6       // rename specified file

    //define MMIOM_USER        0x8000       // beginning of user-defined messages

    // standard four character codes
    //define FOURCC_RIFF    mmioFOURCC('R', 'I', 'F', 'F')
    //define FOURCC_LIST    mmioFOURCC('L', 'I', 'S', 'T')

    // four character codes used to identify standard built-in I/O procedures
    //define FOURCC_DOS     mmioFOURCC('D', 'O', 'S', ' ')
    //define FOURCC_MEM     mmioFOURCC('M', 'E', 'M', ' ')

    // flags for mmioSeek()

    // other constants
    //define MMIO_DEFAULTBUFFER     8192    // default buffer size

    // MMIO macros
    //define mmioFOURCC( ch0, ch1, ch2, ch3 )                               
                    ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    
                    ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

    // MMIO function prototypes
    FOURCC WINAPI mmioStringToFOURCC(LPCTSTR sz, UINT uFlags);
    LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
        DWORD dwFlags);
    HMMIO WINAPI mmioOpen(LPTSTR szFileName, MMIOINFO FAR* lpmmioinfo,
        DWORD dwOpenFlags);

    UINT WINAPI mmioRename(LPCTSTR szFileName, LPCTSTR szNewFileName,
         MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);

    UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
    LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
    LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
    LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
    UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPTSTR pchBuffer, LONG cchBuffer,
        UINT uFlags);
    UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
    UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
    LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
        LPARAM lParam1, LPARAM lParam2);
    UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
        const MMCKINFO FAR* lpckParent, UINT uFlags);
    UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
    UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
    */

    // ****** MCI support *******

    // MCI function prototypes

    [
    usesgetlasterror,
	#ifdef UNICODE 
    entry("mciSendCommandW"),
	#else
    entry("mciSendCommandA"),
	#endif
    helpstring("Sends a command message to the specified MCI device"),
    ]
    MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, 
								   UINT uMsg, 
								   DWORD dwParam1, 
								   DWORD dwParam2);

    [
    usesgetlasterror,
	#ifdef UNICODE 
    entry("mciSendStringW"),
	#else
    entry("mciSendStringA"),
	#endif
    helpstring("Sends a command string to an MCI device specified in the string"),
    ]
	MCIERROR  WINAPI mciSendString(LPCTSTR lpstrCommand, 
								   LPTSTR lpstrReturnString, 
								   UINT uReturnLength, 
								   HWND hwndCallback);

    [
    usesgetlasterror,
	#ifdef UNICODE 
    entry("mciGetDeviceIDW"),
	#else
    entry("mciGetDeviceIDA"),
	#endif
    helpstring("Retrieves the device identifier corresponding to the name of an open device"),
    ]
    MCIDEVICEID WINAPI mciGetDeviceID(LPCTSTR pszDevice);

	/*
    [
    usesgetlasterror,
	#ifdef UNICODE 
    entry("mciGetDeviceIDFromElementIDW"),
	#else
    entry("mciGetDeviceIDFromElementIDA"),
	#endif
    helpstring(""),
    ]
    MCIDEVICEID WINAPI mciGetDeviceIDFromElementID(DWORD dwElementID, 
												   LPCTSTR lpstrType );
	*/

    [
    usesgetlasterror,
	#ifdef UNICODE 
    entry("mciGetErrorStringW"),
	#else
    entry("mciGetErrorStringA"),
	#endif
    helpstring("Retrieves a string that describes the specified MCI error code"),
    ]
    BOOL WINAPI mciGetErrorString(MCIERROR mcierr, 
								  LPTSTR pszText, 
								  UINT cchText);

    [
    usesgetlasterror,
    entry("mciSetYieldProc"),
    helpstring("Sets the address of a procedure to be called periodically when an MCI device is waiting for a command to finish because the MCI_WAIT flag was specified"),
    ]
    BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, 
								YIELDPROC fpYieldProc,
								DWORD dwYieldData);

    #define ERR_BASE    256
    // MCI error return values
    const DWORD MCIERR_INVALID_DEVICE_ID        = (ERR_BASE + 1);
    const DWORD MCIERR_UNRECOGNIZED_KEYWORD     = (ERR_BASE + 3);
    const DWORD MCIERR_UNRECOGNIZED_COMMAND     = (ERR_BASE + 5);
    const DWORD MCIERR_HARDWARE                 = (ERR_BASE + 6);
    const DWORD MCIERR_INVALID_DEVICE_NAME      = (ERR_BASE + 7);
    const DWORD MCIERR_OUT_OF_MEMORY            = (ERR_BASE + 8);
    const DWORD MCIERR_DEVICE_OPEN              = (ERR_BASE + 9);
    const DWORD MCIERR_CANNOT_LOAD_DRIVER       = (ERR_BASE + 10);
    const DWORD MCIERR_MISSING_COMMAND_STRING   = (ERR_BASE + 11);
    const DWORD MCIERR_PARAM_OVERFLOW           = (ERR_BASE + 12);
    const DWORD MCIERR_MISSING_STRING_ARGUMENT  = (ERR_BASE + 13);
    const DWORD MCIERR_BAD_INTEGER              = (ERR_BASE + 14);
    const DWORD MCIERR_PARSER_INTERNAL          = (ERR_BASE + 15);
    const DWORD MCIERR_DRIVER_INTERNAL          = (ERR_BASE + 16);
    const DWORD MCIERR_MISSING_PARAMETER        = (ERR_BASE + 17);
    const DWORD MCIERR_UNSUPPORTED_FUNCTION     = (ERR_BASE + 18);
    const DWORD MCIERR_FILE_NOT_FOUND           = (ERR_BASE + 19);
    const DWORD MCIERR_DEVICE_NOT_READY         = (ERR_BASE + 20);
    const DWORD MCIERR_INTERNAL                 = (ERR_BASE + 21);
    const DWORD MCIERR_DRIVER                   = (ERR_BASE + 22);
    const DWORD MCIERR_CANNOT_USE_ALL           = (ERR_BASE + 23);
    const DWORD MCIERR_MULTIPLE                 = (ERR_BASE + 24);
    const DWORD MCIERR_EXTENSION_NOT_FOUND      = (ERR_BASE + 25);
    const DWORD MCIERR_OUTOFRANGE               = (ERR_BASE + 26);
    const DWORD MCIERR_FLAGS_NOT_COMPATIBLE     = (ERR_BASE + 28);
    const DWORD MCIERR_FILE_NOT_SAVED           = (ERR_BASE + 30);
    const DWORD MCIERR_DEVICE_TYPE_REQUIRED     = (ERR_BASE + 31);
    const DWORD MCIERR_DEVICE_LOCKED            = (ERR_BASE + 32);
    const DWORD MCIERR_DUPLICATE_ALIAS          = (ERR_BASE + 33);
    const DWORD MCIERR_BAD_CONSTANT             = (ERR_BASE + 34);
    const DWORD MCIERR_MUST_USE_SHAREABLE       = (ERR_BASE + 35);
    const DWORD MCIERR_MISSING_DEVICE_NAME      = (ERR_BASE + 36);
    const DWORD MCIERR_BAD_TIME_FORMAT          = (ERR_BASE + 37);
    const DWORD MCIERR_NO_CLOSING_QUOTE         = (ERR_BASE + 38);
    const DWORD MCIERR_DUPLICATE_FLAGS          = (ERR_BASE + 39);
    const DWORD MCIERR_INVALID_FILE             = (ERR_BASE + 40);
    const DWORD MCIERR_NULL_PARAMETER_BLOCK     = (ERR_BASE + 41);
    const DWORD MCIERR_UNNAMED_RESOURCE         = (ERR_BASE + 42);
    const DWORD MCIERR_NEW_REQUIRES_ALIAS       = (ERR_BASE + 43);
    const DWORD MCIERR_NOTIFY_ON_AUTO_OPEN      = (ERR_BASE + 44);
    const DWORD MCIERR_NO_ELEMENT_ALLOWED       = (ERR_BASE + 45);
    const DWORD MCIERR_NONAPPLICABLE_FUNCTION   = (ERR_BASE + 46);
    const DWORD MCIERR_ILLEGAL_FOR_AUTO_OPEN    = (ERR_BASE + 47);
    const DWORD MCIERR_FILENAME_REQUIRED        = (ERR_BASE + 48);
    const DWORD MCIERR_EXTRA_CHARACTERS         = (ERR_BASE + 49);
    const DWORD MCIERR_DEVICE_NOT_INSTALLED     = (ERR_BASE + 50);
    const DWORD MCIERR_GET_CD                   = (ERR_BASE + 51);
    const DWORD MCIERR_SET_CD                   = (ERR_BASE + 52);
    const DWORD MCIERR_SET_DRIVE                = (ERR_BASE + 53);
    const DWORD MCIERR_DEVICE_LENGTH            = (ERR_BASE + 54);
    const DWORD MCIERR_DEVICE_ORD_LENGTH        = (ERR_BASE + 55);
    const DWORD MCIERR_NO_INTEGER               = (ERR_BASE + 56);

    const DWORD MCIERR_WAVE_OUTPUTSINUSE        = (ERR_BASE + 64);
    const DWORD MCIERR_WAVE_SETOUTPUTINUSE      = (ERR_BASE + 65);
    const DWORD MCIERR_WAVE_INPUTSINUSE         = (ERR_BASE + 66);
    const DWORD MCIERR_WAVE_SETINPUTINUSE       = (ERR_BASE + 67);
    const DWORD MCIERR_WAVE_OUTPUTUNSPECIFIED   = (ERR_BASE + 68);
    const DWORD MCIERR_WAVE_INPUTUNSPECIFIED    = (ERR_BASE + 69);
    const DWORD MCIERR_WAVE_OUTPUTSUNSUITABLE   = (ERR_BASE + 70);
    const DWORD MCIERR_WAVE_SETOUTPUTUNSUITABLE = (ERR_BASE + 71);
    const DWORD MCIERR_WAVE_INPUTSUNSUITABLE    = (ERR_BASE + 72);
    const DWORD MCIERR_WAVE_SETINPUTUNSUITABLE  = (ERR_BASE + 73);

    const DWORD MCIERR_SEQ_DIV_INCOMPATIBLE     = (ERR_BASE + 80);
    const DWORD MCIERR_SEQ_PORT_INUSE           = (ERR_BASE + 81);
    const DWORD MCIERR_SEQ_PORT_NONEXISTENT     = (ERR_BASE + 82);
    const DWORD MCIERR_SEQ_PORT_MAPNODEVICE     = (ERR_BASE + 83);
    const DWORD MCIERR_SEQ_PORT_MISCERROR       = (ERR_BASE + 84);
    const DWORD MCIERR_SEQ_TIMER                = (ERR_BASE + 85);
    const DWORD MCIERR_SEQ_PORTUNSPECIFIED      = (ERR_BASE + 86);
    const DWORD MCIERR_SEQ_NOMIDIPRESENT        = (ERR_BASE + 87);

    const DWORD MCIERR_NO_WINDOW                = (ERR_BASE + 90);
    const DWORD MCIERR_CREATEWINDOW             = (ERR_BASE + 91);
    const DWORD MCIERR_FILE_READ                = (ERR_BASE + 92);
    const DWORD MCIERR_FILE_WRITE               = (ERR_BASE + 93);

    const DWORD MCIERR_NO_IDENTITY              = (ERR_BASE + 94);

    // all custom device driver errors must be >= than this value
    const DWORD MCIERR_CUSTOM_DRIVER_BASE       = (ERR_BASE + 256);

    const WORD MCI_FIRST                        = 0x0800;
    // MCI command message identifiers
    const WORD MCI_OPEN                        = 0x0803;
    const WORD MCI_CLOSE                       = 0x0804;
    const WORD MCI_ESCAPE                      = 0x0805;
    const WORD MCI_PLAY                        = 0x0806;
    const WORD MCI_SEEK                        = 0x0807;
    const WORD MCI_STOP                        = 0x0808;
    const WORD MCI_PAUSE                       = 0x0809;
    const WORD MCI_INFO                        = 0x080A;
    const WORD MCI_GETDEVCAPS                  = 0x080B;
    const WORD MCI_SPIN                        = 0x080C;
    const WORD MCI_SET                         = 0x080D;
    const WORD MCI_STEP                        = 0x080E;
    const WORD MCI_RECORD                      = 0x080F;
    const WORD MCI_SYSINFO                     = 0x0810;
    const WORD MCI_BREAK                       = 0x0811;
    const WORD MCI_SAVE                        = 0x0813;
    const WORD MCI_STATUS                      = 0x0814;
    const WORD MCI_CUE                         = 0x0830;
    const WORD MCI_REALIZE                     = 0x0840;
    const WORD MCI_WINDOW                      = 0x0841;
    const WORD MCI_PUT                         = 0x0842;
    const WORD MCI_WHERE                       = 0x0843;
    const WORD MCI_FREEZE                      = 0x0844;
    const WORD MCI_UNFREEZE                    = 0x0845;
    const WORD MCI_LOAD                        = 0x0850;
    const WORD MCI_CUT                         = 0x0851;
    const WORD MCI_COPY                        = 0x0852;
    const WORD MCI_PASTE                       = 0x0853;
    const WORD MCI_UPDATE                      = 0x0854;
    const WORD MCI_RESUME                      = 0x0855;
    const WORD MCI_DELETE                      = 0x0856;

    // all custom MCI command messages must be >= than this value
    //const WORD MCI_USER_MESSAGES               (DRV_MCI_FIRST + = 0x400);
    const WORD MCI_LAST                        = 0x0FFF;

    // device ID for "all devices"
    const DWORD MCI_ALL_DEVICE_ID               = -1;

    // constants for predefined MCI device types
    const WORD MCI_DEVTYPE_VCR                 = 513; // (MCI_STRING_OFFSET + 1)
    const WORD MCI_DEVTYPE_VIDEODISC           = 514; // (MCI_STRING_OFFSET + 2)
    const WORD MCI_DEVTYPE_OVERLAY             = 515; // (MCI_STRING_OFFSET + 3)
    const WORD MCI_DEVTYPE_CD_AUDIO            = 516; // (MCI_STRING_OFFSET + 4)
    const WORD MCI_DEVTYPE_DAT                 = 517; // (MCI_STRING_OFFSET + 5)
    const WORD MCI_DEVTYPE_SCANNER             = 518; // (MCI_STRING_OFFSET + 6)
    const WORD MCI_DEVTYPE_ANIMATION           = 519; // (MCI_STRING_OFFSET + 7)
    const WORD MCI_DEVTYPE_DIGITAL_VIDEO       = 520; // (MCI_STRING_OFFSET + 8)
    const WORD MCI_DEVTYPE_OTHER               = 521; // (MCI_STRING_OFFSET + 9)
    const WORD MCI_DEVTYPE_WAVEFORM_AUDIO      = 522; // (MCI_STRING_OFFSET + 10)
    const WORD MCI_DEVTYPE_SEQUENCER           = 523; // (MCI_STRING_OFFSET + 11)

    const WORD MCI_DEVTYPE_FIRST               = 513; // MCI_DEVTYPE_VCR
    const WORD MCI_DEVTYPE_LAST                = 523; // MCI_DEVTYPE_SEQUENCER

    const WORD MCI_DEVTYPE_FIRST_USER          = 0x1000;
    // return values for 'status mode' command
    const WORD MCI_MODE_NOT_READY              = (512 + 12);
    const WORD MCI_MODE_STOP                   = (512 + 13);
    const WORD MCI_MODE_PLAY                   = (512 + 14);
    const WORD MCI_MODE_RECORD                 = (512 + 15);
    const WORD MCI_MODE_SEEK                   = (512 + 16);
    const WORD MCI_MODE_PAUSE                  = (512 + 17);
    const WORD MCI_MODE_OPEN                   = (512 + 18);

    // constants used in 'set time format' and 'status time format' commands
    const WORD MCI_FORMAT_MILLISECONDS         = 0;
    const WORD MCI_FORMAT_HMS                  = 1;
    const WORD MCI_FORMAT_MSF                  = 2;
    const WORD MCI_FORMAT_FRAMES               = 3;
    const WORD MCI_FORMAT_SMPTE_24             = 4;
    const WORD MCI_FORMAT_SMPTE_25             = 5;
    const WORD MCI_FORMAT_SMPTE_30             = 6;
    const WORD MCI_FORMAT_SMPTE_30DROP         = 7;
    const WORD MCI_FORMAT_BYTES                = 8;
    const WORD MCI_FORMAT_SAMPLES              = 9;
    const WORD MCI_FORMAT_TMSF                 = 10;

    // MCI time format conversion macros
    //const DWORD MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
    //const DWORD MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
    //const DWORD MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

    //const DWORD MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | 
    //                          ((WORD)(s)<<8)) | 
    //                         (((DWORD)(BYTE)(f))<<16)))

    //const DWORD MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
    //const DWORD MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
    //const DWORD MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
    //const DWORD MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

    //const DWORD MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | 
    //                          ((WORD)(m)<<8)) | 
    //                         (((DWORD)(BYTE)(s) | 
    //                           ((WORD)(f)<<8))<<16)))

    //const DWORD MCI_HMS_HOUR(hms)               ((BYTE)(hms))
    //const DWORD MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
    //const DWORD MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))
    //
    //const DWORD MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | 
    //                          ((WORD)(m)<<8)) | 
    //                         (((DWORD)(BYTE)(s))<<16)))

    // flags for wParam of MM_MCINOTIFY message
    const WORD MCI_NOTIFY_SUCCESSFUL           = 0x0001;
    const WORD MCI_NOTIFY_SUPERSEDED           = 0x0002;
    const WORD MCI_NOTIFY_ABORTED              = 0x0004;
    const WORD MCI_NOTIFY_FAILURE              = 0x0008;

    // common flags for dwFlags parameter of MCI command messages
    const DWORD MCI_NOTIFY                      = 0x00000001;
    const DWORD MCI_WAIT                        = 0x00000002;
    const DWORD MCI_FROM                        = 0x00000004;
    const DWORD MCI_TO                          = 0x00000008;
    const DWORD MCI_TRACK                       = 0x00000010;

    // flags for dwFlags parameter of MCI_OPEN command message
    const DWORD MCI_OPEN_SHAREABLE              = 0x00000100;
    const DWORD MCI_OPEN_ELEMENT                = 0x00000200;
    const DWORD MCI_OPEN_ALIAS                  = 0x00000400;
    const DWORD MCI_OPEN_ELEMENT_ID             = 0x00000800;
    const DWORD MCI_OPEN_TYPE_ID                = 0x00001000;
    const DWORD MCI_OPEN_TYPE                   = 0x00002000;

    // flags for dwFlags parameter of MCI_SEEK command message
    const DWORD MCI_SEEK_TO_START               = 0x00000100;
    const DWORD MCI_SEEK_TO_END                 = 0x00000200;

    // flags for dwFlags parameter of MCI_STATUS command message
    const DWORD MCI_STATUS_ITEM                 = 0x00000100;
    const DWORD MCI_STATUS_START                = 0x00000200;

    // flags for dwItem field of the MCI_STATUS_PARMS parameter block
    const DWORD MCI_STATUS_LENGTH               = 0x00000001;
    const DWORD MCI_STATUS_POSITION             = 0x00000002;
    const DWORD MCI_STATUS_NUMBER_OF_TRACKS     = 0x00000003;
    const DWORD MCI_STATUS_MODE                 = 0x00000004;
    const DWORD MCI_STATUS_MEDIA_PRESENT        = 0x00000005;
    const DWORD MCI_STATUS_TIME_FORMAT          = 0x00000006;
    const DWORD MCI_STATUS_READY                = 0x00000007;
    const DWORD MCI_STATUS_CURRENT_TRACK        = 0x00000008;

    // flags for dwFlags parameter of MCI_INFO command message
    const DWORD MCI_INFO_PRODUCT                = 0x00000100;
    const DWORD MCI_INFO_FILE                   = 0x00000200;
    const DWORD MCI_INFO_MEDIA_UPC              = 0x00000400;
    const DWORD MCI_INFO_MEDIA_IDENTITY         = 0x00000800;
    const DWORD MCI_INFO_NAME                   = 0x00001000;
    const DWORD MCI_INFO_COPYRIGHT              = 0x00002000;

    // flags for dwFlags parameter of MCI_GETDEVCAPS command message
    const DWORD MCI_GETDEVCAPS_ITEM             = 0x00000100;

    // flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
    const DWORD MCI_GETDEVCAPS_CAN_RECORD       = 0x00000001;
    const DWORD MCI_GETDEVCAPS_HAS_AUDIO        = 0x00000002;
    const DWORD MCI_GETDEVCAPS_HAS_VIDEO        = 0x00000003;
    const DWORD MCI_GETDEVCAPS_DEVICE_TYPE      = 0x00000004;
    const DWORD MCI_GETDEVCAPS_USES_FILES       = 0x00000005;
    const DWORD MCI_GETDEVCAPS_COMPOUND_DEVICE  = 0x00000006;
    const DWORD MCI_GETDEVCAPS_CAN_EJECT        = 0x00000007;
    const DWORD MCI_GETDEVCAPS_CAN_PLAY         = 0x00000008;
    const DWORD MCI_GETDEVCAPS_CAN_SAVE         = 0x00000009;

    // flags for dwFlags parameter of MCI_SYSINFO command message
    const DWORD MCI_SYSINFO_QUANTITY            = 0x00000100;
    const DWORD MCI_SYSINFO_OPEN                = 0x00000200;
    const DWORD MCI_SYSINFO_NAME                = 0x00000400;
    const DWORD MCI_SYSINFO_INSTALLNAME         = 0x00000800;

    // flags for dwFlags parameter of MCI_SET command message
    const DWORD MCI_SET_DOOR_OPEN               = 0x00000100;
    const DWORD MCI_SET_DOOR_CLOSED             = 0x00000200;
    const DWORD MCI_SET_TIME_FORMAT             = 0x00000400;
    const DWORD MCI_SET_AUDIO                   = 0x00000800;
    const DWORD MCI_SET_VIDEO                   = 0x00001000;
    const DWORD MCI_SET_ON                      = 0x00002000;
    const DWORD MCI_SET_OFF                     = 0x00004000;

    // flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
    const DWORD MCI_SET_AUDIO_ALL               = 0x00000000;
    const DWORD MCI_SET_AUDIO_LEFT              = 0x00000001;
    const DWORD MCI_SET_AUDIO_RIGHT             = 0x00000002;

    // flags for dwFlags parameter of MCI_BREAK command message
    const DWORD MCI_BREAK_KEY                   = 0x00000100;
    const DWORD MCI_BREAK_HWND                  = 0x00000200;
    const DWORD MCI_BREAK_OFF                   = 0x00000400;

    // flags for dwFlags parameter of MCI_RECORD command message
    const DWORD MCI_RECORD_INSERT               = 0x00000100;
    const DWORD MCI_RECORD_OVERWRITE            = 0x00000200;

    // flags for dwFlags parameter of MCI_SAVE command message
    const DWORD MCI_SAVE_FILE                   = 0x00000100;

    // flags for dwFlags parameter of MCI_LOAD command message
    const DWORD MCI_LOAD_FILE                   = 0x00000100;

    // MCI extensions for videodisc devices

    // flag for dwReturn field of MCI_STATUS_PARMS
    // MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
    const WORD MCI_VD_MODE_PARK                = (1024 + 1);

    // flag for dwReturn field of MCI_STATUS_PARMS
    // MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
    const WORD MCI_VD_MEDIA_CLV                = (1024 + 2);
    const WORD MCI_VD_MEDIA_CAV                = (1024 + 3);
    const WORD MCI_VD_MEDIA_OTHER              = (1024 + 4);

    const WORD MCI_VD_FORMAT_TRACK             = 0x4001;

    // flags for dwFlags parameter of MCI_PLAY command message
    const DWORD MCI_VD_PLAY_REVERSE             = 0x00010000;
    const DWORD MCI_VD_PLAY_FAST                = 0x00020000;
    const DWORD MCI_VD_PLAY_SPEED               = 0x00040000;
    const DWORD MCI_VD_PLAY_SCAN                = 0x00080000;
    const DWORD MCI_VD_PLAY_SLOW                = 0x00100000;

    // flag for dwFlags parameter of MCI_SEEK command message
    const DWORD MCI_VD_SEEK_REVERSE             = 0x00010000;

    // flags for dwItem field of MCI_STATUS_PARMS parameter block
    const DWORD MCI_VD_STATUS_SPEED             = 0x00004002;
    const DWORD MCI_VD_STATUS_FORWARD           = 0x00004003;
    const DWORD MCI_VD_STATUS_MEDIA_TYPE        = 0x00004004;
    const DWORD MCI_VD_STATUS_SIDE              = 0x00004005;
    const DWORD MCI_VD_STATUS_DISC_SIZE         = 0x00004006;

    // flags for dwFlags parameter of MCI_GETDEVCAPS command message
    const DWORD MCI_VD_GETDEVCAPS_CLV           = 0x00010000;
    const DWORD MCI_VD_GETDEVCAPS_CAV           = 0x00020000;

    const DWORD MCI_VD_SPIN_UP                  = 0x00010000;
    const DWORD MCI_VD_SPIN_DOWN                = 0x00020000;

    // flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
    const DWORD MCI_VD_GETDEVCAPS_CAN_REVERSE   = 0x00004002;
    const DWORD MCI_VD_GETDEVCAPS_FAST_RATE     = 0x00004003;
    const DWORD MCI_VD_GETDEVCAPS_SLOW_RATE     = 0x00004004;
    const DWORD MCI_VD_GETDEVCAPS_NORMAL_RATE   = 0x00004005;

    // flags for the dwFlags parameter of MCI_STEP command message
    const DWORD MCI_VD_STEP_FRAMES              = 0x00010000;
    const DWORD MCI_VD_STEP_REVERSE             = 0x00020000;

    // flag for the MCI_ESCAPE command message
    const DWORD MCI_VD_ESCAPE_STRING            = 0x00000100;

    // MCI extensions for CD audio devices

    // flags for the dwItem field of the MCI_STATUS_PARMS parameter block
    const DWORD MCI_CDA_STATUS_TYPE_TRACK       = 0x00004001;

    // flags for the dwReturn field of MCI_STATUS_PARMS parameter block
    // MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK)
    const WORD MCI_CDA_TRACK_AUDIO             = (1088 + 0);
    const WORD MCI_CDA_TRACK_OTHER             = (1088 + 1);

    // MCI extensions for waveform audio devices

    const DWORD MCI_WAVE_PCM                    = (1152 + 0);
    const DWORD MCI_WAVE_MAPPER                 = (1152 + 1);

    // flags for the dwFlags parameter of MCI_OPEN command message
    const DWORD MCI_WAVE_OPEN_BUFFER            = 0x00010000;

    // flags for the dwFlags parameter of MCI_SET command message
    const DWORD MCI_WAVE_SET_FORMATTAG          = 0x00010000;
    const DWORD MCI_WAVE_SET_CHANNELS           = 0x00020000;
    const DWORD MCI_WAVE_SET_SAMPLESPERSEC      = 0x00040000;
    const DWORD MCI_WAVE_SET_AVGBYTESPERSEC     = 0x00080000;
    const DWORD MCI_WAVE_SET_BLOCKALIGN         = 0x00100000;
    const DWORD MCI_WAVE_SET_BITSPERSAMPLE      = 0x00200000;

    // flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
    const DWORD MCI_WAVE_INPUT                  = 0x00400000;
    const DWORD MCI_WAVE_OUTPUT                 = 0x00800000;

    // flags for the dwItem field of MCI_STATUS_PARMS parameter block
    const DWORD MCI_WAVE_STATUS_FORMATTAG       = 0x00004001;
    const DWORD MCI_WAVE_STATUS_CHANNELS        = 0x00004002;
    const DWORD MCI_WAVE_STATUS_SAMPLESPERSEC   = 0x00004003;
    const DWORD MCI_WAVE_STATUS_AVGBYTESPERSEC  = 0x00004004;
    const DWORD MCI_WAVE_STATUS_BLOCKALIGN      = 0x00004005;
    const DWORD MCI_WAVE_STATUS_BITSPERSAMPLE   = 0x00004006;
    const DWORD MCI_WAVE_STATUS_LEVEL           = 0x00004007;

    // flags for the dwFlags parameter of MCI_SET command message
    const DWORD MCI_WAVE_SET_ANYINPUT           = 0x04000000;
    const DWORD MCI_WAVE_SET_ANYOUTPUT          = 0x08000000;

    // flags for the dwFlags parameter of MCI_GETDEVCAPS command message
    const DWORD MCI_WAVE_GETDEVCAPS_INPUTS      = 0x00004001;
    const DWORD MCI_WAVE_GETDEVCAPS_OUTPUTS     = 0x00004002;

    // MCI extensions for MIDI sequencer devices

    // flags for the dwReturn field of MCI_STATUS_PARMS parameter block
    // MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
    //const DWORD     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
    //const DWORD     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
    //const DWORD     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
    //const DWORD     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
    //const DWORD     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

    // flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
    // MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
    const DWORD     MCI_SEQ_FORMAT_SONGPTR      = 0x4001;
    const DWORD     MCI_SEQ_FILE                = 0x4002;
    const DWORD     MCI_SEQ_MIDI                = 0x4003;
    const DWORD     MCI_SEQ_SMPTE               = 0x4004;
    const DWORD     MCI_SEQ_NONE                = 65533;
    const DWORD     MCI_SEQ_MAPPER              = 65535;

    // flags for the dwItem field of MCI_STATUS_PARMS parameter block
    const DWORD MCI_SEQ_STATUS_TEMPO            = 0x00004002;
    const DWORD MCI_SEQ_STATUS_PORT             = 0x00004003;
    const DWORD MCI_SEQ_STATUS_SLAVE            = 0x00004007;
    const DWORD MCI_SEQ_STATUS_MASTER           = 0x00004008;
    const DWORD MCI_SEQ_STATUS_OFFSET           = 0x00004009;
    const DWORD MCI_SEQ_STATUS_DIVTYPE          = 0x0000400A;
    const DWORD MCI_SEQ_STATUS_NAME             = 0x0000400B;
    const DWORD MCI_SEQ_STATUS_COPYRIGHT        = 0x0000400C;

    // flags for the dwFlags parameter of MCI_SET command message
    const DWORD MCI_SEQ_SET_TEMPO               = 0x00010000;
    const DWORD MCI_SEQ_SET_PORT                = 0x00020000;
    const DWORD MCI_SEQ_SET_SLAVE               = 0x00040000;
    const DWORD MCI_SEQ_SET_MASTER              = 0x00080000;
    const DWORD MCI_SEQ_SET_OFFSET              = 0x01000000;

    // MCI extensions for animation devices

    // flags for dwFlags parameter of MCI_OPEN command message
    const DWORD MCI_ANIM_OPEN_WS                = 0x00010000;
    const DWORD MCI_ANIM_OPEN_PARENT            = 0x00020000;
    const DWORD MCI_ANIM_OPEN_NOSTATIC          = 0x00040000;

    // flags for dwFlags parameter of MCI_PLAY command message
    const DWORD MCI_ANIM_PLAY_SPEED             = 0x00010000;
    const DWORD MCI_ANIM_PLAY_REVERSE           = 0x00020000;
    const DWORD MCI_ANIM_PLAY_FAST              = 0x00040000;
    const DWORD MCI_ANIM_PLAY_SLOW              = 0x00080000;
    const DWORD MCI_ANIM_PLAY_SCAN              = 0x00100000;

    // flags for dwFlags parameter of MCI_STEP command message
    const DWORD MCI_ANIM_STEP_REVERSE           = 0x00010000;
    const DWORD MCI_ANIM_STEP_FRAMES            = 0x00020000;

    // flags for dwItem field of MCI_STATUS_PARMS parameter block
    const DWORD MCI_ANIM_STATUS_SPEED           = 0x00004001;
    const DWORD MCI_ANIM_STATUS_FORWARD         = 0x00004002;
    const DWORD MCI_ANIM_STATUS_HWND            = 0x00004003;
    const DWORD MCI_ANIM_STATUS_HPAL            = 0x00004004;
    const DWORD MCI_ANIM_STATUS_STRETCH         = 0x00004005;

    // flags for the dwFlags parameter of MCI_INFO command message
    const DWORD MCI_ANIM_INFO_TEXT              = 0x00010000;

    // flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
    const DWORD MCI_ANIM_GETDEVCAPS_CAN_REVERSE = 0x00004001;
    const DWORD MCI_ANIM_GETDEVCAPS_FAST_RATE   = 0x00004002;
    const DWORD MCI_ANIM_GETDEVCAPS_SLOW_RATE   = 0x00004003;
    const DWORD MCI_ANIM_GETDEVCAPS_NORMAL_RATE = 0x00004004;
    const DWORD MCI_ANIM_GETDEVCAPS_PALETTES    = 0x00004006;
    const DWORD MCI_ANIM_GETDEVCAPS_CAN_STRETCH = 0x00004007;
    const DWORD MCI_ANIM_GETDEVCAPS_MAX_WINDOWS = 0x00004008;

    // flags for the MCI_REALIZE command message
    const DWORD MCI_ANIM_REALIZE_NORM           = 0x00010000;
    const DWORD MCI_ANIM_REALIZE_BKGD           = 0x00020000;

    // flags for dwFlags parameter of MCI_WINDOW command message
    const DWORD MCI_ANIM_WINDOW_HWND            = 0x00010000;
    const DWORD MCI_ANIM_WINDOW_STATE           = 0x00040000;
    const DWORD MCI_ANIM_WINDOW_TEXT            = 0x00080000;
    const DWORD MCI_ANIM_WINDOW_ENABLE_STRETCH  = 0x00100000;
    const DWORD MCI_ANIM_WINDOW_DISABLE_STRETCH = 0x00200000;

    // flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
    // MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
    const DWORD MCI_ANIM_WINDOW_DEFAULT         = 0x00000000;

    // flags for dwFlags parameter of MCI_PUT command message
    const DWORD MCI_ANIM_RECT                   = 0x00010000;
    const DWORD MCI_ANIM_PUT_SOURCE             = 0x00020000;
    const DWORD MCI_ANIM_PUT_DESTINATION        = 0x00040000;

    // flags for dwFlags parameter of MCI_WHERE command message
    const DWORD MCI_ANIM_WHERE_SOURCE           = 0x00020000;
    const DWORD MCI_ANIM_WHERE_DESTINATION      = 0x00040000;

    // flags for dwFlags parameter of MCI_UPDATE command message
    const DWORD MCI_ANIM_UPDATE_HDC             = 0x00020000;

    // MCI extensions for video overlay devices

    // flags for dwFlags parameter of MCI_OPEN command message
    const DWORD MCI_OVLY_OPEN_WS                = 0x00010000;
    const DWORD MCI_OVLY_OPEN_PARENT            = 0x00020000;

    // flags for dwFlags parameter of MCI_STATUS command message
    const DWORD MCI_OVLY_STATUS_HWND            = 0x00004001;
    const DWORD MCI_OVLY_STATUS_STRETCH         = 0x00004002;

    // flags for dwFlags parameter of MCI_INFO command message
    const DWORD MCI_OVLY_INFO_TEXT              = 0x00010000;

    // flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
    const DWORD MCI_OVLY_GETDEVCAPS_CAN_STRETCH = 0x00004001;
    const DWORD MCI_OVLY_GETDEVCAPS_CAN_FREEZE  = 0x00004002;
    const DWORD MCI_OVLY_GETDEVCAPS_MAX_WINDOWS = 0x00004003;

    // flags for dwFlags parameter of MCI_WINDOW command message
    const DWORD MCI_OVLY_WINDOW_HWND            = 0x00010000;
    const DWORD MCI_OVLY_WINDOW_STATE           = 0x00040000;
    const DWORD MCI_OVLY_WINDOW_TEXT            = 0x00080000;
    const DWORD MCI_OVLY_WINDOW_ENABLE_STRETCH  = 0x00100000;
    const DWORD MCI_OVLY_WINDOW_DISABLE_STRETCH = 0x00200000;

    // flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
    const DWORD MCI_OVLY_WINDOW_DEFAULT         = 0x00000000;

    // flags for dwFlags parameter of MCI_PUT command message
    const DWORD MCI_OVLY_RECT                   = 0x00010000;
    const DWORD MCI_OVLY_PUT_SOURCE             = 0x00020000;
    const DWORD MCI_OVLY_PUT_DESTINATION        = 0x00040000;
    const DWORD MCI_OVLY_PUT_FRAME              = 0x00080000;
    const DWORD MCI_OVLY_PUT_VIDEO              = 0x00100000;

    // flags for dwFlags parameter of MCI_WHERE command message
    const DWORD MCI_OVLY_WHERE_SOURCE           = 0x00020000;
    const DWORD MCI_OVLY_WHERE_DESTINATION      = 0x00040000;
    const DWORD MCI_OVLY_WHERE_FRAME            = 0x00080000;
    const DWORD MCI_OVLY_WHERE_VIDEO            = 0x00100000;

    // ****** DISPLAY Driver extensions ******

    /*
        //define QUERYROPSUPPORT 40         // use to determine ROP support


    // ****** DIB Driver extensions ********

    //define SELECTDIB      41                      // DIB.DRV select dib escape
    //define DIBINDEX(n)    MAKELONG((n),= 0x10FF)


    // ****** ScreenSaver support *******

    // The current application will receive a syscommand of SC_SCREENSAVE just
    // before the screen saver is invoked.  If the app wishes to prevent a
    // screen save, return non-zero value, otherwise call DefWindowProc().

        //define SC_SCREENSAVE  = 0xF140
    */
}
