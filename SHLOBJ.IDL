//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1996
//
// File: shlobj.h
//
//===========================================================================

#ifndef _PRSHT_H_
//#include "prsht.idl"
#endif

#ifndef INITGUID
//#include "shlguid.h"
#endif // !INITGUID

//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================

//
// SHITEMID -- Item ID
//
typedef struct SHITEMID        // mkid
{
    USHORT      cb;             // Size of the ID (including cb itself)
    BYTE        abID[1];        // The item ID (variable length)
} SHITEMID;
typedef UNALIGNED SHITEMID *LPSHITEMID;
typedef const UNALIGNED SHITEMID *LPCSHITEMID;
//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
typedef struct ITEMIDLIST      // idl
{
    SHITEMID    mkid;
} ITEMIDLIST;

// typedef UNALIGNED ITEMIDLIST * LPITEMIDLIST;
// typedef const UNALIGNED ITEMIDLIST * LPCITEMIDLIST;
typedef LONG LPITEMIDLIST;
typedef LONG LPCITEMIDLIST;

//===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// define SHGetMalloc(ppmem)   CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================

//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

typedef struct CMINVOKECOMMANDINFO {
    DWORD cbSize;        // sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    PTR  /* LPCSTR */ lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    PTR  /* LPCSTR */ lpParameters; // might be NULL (indicating no parameter)
    PTR  /* LPCSTR */ lpDirectory;  // might be NULL (indicating no specific directory)
    ESW   nShow;           // one of SW_ values for ShowWindow() API
    DWORD dwHotKey;
    HICON hIcon;
} CMINVOKECOMMANDINFO,  *LPCMINVOKECOMMANDINFO;

typedef struct CMINVOKECOMMANDINFOEX {
    DWORD cbSize;        // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    PTR /* LPCSTR */ lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    PTR /* LPCSTR */ lpParameters; // might be NULL (indicating no parameter)
    PTR /* LPCSTR */ lpDirectory;  // might be NULL (indicating no specific directory)
    ESW nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    HICON hIcon;
    PTR /* LPCSTR */ lpTitle;      // For CreateProcess-StartupInfo.lpTitle
    PTR /* LPCWSTR */ lpVerbW;        // Unicode verb (for those who can use it)
    PTR /* LPCWSTR */ lpParametersW;  // Unicode parameters (for those who can use it)
    PTR /* LPCWSTR */ lpDirectoryW;   // Unicode directory (for those who can use it)
    PTR /* LPCWSTR */ lpTitleW;       // Unicode title (for those who can use it)
} CMINVOKECOMMANDINFOEX,  *LPCMINVOKECOMMANDINFOEX;

[   uuid(000214E4-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IContextMenu interface")
]
interface IVBContextMenu : IUnknown {

    HRESULT QueryContextMenu(HMENU hmenu,
                             long indexMenu,
                             long idCmdFirst,
                             long idCmdLast,
                             long uFlags);

    HRESULT InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    HRESULT GetCommandString(long        idCmd,
                             UINT        uType,
                             UINT      * pwReserved,
                             LPSTR       pszName,
                             UINT        cchMax);
};
typedef IVBContextMenu *  LPCONTEXTMENU;

//
// IContextMenu2 (IContextMenu with one new member)
//
// IContextMenu2::HandleMenuMsg
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu2 interface and receives one of following messages while
// it is calling TrackPopupMenu (in the window proc of hwndOwner):
//      WM_INITPOPUP, WM_DRAWITEM and WM_MEASUREITEM
//  The callee may handle these messages to draw owner draw menuitems.
//

[   uuid(000214F4-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IContextMenu2 interface")
]
interface IVBContextMenu2 : IUnknown {
    HRESULT QueryContextMenu(HMENU hmenu,
                             UINT indexMenu,
                             UINT idCmdFirst,
                             UINT idCmdLast,
                             UINT uFlags);

    HRESULT InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    HRESULT GetCommandString(UINT        idCmd,
                             UINT        uType,
                             UINT      * pwReserved,
                             LPSTR       pszName,
                             UINT        cchMax);

    HRESULT HandleMenuMsg(UINT uMsg,
                          WPARAM wParam,
                          LPARAM lParam);
};
typedef IVBContextMenu2 * LPCONTEXTMENU2;

//===========================================================================
//
// Interface: IShellExtInit
//
//  The IShellExtInit interface is used by the explorer to initialize shell
// extension objects. The explorer (1) calls CoCreateInstance (or equivalent)
// with the registered CLSID and IID_IShellExtInit, (2) calls its Initialize
// member, then (3) calls its QueryInterface to a particular interface (such
// as IContextMenu or IPropSheetExt and (4) performs the rest of operation.
//
//
// [Member functions]
//
// IShellExtInit::Initialize
//
//  This member function is called when the explorer is initializing either
// context menu extension, property sheet extension or non-default drag-drop
// extension.
//
//  Parameters: (context menu or property sheet extension)
//   pidlFolder -- Specifies the parent folder
//   lpdobj -- Spefifies the set of items selected in that folder.
//   hkeyProgID -- Specifies the type of the focused item in the selection.
//
//  Parameters: (non-default drag-and-drop extension)
//   pidlFolder -- Specifies the target (destination) folder
//   lpdobj -- Specifies the items that are dropped (see the description
//    about shell's clipboard below for clipboard formats).
//   hkeyProgID -- Specifies the folder type.
//
//===========================================================================

/*
[   uuid(000214E8-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IShellExtInit interface")
]
interface IVBShellExtInit : IUnknown {
    // *** IShellExtInit methods ***
    HRESULT Initialize(LPCITEMIDLIST pidlFolder,
                       LPDATAOBJECT lpdobj, HKEY hkeyProgID);
};
typedef IVBShellExtInit * LPSHELLEXTINIT;
*/

//===========================================================================
//
// Interface: IShellPropSheetExt
//
//  The explorer uses the IShellPropSheetExt to allow property sheet
// extensions or control panel extensions to add additional property
// sheet pages.
//
//
// [Member functions]
//
// IShellPropSheetExt::AddPages
//
//  The explorer calls this member function when it finds a registered
// property sheet extension for a particular type of object. For each
// additional page, the extension creates a page object by calling
// CreatePropertySheetPage API and calls lpfnAddPage.
//
//  Parameters:
//   lpfnAddPage -- Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//
// IShellPropSheetExt::ReplacePage
//
//  The explorer never calls this member of property sheet extensions. The
// explorer calls this member of control panel extensions, so that they
// can replace some of default control panel pages (such as a page of
// mouse control panel).
//
//  Parameters:
//   uPageID -- Specifies the page to be replaced.
//   lpfnReplace Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//===========================================================================

/*
[   uuid(000214E9-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IShellPropSheetExt interface")
]
interface IVBShellPropSheetExt : IUnknown {
    // *** IShellPropSheetExt methods ***
    HRESULT AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    HRESULT ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);
};
typedef IShellPropSheetExt * LPSHELLPROPSHEETEXT;
*/

//===========================================================================
//
// IPersistFolder Interface
//
//  The IPersistFolder interface is used by the file system implementation of
// IShellFolder::BindToObject when it is initializing a shell folder object.
//
//
// [Member functions]
//
// IPersistFolder::Initialize
//
//  This member function is called when the explorer is initializing a
// shell folder object.
//
//  Parameters:
//   pidl -- Specifies the absolute location of the folder.
//
//===========================================================================

/*
[   uuid(000214EA-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IPersistFolder interface")
]
interface IVBPersistFolder : IPersist {
    // *** IPersist methods ***
    HRESULT GetClassID(LPCLSID lpClassID);

    // *** IPersistFolder methods ***
    HRESULT Initialize(LPCITEMIDLIST pidl);
};
typedef IVBPersistFolder *LPPERSISTFOLDER;
*/

//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

[
    odl,
    helpstring("Visual Basic version of IExtractIcon interface"),
#ifdef UNICODE
    uuid(000214FA-0000-0000-C000-000000000046),
#else
    uuid(000214EB-0000-0000-C000-000000000046),
#endif
]
interface IVBExtractIcon : IUnknown {
    // *** IExtractIcon methods ***
    HRESULT GetIconLocation(UINT   uFlags,
                            LPTSTR  szIconFile,
                            UINT   cchMax,
                            int   * piIndex,
                            UINT  * pwFlags);

    HRESULT Extract(LPCTSTR pszFile,
                    UINT   nIconIndex,
                    HICON   *phiconLarge,
                    HICON   *phiconSmall,
                    UINT    nIconSize);
};
typedef IVBExtractIcon * LPEXTRACTICON;

//===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================

[   uuid(000214E5-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IShellIcon interface")
]
interface IVBShellIcon : IUnknown {
    // *** IShellIcon methods ***
    HRESULT GetIconOf(LPCITEMIDLIST pidl,
                      UINT flags,
                      INT * lpIconIndex);
};
typedef IVBShellIcon *LPSHELLICON;

//===========================================================================
//
// IShellLink Interface
//
//===========================================================================

// IShellLink::Resolve fFlags
typedef enum ESLR {
    SLR_NO_UI           = 0x0001,
    SLR_ANY_MATCH       = 0x0002,
    SLR_UPDATE          = 0x0004,
} ESLR;

// IShellLink::GetPath fFlags
typedef enum ESLGP {
    SLGP_SHORTPATH      = 0x0001,
    SLGP_UNCPRIORITY    = 0x0002,
} ESLGP;

[   odl,
    helpstring("Visual Basic version of IShellLink interface"),
#ifdef UNICODE
    uuid(000214F9-0000-0000-C000-000000000046)
#else
    uuid(000214EE-0000-0000-C000-000000000046)
#endif
]
interface IVBShellLink : IUnknown {

    [ helpstring("Retrieves the path and filename of a shell link object") ]
    HRESULT GetPath([in, out] LPTSTR pszFile,
                    [in] int cchMaxPath,
                    [in, out] LPVOID pfd,
                    [in] ESLGP fFlags);

    [ helpstring("Retrieves the list of shell link item identifiers") ]
    HRESULT GetIDList([out, retval] LPITEMIDLIST * ppidl);
    [ helpstring("Sets the list of shell link item identifiers") ]
    HRESULT SetIDList([in] LPCITEMIDLIST pidl);

    [ helpstring("Retrieves the shell link description string") ]
    HRESULT GetDescription([in, out] LPTSTR pszName,
                           [in] int cchMaxName);
    [ helpstring("Sets the shell link description string") ]
    HRESULT SetDescription([in] LPCTSTR pszName);

    [ helpstring("Retrieves the name of the shell link working directory") ]
    HRESULT GetWorkingDirectory([in, out] LPTSTR pszDir,
                                [in] int cchMaxPath);
    [ helpstring("Sets the name of the shell link working directory") ]
    HRESULT SetWorkingDirectory([in] LPCTSTR pszDir);

    [ helpstring("Retrieves the shell link command-line arguments") ]
    HRESULT GetArguments(LPTSTR pszArgs, int cchMaxPath);
    [ helpstring("Sets the shell link command-line arguments") ]
    HRESULT SetArguments([in] LPCTSTR pszArgs);

    [ propget, helpstring("Retrieves or sets the shell link hot key") ]
    HRESULT Hotkey([out, retval] WORD *pwHotkey);
    [ propput ]
    HRESULT Hotkey([in] WORD wHotkey);

    [ propget,
      helpstring("Retrieves or sets the shell link show command") ]
    HRESULT ShowCmd([out, retval] ESW *piShowCmd);
    [ propput ]
    HRESULT ShowCmd([in] ESW iShowCmd);

    [ helpstring("Retrieves the location (path and index) of the shell link icon") ]
    HRESULT GetIconLocation([in, out] LPTSTR pszIconPath,
                            [in] int cchIconPath,
                            [in, out] int *piIcon);
    [ helpstring("Sets the location (path and index) of the shell link icon") ]
    HRESULT SetIconLocation([in] LPCTSTR pszIconPath,
                            [in] int iIcon);

    [ helpstring("Sets the shell link relative path") ]
    HRESULT SetRelativePath([in] LPCTSTR pszPathRel,
                            [in] DWORD dwReserved);

    [ helpstring("Resolves a shell link. The system searches for the shell link object and updates the shell link path and its list of identifiers (if necessary)") ]
    HRESULT Resolve([in] HWND hwnd,
                    [in] ESLR fFlags);

    [ helpstring("Sets the shell link path and filename") ]
    HRESULT SetPath([in] LPCTSTR pszFile);
};

[   uuid(00021401-0000-0000-C000-000000000046),
    helpstring("Visual Basic CShellLink class")
]
coclass CShellLink {
    [default]
    interface IVBShellLink;
};

//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

/*
[   odl,
    helpstring("Visual Basic version of IShellExecuteHook interface"),
#ifdef UNICODE
    uuid(000214FB-0000-0000-C000-000000000046)
#else
    uuid(000214EF-0000-0000-C000-000000000046)
#endif
]
interface IVBShellExecuteHook : IUnknown {
    // *** IShellExecuteHook methods ***
    HRESULT Execute(LPSHELLEXECUTEINFO pei);
};
*/

//===========================================================================
//
// VB version of INewShortcutHook Interface
//
//===========================================================================

[   odl,
    helpstring("Visual Basic version of INewShortcutHookA interface"),
#ifdef UNICODE
    uuid(000214F7-0000-0000-C000-000000000046)
]
interface IVBNewShortcutHook : IUnknown {
#else
    uuid(000214E1-0000-0000-C000-000000000046)
]
interface IVBNewShortcutHook : IUnknown {
#endif
    // *** INewShortcutHook methods ***
    HRESULT SetReferent(LPCTSTR pcszReferent, HWND hwnd);
    HRESULT GetReferent(LPTSTR pszReferent, int cchReferent);
    HRESULT SetFolder(LPCTSTR pcszFolder);
    HRESULT GetFolder(LPTSTR pszFolder, int cchFolder);
    HRESULT GetName(LPTSTR pszName, int cchName);
    HRESULT GetExtension(LPTSTR pszExtension, int cchExtension);
};

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

/*
[   odl,
    helpstring("Visual Basic version of ICopyHook interface"),
#ifdef UNICODE
    uuid(-0000-0000-C000-000000000046), uuid(-0000-0000-C000-000000000046)
#else
    uuid(-0000-0000-C000-000000000046), uuid(-0000-0000-C000-000000000046)
#endif
]
interface IVBCopyHook : IUnknown {
    UINT CopyCallback(HWND hwnd, UINT wFunc, UINT wFlags,
                      LPCTSTR pszSrcFile, DWORD dwSrcAttribs,
                      LPCTSTR pszDestFile, DWORD dwDestAttribs);
};
typedef IVBCopyHook *    LPCOPYHOOK;
#endif
*/

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

[   uuid(000214F3-0000-0000-C000-000000000046),
    odl,
    helpstring("Visual Basic version of IFileViewerSite interface")
]
interface IVBFileViewerSite {
    HRESULT SetPinnedWindow(HWND hwnd);
    HRESULT GetPinnedWindow(HWND *phwnd);
};
typedef IVBFileViewerSite * LPFILEVIEWERSITE;

//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

typedef struct FVSHOWINFO
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    ESW iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    LPUNKNOWN punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[260 /*MAX_PATH*/];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

[   odl,
    helpstring("Visual Basic version of IFileViewer interface"),
#ifdef UNICODE
    uuid(000214F8-0000-0000-C000-000000000046)
#else
    uuid(000214F0-0000-0000-C000-000000000046)
#endif
]
interface IVBFileViewer {
    HRESULT ShowInitialize(LPFILEVIEWERSITE lpfsi);
    HRESULT Show(LPFVSHOWINFO pvsi);
    HRESULT PrintTo(LPSTR pszDriver, BOOL fSuppressUI);
};
typedef IVBFileViewer * LPFILEVIEWER;

// CommandTarget ids. for shell doc view wedge
enum {
    SHDVID_SETPROGRESSPOS,
    SHDVID_SETPROGRESSRANGE,
    SHDVID_SETSTATUSTEXT,    // variantIn  bstr

    SHDVID_REFRESH,
    SHDVID_STOP,
    SHDVID_UPDATECOMMANDS, /// this forces a re-querystatus of the command targets.
                           /// the arg in can specify a specific one to update or NULL for evrything
    SHDVID_SETTITLE,            // variantIn bstr
    SHDVID_FINALTITLEAVAIL,     // variantIn bstr - sent after final SETTITLE is sent
    SHDVID_STARTLOAD,           // NULL for everything
    SHDVID_STOPLOAD             // NULL for everything
#if MSOCT2
    ,SHDVID_CCALLBACK,          // callback to arbitrary C func
    SHDVID_MENUEXEC,            // do menu command
    SHDVID_MENUQS               // query menu commands
#endif
};



//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================



//--------------------------------------------------------------------------
//
// FOLDERSETTINGS
//
//  FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view "inherit" it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.
//
//--------------------------------------------------------------------------

typedef BYTE * LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies FWF_TRANSPARENT/NOCLIENTEDGE/NOSCROLL
typedef enum
    {
    FWF_AUTOARRANGE =       0x0001,
    FWF_ABBREVIATEDNAMES =  0x0002,
    FWF_SNAPTOGRID =        0x0004,
    FWF_OWNERDATA =         0x0008,
    FWF_BESTFITWINDOW =     0x0010,
    FWF_DESKTOP =           0x0020,
    FWF_SINGLESEL =         0x0040,
    FWF_NOSUBFOLDERS =      0x0080,
    FWF_TRANSPARENT  =      0x0100,
    FWF_NOCLIENTEDGE =      0x0200,
    FWF_NOSCROLL     =      0x0400,
    FWF_ALIGNLEFT    =      0x0800,
    FWF_SINGLECLICKACTIVATE=0x8000  // TEMPORARY -- NO UI FOR THIS
    } FOLDERFLAGS;

typedef enum
    {
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    } FOLDERVIEWMODE;

typedef struct
    {
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)
    UINT fFlags;         // View options (FOLDERFLAGS bits)
    } FOLDERSETTINGS, *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;


//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the "contents pane" of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the "contents pane"
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  "File" and "Edit" pulldown in the File menu group, "View" and "Tools"
//  in the Container menu group and "Help" in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP.
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(lpszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)
//
//   The view calls this member to let shell explorer browse to another
//  folder. The pidl and wFlags specifies the folder to be browsed.
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These   .
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   .
//  browser || explorer)).                                                  .
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the LPSTREAM variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. "lpButtons" and "nButtons" specifies the array of toolbar
//  items. "uFlags" must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

/*
[   odl,
    helpstring("Visual Basic version of IShellBrowser interface"),
    uuid(000214E2-0000-0000-C000-000000000046)
]
interface IVBShellBrowser : IOleWindow {
    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    HRESULT InsertMenusSB(HMENU hmenuShared,
                          LPOLEMENUGROUPWIDTHS lpMenuWidths);
    HRESULT SetMenuSB(HMENU hmenuShared, HOLEMENU holemenuReserved,
                HWND hwndActiveObject);
    HRESULT RemoveMenusSB(HMENU hmenuShared);
    HRESULT SetStatusTextSB(LPCOLESTR lpszStatusText);
    HRESULT EnableModelessSB(BOOL fEnable);
    HRESULT TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    HRESULT BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    HRESULT GetViewStateStream(DWORD grfMode,
                LPSTREAM  *ppStrm);
    HRESULT GetControlWindow(UINT id, HWND * lphwnd);
    HRESULT SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
                LPARAM lParam, LRESULT * pret);
    HRESULT QueryActiveShellView(struct IShellView ** ppshv);
    HRESULT OnViewWindowActive(struct IShellView * ppshv);
    HRESULT SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons,
                UINT uFlags);
};
typedef IVBShellBrowser * LPSHELLBROWSER;
*/
enum {
        SBSC_HIDE = 0,
        SBSC_SHOW = 1,
        SBSC_TOGGLE = 2,
        SBSC_QUERY =  3
};

// CommandTarget ids.
enum {
        SBCMDID_ENABLESHOWTREE,
        SBCMDID_SHOWCONTROL,            // variant vt_i4 = loword = FCW_* hiword = SBSC_*
        SBCMDID_CANCELNAVIGATION,       // cancel last navigation
        SBCMDID_MAYSAVECHANGES,         // about to close and may save changes
        SBCMDID_SETHLINKFRAME,          // variant vt_i4 = phlinkframe
        SBCMDID_ENABLESTOP,             // variant vt_bool = fEnable
        SBCMDID_OPTIONS,                // the view.options page
};


//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

/*
[   odl,
    helpstring("Visual Basic version of ICommDlgBrowser interface"),
    uuid(000214F1-0000-0000-C000-000000000046)
]
interface ICommDlgBrowser : IUnknown {
    // *** ICommDlgBrowser methods ***
    HRESULT OnDefaultCommand(struct IVBShellView * ppshv);
    HRESULT OnStateChange(struct IShellView * ppshv,
                          ULONG uChange);
    HRESULT IncludeObject(struct IVBShellView * ppshv,
                          LPCITEMIDLIST pidl);
};
typedef IVBCommDlgBrowser * LPCOMMDLGBROWSER;
*/


//==========================================================================
//
// Interface:   IShellView
//
// IShellView::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellView::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellView::TranslateAccelerator(lpmsg)
//
//   Similar to IOleInPlaceActiveObject::TranlateAccelerator. The explorer
//  calls this function BEFORE any other translation. Returning S_OK
//  indicates that the message was translated (eaten) and should not be
//  translated or dispatched by the explorer.
//
//
// IShellView::EnableModeless(fEnable)
//   Similar to IOleInPlaceActiveObject::EnableModeless.
//
//
// IShellView::UIActivate(uState)
//
//   The explorer calls this member function whenever the activation
//  state of the view window is changed by a certain event that is
//  NOT caused by the shell view itself.
//
//   SVUIA_DEACTIVATE will be passed when the explorer is about to
//  destroy the shell view window; the shell view is supposed to remove
//  all the extended UIs (typically merged menu and modeless popup windows).
//
//   SVUIA_ACTIVATE_NOFOCUS will be passsed when the shell view is losing
//  the input focus or the shell view has been just created without the
//  input focus; the shell view is supposed to set menuitems appropriate
//  for non-focused state (no selection specific items should be added).
//
//   SVUIA_ACTIVATE_FOCUS will be passed when the explorer has just
//  created the view window with the input focus; the shell view is
//  supposed to set menuitems appropriate for focused state.
//
//   SVUIA_INPLACEACTIVATE(new) will be passed when the shell view is opened
//  within an ActiveX control, which is not a UI active. In this case,
//  the shell view should not merge menus or put toolbas. To be compatible
//  with Win95 client, we don't pass this value unless the view supports
//  IShellView2.
//
//   The shell view should not change focus within this member function.
//  The shell view should not hook the WM_KILLFOCUS message to remerge
//  menuitems. However, the shell view typically hook the WM_SETFOCUS
//  message, and re-merge the menu after calling IShellBrowser::
//  OnViewWindowActivated.
//
//
// IShellView::Refresh()
//
//   The explorer calls this member when the view needs to refresh its
//  contents (such as when the user hits F5 key).
//
//
// IShellView::CreateViewWindow
//
//   This member creates the view window (right-pane of the explorer or the
//  client window of the folder window).
//
//
// IShellView::DestroyViewWindow
//
//   This member destroys the view window.
//
//
// IShellView::GetCurrentInfo
//
//   This member returns the folder settings.
//
//
// IShellView::AddPropertySHeetPages
//
//   The explorer calls this member when it is opening the option property
//  sheet. This allows the view to add additional pages to it.
//
//
// IShellView::SaveViewState()
//
//   The explorer calls this member when the shell view is supposed to
//  store its view settings. The shell view is supposed to get a view
//  stream by calling IShellBrowser::GetViewStateStream and store the
//  current view state into that stream.
//
//
// IShellView::SelectItem(pidlItem, uFlags)
//
//   The explorer calls this member to change the selection state of
//  item(s) within the shell view window.  If pidlItem is NULL and uFlags
//  is SVSI_DESELECTOTHERS, all items should be deselected.
//
//-------------------------------------------------------------------------

//
// uState values for IShellView::UIActivate
//
typedef enum ESVUIA_STATUS {
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} ESVUIA_STATUS;

/*
[   odl,
    helpstring("Visual Basic version of IShellView interface"),
    uuid(000214E3-0000-0000-C000-000000000046)
]
interface IVBShellView : IOleWindow {
    // *** IShellView methods ***

    HRESULT TranslateAccelerator(LPMSG lpmsg);

#ifdef _FIX_ENABLEMODELESS_CONFLICT
    HRESULT EnableModelessSV(BOOL fEnable);
#else
    HRESULT EnableModeless(BOOL fEnable);
#endif

    HRESULT UIActivate(UINT uState);

    HRESULT Refresh();

    HRESULT CreateViewWindow(IShellView  *lpPrevView,
                             LPCFOLDERSETTINGS lpfs,
                             IShellBrowser  * psb,
                             RECT * prcView,
                             HWND  *phWnd);

    HRESULT DestroyViewWindow)(THIS);

    HRESULT GetCurrentInfo(LPFOLDERSETTINGS lpfs);

    HRESULT AddPropertySheetPages(DWORD dwReserved,
                                  LPFNADDPROPSHEETPAGE lpfn,
                                  LPARAM lparam);

    HRESULT SaveViewState();

    HRESULT SelectItem(LPCITEMIDLIST pidlItem,
                       UINT uFlags);

    HRESULT GetItemObject(UINT uItem,
                          REFIID riid,
                          LPVOID ppv);
};
typedef IVBShellView *    LPSHELLVIEW;

typedef UUID SHELLVIEWID;

typedef struct _SV2CVW2_PARAMS {
        DWORD cbSize;

        IShellView *psvPrev;
        FOLDERSETTINGS const *pfs;
        IShellBrowser *psbOwner;
        RECT *prcView;
        SHELLVIEWID const *pvid;

        HWND hwndView;
} SV2CVW2_PARAMS;
typedef SV2CVW2_PARAMS *LPSV2CVW2_PARAMS;

[   odl,
    helpstring("Visual Basic version of IShellView2 interface"),
    uuid(88E39E80-3578-11CF-AE69-08002B2E1262)
]
interface IShellView2 : IShellView {
    // *** IShellView2 methods ***
    HRESULT GetView(SHELLVIEWID* pvid, ULONG uView);
    HRESULT CreateViewWindow2(LPSV2CVW2_PARAMS lpParams);
};
*/

//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------

typedef enum ESTRRET {
    STRRET_WSTR     = 0,          // Use STRRET.pOleStr
    STRRET_OFFSET   = 1,          // Use STRRET.uOffset to Ansi
    STRRET_CSTR     = 2           // Use STRRET.cStr
} ESTRRET;

typedef struct STRRET
{
    ESTRRET uType; // One of the STRRET_* values
    /*
    union
    {
        LPWSTR          pOleStr;        // OLESTR that will be freed
        LPSTR           pStr;           // ANSI string that will be freed (needed?)
        UINT            uOffset;        // Offset into SHITEMID
        char            cStr[260];      // Buffer to fill in (ANSI)
    } DUMMYUNIONNAME;
    */
    BYTE cStr[260]; // MAX_PATH buffer to fill in (ANSI)
} STRRET;
typedef STRRET * LPSTRRET;
// typedef LONG LPSTRRET;


//-------------------------------------------------------------------------
//
// SHGetPathFromIDList
//
//  This function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.
//
//-------------------------------------------------------------------------

// Moved to SHELLAPI.IDL

//-------------------------------------------------------------------------
//
// IEnumIDList interface
//
//  IShellFolder::EnumObjects member returns an IEnumIDList object.
//
//-------------------------------------------------------------------------

[   odl,
    helpstring("Visual Basic version of IShellBrowser interface"),
    uuid(000214F2-0000-0000-C000-000000000046)
]
interface IVBEnumIDList : IUnknown {
    // *** IEnumIDList methods ***

    LONG Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);

    LONG Skip(ULONG celt);

    LONG Reset();

    LONG Clone(IVBEnumIDList **ppenum);

};
typedef IVBEnumIDList      *LPENUMIDLIST;

//-------------------------------------------------------------------------
//
// IShellFolder interface
//
//
// [Member functions]
//
// IShellFolder::BindToObject(pidl, pbc, riid, ppvOut)
//   This function returns an instance of a sub-folder which is specified
//  by the IDList (pidl).
//
// IShellFolder::BindToStorage(pidl, pbc, riid, ppvObj)
//   This function returns a storage instance of a sub-folder which is
//  specified by the IDList (pidl). The shell never calls this member
//  function in the first release of Win95.
//
// IShellFolder::CompareIDs(lParam, pidl1, pidl2)
//   This function compares two IDLists and returns the result. The shell
//  explorer always passes 0 as lParam, which indicates "sort by name".
//  It should return 0 (as CODE of the scode), if two id indicates the
//  same object; negative value if pidl1 should be placed before pidl2;
//  positive value if pidl2 should be placed before pidl1.
//
// IShellFolder::CreateViewObject(hwndOwner, riid, ppvOut)
//   This function creates a view object of the folder itself. The view
//  object is a difference instance from the shell folder object.
//   "hwndOwner" can be used  as the owner window of its dialog box or
//      menu during the lifetime of the view object.
//  instance which has only one reference count. The explorer may create
//  more than one instances of view object from one shell folder object
//  and treat them as separate instances.
//
// IShellFolder::GetAttributesOf(cidl, apidl, prgfInOut)
//   This function returns the attributes of specified objects in that
//  folder. "cidl" and "apidl" specifies objects. "apidl" contains only
//  simple IDLists. The explorer initializes *prgfInOut with a set of
//  flags to be evaluated. The shell folder may optimize the operation
//  by not returning unspecified flags.
//
// IShellFolder::GetUIObjectOf(hwndOwner, cidl, apidl, riid, prgfInOut, ppvOut)
//   This function creates a UI object to be used for specified objects.
//  The shell explorer passes either IID_IDataObject (for transfer operation)
//  or IID_IContextMenu (for context menu operation) as riid.
//
// IShellFolder::GetDisplayNameOf
//   This function returns the display name of the specified object.
//  If the ID contains the display name (in the locale character set),
//  it returns the offset to the name. Otherwise, it returns a pointer
//  to the display name string (UNICODE), which is allocated by the
//  task allocator, or fills in a buffer.
//
// IShellFolder::SetNameOf
//   This function sets the display name of the specified object.
//  If it changes the ID as well, it returns the new ID which is
//  alocated by the task allocator.
//
//-------------------------------------------------------------------------

// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
typedef enum ESHGDN
{
    SHGDN_NORMAL            = 0,        // default (display purpose)
    SHGDN_INFOLDER          = 1,        // displayed under a folder (relative)
    SHGDN_FORADDRESSBAR     = 0x4000,   // for displaying in the address (drives dropdown) bar
    SHGDN_FORPARSING        = 0x8000,   // for ParseDisplayName or path
} ESHGDN;

// IShellFolder::EnumObjects
typedef enum ESHCONTF
{
    SHCONTF_FOLDERS         = 32,       // for shell browser
    SHCONTF_NONFOLDERS      = 64,       // for default view
    SHCONTF_INCLUDEHIDDEN   = 128,      // for hidden/system objects
} ESHCONTF;

// IShellFolder::GetAttributesOf flags
typedef enum ESFGAO {
    SFGAO_CANCOPY           = 0x00000001,     // DROPEFFECT_COPY Objects can be copied
    SFGAO_CANMOVE           = 0x00000002,     // Objects can be moved
    SFGAO_CANLINK           = 0x00000004,     // Objects can be linked
    SFGAO_CANRENAME         = 0x00000010,     // Objects can be renamed
    SFGAO_CANDELETE         = 0x00000020,     // Objects can be deleted
    SFGAO_HASPROPSHEET      = 0x00000040,     // Objects have property sheets
    SFGAO_DROPTARGET        = 0x00000100,     // Objects are drop target
    SFGAO_CAPABILITYMASK    = 0x00000177,
    SFGAO_LINK              = 0x00010000,     // Shortcut (link)
    SFGAO_SHARE             = 0x00020000,     // shared
    SFGAO_READONLY          = 0x00040000,     // read-only
    SFGAO_GHOSTED           = 0x00080000,     // ghosted icon
    SFGAO_DISPLAYATTRMASK   = 0x000F0000,
    SFGAO_FILESYSANCESTOR   = 0x10000000,     // It contains file system folder
    SFGAO_FOLDER            = 0x20000000,     // It's a folder.
    SFGAO_FILESYSTEM        = 0x40000000,     // is a file system thing (file/folder/root)
    SFGAO_HASSUBFOLDER      = 0x80000000,     // Expandable in the map pane
    SFGAO_CONTENTSMASK      = 0x80000000,
    SFGAO_VALIDATE          = 0x01000000,     // invalidate cached information
    SFGAO_REMOVABLE         = 0x02000000,     // is this removeable media?
    SFGAO_COMPRESSED        = 0x04000000      // Object is compressed (use alt color)
} ESFGAO;

[   odl,
    helpstring("Visual Basic version of IShellFolder interface"),
    uuid(000214E6-0000-0000-C000-000000000046)
]
interface IVBShellFolder : IUnknown {
    // *** IShellFolder methods ***
    HRESULT ParseDisplayName(HWND hwndOwner,
                             LONG /* LPBC */ pbcReserved,
                             LPOLESTR lpszDisplayName,
                             ULONG * pchEaten,
                             LPITEMIDLIST * ppidl,
                             ULONG *pdwAttributes);

    HRESULT EnumObjects(HWND hwndOwner,
                        ESHCONTF grfFlags,
                        LPENUMIDLIST * ppenumIDList);

    HRESULT BindToObject(LPCITEMIDLIST pidl,
                         LONG /* LPBC */ pbcReserved,
                         REFIID riid,
                         LPVOID ppvOut);

    HRESULT BindToStorage(LPCITEMIDLIST pidl,
                          LONG /* LPBC */ pbcReserved,
                          REFIID riid,
                          LPVOID ppvObj);

    HRESULT CompareIDs(LPARAM lParam,
                       LPCITEMIDLIST pidl1,
                       LPCITEMIDLIST pidl2);

    HRESULT CreateViewObject(HWND hwndOwner,
                             REFIID riid,
                             LPVOID ppvOut);

    HRESULT GetAttributesOf(UINT cidl,
                            LPCITEMIDLIST * apidl,
                            ESFGAO * rgfInOut);

    HRESULT GetUIObjectOf(HWND hwndOwner,
                          UINT cidl,
                          LPCITEMIDLIST * apidl,
                          REFIID riid,
                          UINT * prgfInOut,
                          LPVOID ppvOut);

    HRESULT GetDisplayNameOf(LPCITEMIDLIST pidl,
                             ESHGDN uFlags,
                             LPSTRRET lpName);

    HRESULT SetNameOf(HWND hwndOwner,
                      LPCITEMIDLIST pidl,
                      LPCOLESTR lpszName,
                      ESHCONTF uFlags,
                      LPITEMIDLIST * ppidlOut);
};
typedef IVBShellFolder * LPSHELLFOLDER;

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================
/*
#define CFSTR_SHELLIDLIST       TEXT("Shell IDList Array")      // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET TEXT("Shell Object Offsets")    // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES      TEXT("Net Resource")            // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA   TEXT("FileGroupDescriptor")     // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW   TEXT("FileGroupDescriptorW")    // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS      TEXT("FileContents")            // CF_FILECONTENTS
#define CFSTR_FILENAMEA         TEXT("FileName")                // CF_FILENAMEA
#define CFSTR_FILENAMEW         TEXT("FileNameW")               // CF_FILENAMEW
#define CFSTR_PRINTERGROUP      TEXT("PrinterFriendlyName")     // CF_PRINTERS
#define CFSTR_FILENAMEMAP       TEXT("FileNameMap")             // CF_FILENAMEMAP
#define CFSTR_PREFERREDDROPEFFECT TEXT("Preferred DropEffect")

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#endif

//
// CF_OBJECTPOSITIONS
//
//



#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version
//
// format of CF_NETRESOURCE
//
typedef struct NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;

//
// format of CF_IDLIST
//
typedef struct CIDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;
*/

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum FD_FLAGS {
    FD_CLSID            = 0x0001,
    FD_SIZEPOINT        = 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE         = 0x0040,
    FD_LINKUI           = 0x8000,       // 'link' UI is prefered
} FD_FLAGS;

typedef struct FILEDESCRIPTOR { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    CURRENCY ftCreationTime;
    CURRENCY ftLastAccessTime;
    CURRENCY ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
#if UNICODE
    BYTE cFileName[ 260 * 2 /* MAX_PATH */ ];
#else
    BYTE cFileName[ 260 /* MAX_PATH */ ];
#endif
} FILEDESCRIPTOR, *LPFILEDESCRIPTOR;

typedef struct FILEDESCRIPTORO { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
#if UNICODE
    BYTE cFileName[ 260 * 2 /* MAX_PATH */ ];
#else
    BYTE cFileName[ 260 /* MAX_PATH */ ];
#endif
} FILEDESCRIPTORO, *LPFILEDESCRIPTORO;

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct FILEGROUPDESCRIPTOR { // fgd
     UINT cItems;
     FILEDESCRIPTOR fgd[1];
} FILEGROUPDESCRIPTOR, * LPFILEGROUPDESCRIPTOR;

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINTL pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, * LPDROPFILES;


#if 0
//====== File System Notification APIs ===============================
//



//
//  File System Notification flags
//



#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L
#define SHCNE_EXTENDED_EVENT      0x00080000L // Extended Event.

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0D81E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#define SHCNEE_THEMECHANGED       0x00000001L  // The theme changed


// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000

#ifdef UNICODE
#define SHCNF_PATH      SHCNF_PATHW
#define SHCNF_PRINTER   SHCNF_PRINTERW
#else
#define SHCNF_PATH      SHCNF_PATHA
#define SHCNF_PRINTER   SHCNF_PRINTERA
#endif
#endif

// QueryContextMenu uFlags
typedef enum QUERYCONTEXTMENUFLAGS {
    CMF_NORMAL              = 0x00000000,
    CMF_DEFAULTONLY         = 0x00000001,
    CMF_VERBSONLY           = 0x00000002,
    CMF_EXPLORE             = 0x00000004,
    CMF_NOVERBS             = 0x00000008,
    CMF_CANRENAME           = 0x00000010,
    CMF_NODEFAULT           = 0x00000020,
    CMF_INCLUDESTATIC       = 0x00000040,
    CMF_RESERVED            = 0xffff0000,     // View specific

    // GetCommandString uFlags
    GCS_VERBA               = 0x00000000,     // canonical verb
    GCS_HELPTEXTA           = 0x00000001,     // help text (for status bar)
    GCS_VALIDATEA           = 0x00000002,     // validate command exists
    GCS_VERBW               = 0x00000004,     // canonical verb (unicode)
    GCS_HELPTEXTW           = 0x00000005,     // help text (unicode version)
    GCS_VALIDATEW           = 0x00000006,     // validate command exists (unicode)
    GCS_UNICODE             = 0x00000004      // for bit testing - Unicode string
} QUERYCONTEXTMENUFLAGS;

#if 0
#ifdef UNICODE
#define GCS_VERB        GCS_VERBW
#define GCS_HELPTEXT    GCS_HELPTEXTW
#define GCS_VALIDATE    GCS_VALIDATEW
#else
#define GCS_VERB        GCS_VERBA
#define GCS_HELPTEXT    GCS_HELPTEXTA
#define GCS_VALIDATE    GCS_VALIDATEA
#endif

#define CMDSTR_NEWFOLDERA   "NewFolder"
#define CMDSTR_VIEWLISTA    "ViewList"
#define CMDSTR_VIEWDETAILSA "ViewDetails"
#define CMDSTR_NEWFOLDERW   L"NewFolder"
#define CMDSTR_VIEWLISTW    L"ViewList"
#define CMDSTR_VIEWDETAILSW L"ViewDetails"

#ifdef UNICODE
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW
#else
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA
#endif

#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY
#define CMIC_MASK_ICON          SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE
#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE
#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME
#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM
#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE
#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK


// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0)
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1)
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)
//
// Values for wFlags parameter of ISB::BrowseObject() member.
//
#define SBSP_DEFBROWSER  0x0000
#define SBSP_SAMEBROWSER 0x0001
#define SBSP_NEWBROWSER  0x0002

#define SBSP_DEFMODE     0x0000
#define SBSP_OPENMODE    0x0010
#define SBSP_EXPLOREMODE 0x0020

#define SBSP_ABSOLUTE    0x0000
#define SBSP_RELATIVE    0x1000
#define SBSP_PARENT      0x2000

#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define SBSP_REDIRECT                     0x40000000

//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
#define FCW_STATUS      0x0001
#define FCW_TOOLBAR     0x0002
#define FCW_TREE        0x0003

//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004

#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003

//
// shellview select item flags
//
#define SVSI_DESELECT   0x0000
#define SVSI_SELECT     0x0001
#define SVSI_EDIT       0x0003  // includes select
#define SVSI_DESELECTOTHERS 0x0004
#define SVSI_ENSUREVISIBLE  0x0008
#define SVSI_FOCUSED        0x0010

//
// shellview get item object flags
//
#define SVGIO_BACKGROUND    0x00000000
#define SVGIO_SELECTION     0x00000001
#define SVGIO_ALLVIEW       0x00000002

#define SV2GV_CURRENTVIEW ((UINT)-1)
#define SV2GV_DEFAULTVIEW ((UINT)-2)

#endif

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
typedef enum WPOFLAGS {
    WPSTYLE_CENTER    =  0,
    WPSTYLE_TILE      =  1,
    WPSTYLE_STRETCH   =  2,
    WPSTYLE_MAX       =  3
} WPOFLAGS;

typedef struct WALLPAPEROPT {
    DWORD      dwSize;     // size of this Structure.
    WPOFLAGS   dwStyle;    // WPSTYLE_* mentioned above
} WALLPAPEROPT, *LPWALLPAPEROPT;

typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct COMPONENTSOPT {
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
} COMPONENTSOPT, *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct COMPPOS {
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
} COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct COMPONENT {
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled? 
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[260];          // Friendly name of component.
    WCHAR   wszSource[2083]; //URL of the component. INTERNET_MAX_URL_LENGTH
    WCHAR   wszSubscribedURL[2083]; //Subscrined URL
} COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;

////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
typedef enum ADACFLAGS {
    AD_APPLY_SAVE   =      0x00000001,
    AD_APPLY_HTMLGEN =     0x00000002,
    AD_APPLY_REFRESH =     0x00000004, 
    AD_APPLY_ALL   =       0x00000007,
    AD_APPLY_FORCE =       0x00000008,
    AD_APPLY_BUFFERED_REFRESH = 0x00000010
} ADACFLAGS;

////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()
typedef enum ADCOMPFLAGS {
    COMP_ELEM_TYPE          =  0x00000001,
    COMP_ELEM_CHECKED       =  0x00000002,
    COMP_ELEM_DIRTY         =  0x00000004,
    COMP_ELEM_NOSCROLL      =  0x00000008,
    COMP_ELEM_POS_LEFT      =  0x00000010,
    COMP_ELEM_POS_TOP       =  0x00000020,
    COMP_ELEM_SIZE_WIDTH    =  0x00000040,
    COMP_ELEM_SIZE_HEIGHT   =  0x00000080,
    COMP_ELEM_POS_ZINDEX    =  0x00000100,
    COMP_ELEM_SOURCE        =  0x00000200,
    COMP_ELEM_FRIENDLYNAME  =  0x00000400,
    COMP_ELEM_SUBSCRIBEDURL =  0x00000800,
    COMP_ELEM_ALL           =  0x00000FFF
} ADCOMPFLAGS;


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum DTI_ADTIWUI {
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
} DTI_ADTIWUI;


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
typedef enum ADURLFLAGS  {
    ADDURL_SILENT    =       0X0001
} ADURLFLAGS;


//
//  Interface for manipulating the Active Desktop.
//

[   
	odl,
	helpstring("Visual Basic version of IActiveDesktop interface"),
    uuid(F490EB00-1240-11D1-9888-006097DEACF9)
]
interface IVBActiveDesktop : IUnknown {
   // *** IActiveDesktop methods ***

    HRESULT ApplyChanges([in] ADACFLAGS dwFlags);
    HRESULT GetWallpaper([in, out] LPWSTR pwszWallpaper, 
						 [in] int cchWallpaper, [in] DWORD dwReserved);
    HRESULT SetWallpaper([in, out] LPCWSTR pwszWallpaper, [in] DWORD dwReserved);
    HRESULT GetWallpaperOptions([in, out] LPWALLPAPEROPT pwpo, [in] DWORD dwReserved);
    HRESULT SetWallpaperOptions([in] LPCWALLPAPEROPT pwpo, [in] DWORD dwReserved);
    HRESULT GetPattern([in, out] LPWSTR pwszPattern, 
					   [in] int cchPattern, [in] DWORD dwReserved);
    HRESULT SetPattern([in] LPCWSTR pwszPattern, [in] DWORD dwReserved);
    HRESULT GetDesktopItemOptions([in, out] LPCOMPONENTSOPT pco, [in] DWORD dwReserved);
    HRESULT SetDesktopItemOptions([in] LPCCOMPONENTSOPT pco, [in] DWORD dwReserved);
    HRESULT AddDesktopItem([in] LPCCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT AddDesktopItemWithUI([in] HWND hwnd,
								 [in, out] LPCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT ModifyDesktopItem([in, out] LPCCOMPONENT pcomp,[in] ADCOMPFLAGS dwFlags);
    HRESULT RemoveDesktopItem([in, out] LPCCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT GetDesktopItemCount([in, out] LPINT lpiCount, 
								[in] DWORD dwReserved);
    HRESULT GetDesktopItem([in] int nComponent,
						   [in, out] LPCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT GetDesktopItemByID([in] DWORD dwID,
							   [in, out] LPCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT GenerateDesktopItemHtml([in] LPCWSTR pwszFileName,
									[in, out] LPCOMPONENT pcomp, [in] DWORD dwReserved);
    HRESULT AddUrl([in] HWND hwnd,[in] LPCWSTR pszSource,
				   [in, out] LPCOMPONENT pcomp, [in] ADURLFLAGS dwFlags);
    HRESULT GetDesktopItemBySource([in] LPCWSTR pwszSource, 
								   [in, out] LPCOMPONENT pcomp, [in] DWORD dwReserved);
};

[   uuid(75048700-EF1F-11D0-9888-006097DEACF9),
    helpstring("Visual Basic CActiveDesktop class")
]
coclass CActiveDesktop {
    [default]
    interface IVBActiveDesktop;
};

